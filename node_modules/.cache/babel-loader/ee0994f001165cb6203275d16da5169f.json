{"ast":null,"code":"const Util = require('../../util/common');\n\nconst Shape = require('./shape');\n\nconst Vector2 = require('../../graphic/util/vector2');\n\nconst Global = require('../../global');\n\nfunction getRectPoints(cfg) {\n  const {\n    x,\n    y,\n    y0,\n    size\n  } = cfg;\n  let ymin = y0;\n  let ymax = y;\n\n  if (Util.isArray(y)) {\n    ymax = y[1];\n    ymin = y[0];\n  }\n\n  let xmin;\n  let xmax;\n\n  if (Util.isArray(x)) {\n    xmin = x[0];\n    xmax = x[1];\n  } else {\n    xmin = x - size / 2;\n    xmax = x + size / 2;\n  }\n\n  return [{\n    x: xmin,\n    y: ymin\n  }, {\n    x: xmin,\n    y: ymax\n  }, {\n    x: xmax,\n    y: ymax\n  }, {\n    x: xmax,\n    y: ymin\n  }];\n}\n\nfunction getRectRange(points) {\n  const xValues = [];\n  const yValues = [];\n\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    xValues.push(point.x);\n    yValues.push(point.y);\n  }\n\n  const xMin = Math.min.apply(null, xValues);\n  const yMin = Math.min.apply(null, yValues);\n  const xMax = Math.max.apply(null, xValues);\n  const yMax = Math.max.apply(null, yValues);\n  return {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin\n  };\n}\n\nfunction getMiddlePoint(a, b) {\n  const x = (a.x - b.x) / 2 + b.x;\n  const y = (a.y - b.y) / 2 + b.y;\n  return {\n    x,\n    y\n  };\n}\n\nconst Interval = Shape.registerFactory('interval', {\n  defaultShapeType: 'rect',\n\n  getDefaultPoints(cfg) {\n    return getRectPoints(cfg);\n  }\n\n});\nShape.registerShape('interval', 'rect', {\n  draw(cfg, container) {\n    const points = this.parsePoints(cfg.points);\n    const style = Util.mix({\n      fill: cfg.color\n    }, Global.shape.interval, cfg.style);\n\n    if (cfg.isInCircle) {\n      let newPoints = points.slice(0);\n\n      if (this._coord.transposed) {\n        newPoints = [points[0], points[3], points[2], points[1]];\n      }\n\n      const {\n        x,\n        y\n      } = cfg.center;\n      const v = [1, 0];\n      const v0 = [newPoints[0].x - x, newPoints[0].y - y];\n      const v1 = [newPoints[1].x - x, newPoints[1].y - y];\n      const v2 = [newPoints[2].x - x, newPoints[2].y - y];\n      let startAngle = Vector2.angleTo(v, v1);\n      let endAngle = Vector2.angleTo(v, v2);\n      const r0 = Vector2.length(v0);\n      const r = Vector2.length(v1);\n\n      if (startAngle >= 1.5 * Math.PI) {\n        startAngle = startAngle - 2 * Math.PI;\n      }\n\n      if (endAngle >= 1.5 * Math.PI) {\n        endAngle = endAngle - 2 * Math.PI;\n      }\n\n      return container.addShape('Sector', {\n        className: 'interval',\n        attrs: Util.mix({\n          x,\n          y,\n          r,\n          r0,\n          startAngle,\n          endAngle\n        }, style)\n      });\n    }\n\n    const rectCfg = getRectRange(points);\n    return container.addShape('rect', {\n      className: 'interval',\n      attrs: Util.mix(rectCfg, style)\n    });\n  }\n\n}); // 金字塔 和 漏斗图\n\n['pyramid', 'funnel'].forEach(shapeType => {\n  Shape.registerShape('interval', shapeType, {\n    getPoints(cfg) {\n      cfg.size = cfg.size * 2; // 漏斗图的 size 是柱状图的两倍\n\n      return getRectPoints(cfg);\n    },\n\n    draw(cfg, container) {\n      const points = this.parsePoints(cfg.points);\n      const nextPoints = this.parsePoints(cfg.nextPoints);\n      let polygonPoints = null;\n\n      if (nextPoints) {\n        polygonPoints = [points[0], points[1], nextPoints[1], nextPoints[0]];\n      } else {\n        polygonPoints = [points[0], points[1]]; // pyramid 顶部是三角形，所以取中心点就好了，funnel顶部是长方形\n\n        if (shapeType === 'pyramid') {\n          polygonPoints.push(getMiddlePoint(points[2], points[3]));\n        } else {\n          polygonPoints.push(points[2], points[3]);\n        }\n      }\n\n      const attrs = Util.mix({\n        fill: cfg.color,\n        points: polygonPoints\n      }, Global.shape.interval, cfg.style);\n      return container.addShape('polygon', {\n        className: 'interval',\n        attrs\n      });\n    }\n\n  });\n});\nmodule.exports = Interval;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/geom/shape/interval.js"],"names":["Util","require","Shape","Vector2","Global","getRectPoints","cfg","x","y","y0","size","ymin","ymax","isArray","xmin","xmax","getRectRange","points","xValues","yValues","i","len","length","point","push","xMin","Math","min","apply","yMin","xMax","max","yMax","width","height","getMiddlePoint","a","b","Interval","registerFactory","defaultShapeType","getDefaultPoints","registerShape","draw","container","parsePoints","style","mix","fill","color","shape","interval","isInCircle","newPoints","slice","_coord","transposed","center","v","v0","v1","v2","startAngle","angleTo","endAngle","r0","r","PI","addShape","className","attrs","rectCfg","forEach","shapeType","getPoints","nextPoints","polygonPoints","module","exports"],"mappings":"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","sourcesContent":["const Util = require('../../util/common');\nconst Shape = require('./shape');\nconst Vector2 = require('../../graphic/util/vector2');\nconst Global = require('../../global');\n\nfunction getRectPoints(cfg) {\n  const { x, y, y0, size } = cfg;\n\n  let ymin = y0;\n  let ymax = y;\n  if (Util.isArray(y)) {\n    ymax = y[1];\n    ymin = y[0];\n  }\n\n  let xmin;\n  let xmax;\n  if (Util.isArray(x)) {\n    xmin = x[0];\n    xmax = x[1];\n  } else {\n    xmin = x - size / 2;\n    xmax = x + size / 2;\n  }\n\n  return [\n    { x: xmin, y: ymin },\n    { x: xmin, y: ymax },\n    { x: xmax, y: ymax },\n    { x: xmax, y: ymin }\n  ];\n}\n\nfunction getRectRange(points) {\n  const xValues = [];\n  const yValues = [];\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    xValues.push(point.x);\n    yValues.push(point.y);\n  }\n  const xMin = Math.min.apply(null, xValues);\n  const yMin = Math.min.apply(null, yValues);\n  const xMax = Math.max.apply(null, xValues);\n  const yMax = Math.max.apply(null, yValues);\n\n  return {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin\n  };\n}\n\nfunction getMiddlePoint(a, b) {\n  const x = (a.x - b.x) / 2 + b.x;\n  const y = (a.y - b.y) / 2 + b.y;\n  return { x, y };\n}\n\nconst Interval = Shape.registerFactory('interval', {\n  defaultShapeType: 'rect',\n  getDefaultPoints(cfg) {\n    return getRectPoints(cfg);\n  }\n});\n\nShape.registerShape('interval', 'rect', {\n  draw(cfg, container) {\n    const points = this.parsePoints(cfg.points);\n    const style = Util.mix({\n      fill: cfg.color\n    }, Global.shape.interval, cfg.style);\n    if (cfg.isInCircle) {\n      let newPoints = points.slice(0);\n      if (this._coord.transposed) {\n        newPoints = [ points[0], points[3], points[2], points[1] ];\n      }\n\n      const { x, y } = cfg.center;\n      const v = [ 1, 0 ];\n      const v0 = [ newPoints[0].x - x, newPoints[0].y - y ];\n      const v1 = [ newPoints[1].x - x, newPoints[1].y - y ];\n      const v2 = [ newPoints[2].x - x, newPoints[2].y - y ];\n\n      let startAngle = Vector2.angleTo(v, v1);\n      let endAngle = Vector2.angleTo(v, v2);\n      const r0 = Vector2.length(v0);\n      const r = Vector2.length(v1);\n\n      if (startAngle >= 1.5 * Math.PI) {\n        startAngle = startAngle - 2 * Math.PI;\n      }\n\n      if (endAngle >= 1.5 * Math.PI) {\n        endAngle = endAngle - 2 * Math.PI;\n      }\n\n      return container.addShape('Sector', {\n        className: 'interval',\n        attrs: Util.mix({\n          x,\n          y,\n          r,\n          r0,\n          startAngle,\n          endAngle\n        }, style)\n      });\n    }\n\n    const rectCfg = getRectRange(points);\n\n    return container.addShape('rect', {\n      className: 'interval',\n      attrs: Util.mix(rectCfg, style)\n    });\n  }\n});\n\n// 金字塔 和 漏斗图\n[ 'pyramid', 'funnel' ].forEach(shapeType => {\n  Shape.registerShape('interval', shapeType, {\n    getPoints(cfg) {\n      cfg.size = cfg.size * 2; // 漏斗图的 size 是柱状图的两倍\n      return getRectPoints(cfg);\n    },\n    draw(cfg, container) {\n      const points = this.parsePoints(cfg.points);\n      const nextPoints = this.parsePoints(cfg.nextPoints);\n\n      let polygonPoints = null;\n      if (nextPoints) {\n        polygonPoints = [ points[0], points[1], nextPoints[1], nextPoints[0] ];\n      } else {\n        polygonPoints = [\n          points[0],\n          points[1]\n        ];\n        // pyramid 顶部是三角形，所以取中心点就好了，funnel顶部是长方形\n        if (shapeType === 'pyramid') {\n          polygonPoints.push(getMiddlePoint(points[2], points[3]));\n        } else {\n          polygonPoints.push(points[2], points[3]);\n        }\n      }\n\n      const attrs = Util.mix({\n        fill: cfg.color,\n        points: polygonPoints\n      }, Global.shape.interval, cfg.style);\n\n      return container.addShape('polygon', {\n        className: 'interval',\n        attrs\n      });\n    }\n  });\n});\n\nmodule.exports = Interval;\n"]},"metadata":{},"sourceType":"script"}