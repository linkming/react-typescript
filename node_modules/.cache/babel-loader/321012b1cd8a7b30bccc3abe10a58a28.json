{"ast":null,"code":"const Util = require('../../util/common');\n\nconst Axis = require('../../component/axis/');\n\nconst Global = require('../../global');\n\nconst {\n  Shape\n} = require('../../graphic/index');\n\nfunction formatTicks(ticks) {\n  const tmp = ticks.slice(0);\n\n  if (tmp.length > 0) {\n    const first = tmp[0];\n    const last = tmp[tmp.length - 1];\n\n    if (first.value !== 0) {\n      tmp.unshift({\n        value: 0\n      });\n    }\n\n    if (last.value !== 1) {\n      tmp.push({\n        value: 1\n      });\n    }\n  }\n\n  return tmp;\n}\n\nclass AxisController {\n  constructor(cfg) {\n    this.axisCfg = {};\n    this.frontPlot = null;\n    this.backPlot = null;\n    this.axes = {}; // store the axes's options\n\n    Util.mix(this, cfg);\n  }\n\n  _isHide(field) {\n    const axisCfg = this.axisCfg;\n    return !axisCfg || axisCfg[field] === false;\n  }\n\n  _getLinePosition(scale, dimType, index, transposed) {\n    let position = '';\n    const field = scale.field;\n    const axisCfg = this.axisCfg;\n\n    if (axisCfg[field] && axisCfg[field].position) {\n      position = axisCfg[field].position;\n    } else if (dimType === 'x') {\n      position = transposed ? 'left' : 'bottom';\n    } else if (dimType === 'y') {\n      position = index ? 'right' : 'left';\n\n      if (transposed) {\n        position = 'bottom';\n      }\n    }\n\n    return position;\n  }\n\n  _getLineCfg(coord, dimType, position) {\n    let start;\n    let end;\n    let factor = 1; // Mark clockwise or counterclockwise\n\n    if (dimType === 'x') {\n      start = {\n        x: 0,\n        y: 0\n      };\n      end = {\n        x: 1,\n        y: 0\n      };\n    } else {\n      if (position === 'right') {\n        // there will be several y axes\n        start = {\n          x: 1,\n          y: 0\n        };\n        end = {\n          x: 1,\n          y: 1\n        };\n      } else {\n        start = {\n          x: 0,\n          y: 0\n        };\n        end = {\n          x: 0,\n          y: 1\n        };\n        factor = -1;\n      }\n    }\n\n    if (coord.transposed) {\n      factor *= -1;\n    }\n\n    return {\n      offsetFactor: factor,\n      start: coord.convertPoint(start),\n      end: coord.convertPoint(end)\n    };\n  }\n\n  _getCircleCfg(coord) {\n    return {\n      startAngle: coord.startAngle,\n      endAngle: coord.endAngle,\n      center: coord.center,\n      radius: coord.circleRadius\n    };\n  }\n\n  _getRadiusCfg(coord) {\n    const transposed = coord.transposed;\n    let start;\n    let end;\n\n    if (transposed) {\n      start = {\n        x: 0,\n        y: 0\n      };\n      end = {\n        x: 1,\n        y: 0\n      };\n    } else {\n      start = {\n        x: 0,\n        y: 0\n      };\n      end = {\n        x: 0,\n        y: 1\n      };\n    }\n\n    return {\n      offsetFactor: -1,\n      start: coord.convertPoint(start),\n      end: coord.convertPoint(end)\n    };\n  }\n\n  _getAxisCfg(coord, scale, verticalScale, dimType, defaultCfg) {\n    const self = this;\n    const axisCfg = this.axisCfg;\n    const ticks = scale.getTicks();\n    const cfg = Util.deepMix({\n      ticks,\n      frontContainer: this.frontPlot,\n      backContainer: this.backPlot\n    }, defaultCfg, axisCfg[scale.field]);\n    const labels = [];\n    const label = cfg.label;\n    const count = ticks.length;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let labelCfg = label;\n    Util.each(ticks, (tick, index) => {\n      if (Util.isFunction(label)) {\n        const executedLabel = label(tick.text, index, count);\n        labelCfg = executedLabel ? Util.mix({}, Global._defaultAxis.label, executedLabel) : null;\n      }\n\n      if (labelCfg) {\n        const textStyle = {};\n\n        if (labelCfg.textAlign) {\n          textStyle.textAlign = labelCfg.textAlign;\n        }\n\n        if (labelCfg.textBaseline) {\n          textStyle.textBaseline = labelCfg.textBaseline;\n        }\n\n        const axisLabel = new Shape.Text({\n          className: 'axis-label',\n          attrs: Util.mix({\n            x: 0,\n            y: 0,\n            text: tick.text,\n            fontFamily: self.chart.get('canvas').get('fontFamily')\n          }, labelCfg),\n          value: tick.value,\n          textStyle,\n          top: labelCfg.top,\n          context: self.chart.get('canvas').get('context')\n        });\n        labels.push(axisLabel);\n        const {\n          width,\n          height\n        } = axisLabel.getBBox();\n        maxWidth = Math.max(maxWidth, width);\n        maxHeight = Math.max(maxHeight, height);\n      }\n    });\n    cfg.labels = labels;\n    cfg.maxWidth = maxWidth;\n    cfg.maxHeight = maxHeight;\n    return cfg;\n  }\n\n  _createAxis(coord, scale, verticalScale, dimType, index = '') {\n    const self = this;\n    const coordType = coord.type;\n    const transposed = coord.transposed;\n    let type;\n    let key;\n    let defaultCfg;\n\n    if (coordType === 'cartesian' || coordType === 'rect') {\n      const position = self._getLinePosition(scale, dimType, index, transposed);\n\n      defaultCfg = Global.axis[position];\n      defaultCfg.position = position;\n      type = 'Line';\n      key = position;\n    } else {\n      if (dimType === 'x' && !transposed || dimType === 'y' && transposed) {\n        defaultCfg = Global.axis.circle;\n        type = 'Circle';\n        key = 'circle';\n      } else {\n        defaultCfg = Global.axis.radius;\n        type = 'Line';\n        key = 'radius';\n      }\n    }\n\n    const cfg = self._getAxisCfg(coord, scale, verticalScale, dimType, defaultCfg);\n\n    cfg.type = type;\n    cfg.dimType = dimType;\n    cfg.verticalScale = verticalScale;\n    cfg.index = index;\n    this.axes[key] = cfg;\n  }\n\n  createAxis(coord, xScale, yScales) {\n    const self = this;\n\n    if (xScale && !self._isHide(xScale.field)) {\n      self._createAxis(coord, xScale, yScales[0], 'x');\n    }\n\n    Util.each(yScales, function (yScale, index) {\n      if (!self._isHide(yScale.field)) {\n        self._createAxis(coord, yScale, xScale, 'y', index);\n      }\n    });\n    const axes = this.axes;\n    const chart = self.chart;\n\n    if (chart._isAutoPadding()) {\n      const userPadding = Util.parsePadding(chart.get('padding'));\n      const appendPadding = Util.parsePadding(chart.get('appendPadding'));\n      const legendRange = chart.get('legendRange') || {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      const padding = [userPadding[0] === 'auto' ? legendRange.top + appendPadding[0] * 2 : userPadding[0], userPadding[1] === 'auto' ? legendRange.right + appendPadding[1] : userPadding[1], userPadding[2] === 'auto' ? legendRange.bottom + appendPadding[2] : userPadding[2], userPadding[3] === 'auto' ? legendRange.left + appendPadding[3] : userPadding[3]];\n\n      if (coord.isPolar) {\n        const circleAxis = axes.circle;\n\n        if (circleAxis) {\n          const {\n            maxHeight,\n            maxWidth,\n            labelOffset\n          } = circleAxis;\n          padding[0] += maxHeight + labelOffset;\n          padding[1] += maxWidth + labelOffset;\n          padding[2] += maxHeight + labelOffset;\n          padding[3] += maxWidth + labelOffset;\n        }\n      } else {\n        if (axes.right && userPadding[1] === 'auto') {\n          const {\n            maxWidth,\n            labelOffset\n          } = axes.right;\n          padding[1] += maxWidth + labelOffset;\n        }\n\n        if (axes.left && userPadding[3] === 'auto') {\n          const {\n            maxWidth,\n            labelOffset\n          } = axes.left;\n          padding[3] += maxWidth + labelOffset;\n        }\n\n        if (axes.bottom && userPadding[2] === 'auto') {\n          const {\n            maxHeight,\n            labelOffset\n          } = axes.bottom;\n          padding[2] += maxHeight + labelOffset;\n        }\n      }\n\n      chart.set('_padding', padding);\n\n      chart._updateLayout(padding);\n    }\n\n    Util.each(axes, axis => {\n      const {\n        type,\n        grid,\n        verticalScale,\n        ticks,\n        dimType,\n        position,\n        index\n      } = axis;\n      let appendCfg;\n\n      if (coord.isPolar) {\n        if (type === 'Line') {\n          appendCfg = self._getRadiusCfg(coord);\n        } else if (type === 'Circle') {\n          appendCfg = self._getCircleCfg(coord);\n        }\n      } else {\n        appendCfg = self._getLineCfg(coord, dimType, position);\n      }\n\n      if (grid && verticalScale) {\n        const gridPoints = [];\n        const verticalTicks = formatTicks(verticalScale.getTicks());\n        Util.each(ticks, tick => {\n          const subPoints = [];\n          Util.each(verticalTicks, verticalTick => {\n            const x = dimType === 'x' ? tick.value : verticalTick.value;\n            const y = dimType === 'x' ? verticalTick.value : tick.value;\n\n            if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {\n              const point = coord.convertPoint({\n                x,\n                y\n              });\n              subPoints.push(point);\n            }\n          });\n          gridPoints.push({\n            points: subPoints,\n            _id: 'axis-' + dimType + index + '-grid-' + tick.tickValue\n          });\n        });\n        axis.gridPoints = gridPoints;\n\n        if (coord.isPolar) {\n          axis.center = coord.center;\n          axis.startAngle = coord.startAngle;\n          axis.endAngle = coord.endAngle;\n        }\n      }\n\n      appendCfg._id = 'axis-' + dimType;\n\n      if (!Util.isNil(index)) {\n        appendCfg._id = 'axis-' + dimType + index;\n      }\n\n      new Axis[type](Util.mix(axis, appendCfg));\n    });\n  }\n\n  clear() {\n    this.axes = {};\n    this.frontPlot.clear();\n    this.backPlot.clear();\n  }\n\n}\n\nmodule.exports = AxisController;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/chart/controller/axis.js"],"names":["Util","require","Axis","Global","Shape","formatTicks","ticks","tmp","slice","length","first","last","value","unshift","push","AxisController","constructor","cfg","axisCfg","frontPlot","backPlot","axes","mix","_isHide","field","_getLinePosition","scale","dimType","index","transposed","position","_getLineCfg","coord","start","end","factor","x","y","offsetFactor","convertPoint","_getCircleCfg","startAngle","endAngle","center","radius","circleRadius","_getRadiusCfg","_getAxisCfg","verticalScale","defaultCfg","self","getTicks","deepMix","frontContainer","backContainer","labels","label","count","maxWidth","maxHeight","labelCfg","each","tick","isFunction","executedLabel","text","_defaultAxis","textStyle","textAlign","textBaseline","axisLabel","Text","className","attrs","fontFamily","chart","get","top","context","width","height","getBBox","Math","max","_createAxis","coordType","type","key","axis","circle","createAxis","xScale","yScales","yScale","_isAutoPadding","userPadding","parsePadding","appendPadding","legendRange","right","bottom","left","padding","isPolar","circleAxis","labelOffset","set","_updateLayout","grid","appendCfg","gridPoints","verticalTicks","subPoints","verticalTick","point","points","_id","tickValue","isNil","clear","module","exports"],"mappings":"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","sourcesContent":["const Util = require('../../util/common');\nconst Axis = require('../../component/axis/');\nconst Global = require('../../global');\nconst { Shape } = require('../../graphic/index');\n\nfunction formatTicks(ticks) {\n  const tmp = ticks.slice(0);\n  if (tmp.length > 0) {\n    const first = tmp[0];\n    const last = tmp[tmp.length - 1];\n    if (first.value !== 0) {\n      tmp.unshift({\n        value: 0\n      });\n    }\n    if (last.value !== 1) {\n      tmp.push({\n        value: 1\n      });\n    }\n  }\n\n  return tmp;\n}\n\nclass AxisController {\n  constructor(cfg) {\n    this.axisCfg = {};\n    this.frontPlot = null;\n    this.backPlot = null;\n    this.axes = {}; // store the axes's options\n    Util.mix(this, cfg);\n  }\n\n  _isHide(field) {\n    const axisCfg = this.axisCfg;\n    return !axisCfg || axisCfg[field] === false;\n  }\n\n  _getLinePosition(scale, dimType, index, transposed) {\n    let position = '';\n    const field = scale.field;\n    const axisCfg = this.axisCfg;\n    if (axisCfg[field] && axisCfg[field].position) {\n      position = axisCfg[field].position;\n    } else if (dimType === 'x') {\n      position = transposed ? 'left' : 'bottom';\n    } else if (dimType === 'y') {\n      position = index ? 'right' : 'left';\n      if (transposed) {\n        position = 'bottom';\n      }\n    }\n\n    return position;\n  }\n\n  _getLineCfg(coord, dimType, position) {\n    let start;\n    let end;\n    let factor = 1; // Mark clockwise or counterclockwise\n    if (dimType === 'x') {\n      start = {\n        x: 0,\n        y: 0\n      };\n      end = {\n        x: 1,\n        y: 0\n      };\n    } else {\n      if (position === 'right') { // there will be several y axes\n        start = {\n          x: 1,\n          y: 0\n        };\n        end = {\n          x: 1,\n          y: 1\n        };\n      } else {\n        start = {\n          x: 0,\n          y: 0\n        };\n        end = {\n          x: 0,\n          y: 1\n        };\n        factor = -1;\n      }\n    }\n    if (coord.transposed) {\n      factor *= -1;\n    }\n\n    return {\n      offsetFactor: factor,\n      start: coord.convertPoint(start),\n      end: coord.convertPoint(end)\n    };\n  }\n\n  _getCircleCfg(coord) {\n    return {\n      startAngle: coord.startAngle,\n      endAngle: coord.endAngle,\n      center: coord.center,\n      radius: coord.circleRadius\n    };\n  }\n\n  _getRadiusCfg(coord) {\n    const transposed = coord.transposed;\n    let start;\n    let end;\n    if (transposed) {\n      start = { x: 0, y: 0 };\n      end = { x: 1, y: 0 };\n    } else {\n      start = { x: 0, y: 0 };\n      end = { x: 0, y: 1 };\n    }\n    return {\n      offsetFactor: -1,\n      start: coord.convertPoint(start),\n      end: coord.convertPoint(end)\n    };\n  }\n\n  _getAxisCfg(coord, scale, verticalScale, dimType, defaultCfg) {\n    const self = this;\n    const axisCfg = this.axisCfg;\n    const ticks = scale.getTicks();\n\n    const cfg = Util.deepMix({\n      ticks,\n      frontContainer: this.frontPlot,\n      backContainer: this.backPlot\n    }, defaultCfg, axisCfg[scale.field]);\n\n    const labels = [];\n    const label = cfg.label;\n    const count = ticks.length;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let labelCfg = label;\n\n    Util.each(ticks, (tick, index) => {\n      if (Util.isFunction(label)) {\n        const executedLabel = label(tick.text, index, count);\n        labelCfg = executedLabel ? Util.mix({}, Global._defaultAxis.label, executedLabel) : null;\n      }\n      if (labelCfg) {\n        const textStyle = {};\n        if (labelCfg.textAlign) {\n          textStyle.textAlign = labelCfg.textAlign;\n        }\n        if (labelCfg.textBaseline) {\n          textStyle.textBaseline = labelCfg.textBaseline;\n        }\n        const axisLabel = new Shape.Text({\n          className: 'axis-label',\n          attrs: Util.mix({\n            x: 0,\n            y: 0,\n            text: tick.text,\n            fontFamily: self.chart.get('canvas').get('fontFamily')\n          }, labelCfg),\n          value: tick.value,\n          textStyle,\n          top: labelCfg.top,\n          context: self.chart.get('canvas').get('context')\n        });\n        labels.push(axisLabel);\n        const { width, height } = axisLabel.getBBox();\n        maxWidth = Math.max(maxWidth, width);\n        maxHeight = Math.max(maxHeight, height);\n      }\n    });\n\n    cfg.labels = labels;\n    cfg.maxWidth = maxWidth;\n    cfg.maxHeight = maxHeight;\n    return cfg;\n  }\n\n  _createAxis(coord, scale, verticalScale, dimType, index = '') {\n    const self = this;\n    const coordType = coord.type;\n    const transposed = coord.transposed;\n    let type;\n    let key;\n    let defaultCfg;\n    if (coordType === 'cartesian' || coordType === 'rect') {\n      const position = self._getLinePosition(scale, dimType, index, transposed);\n      defaultCfg = Global.axis[position];\n      defaultCfg.position = position;\n      type = 'Line';\n      key = position;\n    } else {\n      if ((dimType === 'x' && !transposed) || (dimType === 'y' && transposed)) {\n        defaultCfg = Global.axis.circle;\n        type = 'Circle';\n        key = 'circle';\n      } else {\n        defaultCfg = Global.axis.radius;\n        type = 'Line';\n        key = 'radius';\n      }\n    }\n    const cfg = self._getAxisCfg(coord, scale, verticalScale, dimType, defaultCfg);\n    cfg.type = type;\n    cfg.dimType = dimType;\n    cfg.verticalScale = verticalScale;\n    cfg.index = index;\n    this.axes[key] = cfg;\n  }\n\n  createAxis(coord, xScale, yScales) {\n    const self = this;\n    if (xScale && !self._isHide(xScale.field)) {\n      self._createAxis(coord, xScale, yScales[0], 'x');\n    }\n    Util.each(yScales, function(yScale, index) {\n      if (!self._isHide(yScale.field)) {\n        self._createAxis(coord, yScale, xScale, 'y', index);\n      }\n    });\n\n    const axes = this.axes;\n    const chart = self.chart;\n    if (chart._isAutoPadding()) {\n      const userPadding = Util.parsePadding(chart.get('padding'));\n      const appendPadding = Util.parsePadding(chart.get('appendPadding'));\n      const legendRange = chart.get('legendRange') || {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n\n      const padding = [\n        userPadding[0] === 'auto' ? legendRange.top + appendPadding[0] * 2 : userPadding[0],\n        userPadding[1] === 'auto' ? legendRange.right + appendPadding[1] : userPadding[1],\n        userPadding[2] === 'auto' ? legendRange.bottom + appendPadding[2] : userPadding[2],\n        userPadding[3] === 'auto' ? legendRange.left + appendPadding[3] : userPadding[3]\n      ];\n\n      if (coord.isPolar) {\n        const circleAxis = axes.circle;\n        if (circleAxis) {\n          const { maxHeight, maxWidth, labelOffset } = circleAxis;\n          padding[0] += maxHeight + labelOffset;\n          padding[1] += maxWidth + labelOffset;\n          padding[2] += maxHeight + labelOffset;\n          padding[3] += maxWidth + labelOffset;\n        }\n      } else {\n        if (axes.right && userPadding[1] === 'auto') {\n          const { maxWidth, labelOffset } = axes.right;\n          padding[1] += maxWidth + labelOffset;\n        }\n\n        if (axes.left && userPadding[3] === 'auto') {\n          const { maxWidth, labelOffset } = axes.left;\n          padding[3] += maxWidth + labelOffset;\n        }\n\n        if (axes.bottom && userPadding[2] === 'auto') {\n          const { maxHeight, labelOffset } = axes.bottom;\n          padding[2] += maxHeight + labelOffset;\n        }\n      }\n      chart.set('_padding', padding);\n      chart._updateLayout(padding);\n    }\n\n    Util.each(axes, axis => {\n      const { type, grid, verticalScale, ticks, dimType, position, index } = axis;\n      let appendCfg;\n      if (coord.isPolar) {\n        if (type === 'Line') {\n          appendCfg = self._getRadiusCfg(coord);\n        } else if (type === 'Circle') {\n          appendCfg = self._getCircleCfg(coord);\n        }\n      } else {\n        appendCfg = self._getLineCfg(coord, dimType, position);\n      }\n\n      if (grid && verticalScale) {\n        const gridPoints = [];\n        const verticalTicks = formatTicks(verticalScale.getTicks());\n\n        Util.each(ticks, tick => {\n          const subPoints = [];\n          Util.each(verticalTicks, verticalTick => {\n            const x = dimType === 'x' ? tick.value : verticalTick.value;\n            const y = dimType === 'x' ? verticalTick.value : tick.value;\n\n            if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {\n              const point = coord.convertPoint({\n                x,\n                y\n              });\n              subPoints.push(point);\n            }\n          });\n\n          gridPoints.push({\n            points: subPoints,\n            _id: 'axis-' + dimType + index + '-grid-' + tick.tickValue\n          });\n        });\n        axis.gridPoints = gridPoints;\n\n        if (coord.isPolar) {\n          axis.center = coord.center;\n          axis.startAngle = coord.startAngle;\n          axis.endAngle = coord.endAngle;\n        }\n      }\n      appendCfg._id = 'axis-' + dimType;\n      if (!Util.isNil(index)) {\n        appendCfg._id = 'axis-' + dimType + index;\n      }\n\n      new Axis[type](Util.mix(axis, appendCfg));\n    });\n  }\n\n  clear() {\n    this.axes = {};\n    this.frontPlot.clear();\n    this.backPlot.clear();\n  }\n}\n\nmodule.exports = AxisController;\n"]},"metadata":{},"sourceType":"script"}