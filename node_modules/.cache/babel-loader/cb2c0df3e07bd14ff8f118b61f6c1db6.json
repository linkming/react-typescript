{"ast":null,"code":"/**\n * Handle the detail animations\n * @author sima.zhang1990@gmail.com\n */\nconst Util = require('../util/common');\n\nconst Element = require('../graphic/element');\n\nconst Timeline = require('../graphic/animate/timeline');\n\nconst Animator = require('../graphic/animate/animator');\n\nconst Animate = require('./animate');\n\nconst ShapeAction = require('./shape-action');\n\nconst GroupAction = require('./group-action');\n\nconst Chart = require('../chart/chart');\n\nlet timeline;\n\nElement.prototype.animate = function () {\n  const attrs = Util.mix({}, this.get('attrs'));\n  return new Animator(this, attrs, timeline);\n};\n\nChart.prototype.animate = function (cfg) {\n  this.set('animate', cfg);\n  return this;\n};\n\nAnimate.Action = ShapeAction;\nAnimate.defaultCfg = {\n  interval: {\n    enter(coord) {\n      if (coord.isPolar && coord.transposed) {\n        // for pie chart\n        return function (shape) {\n          shape.set('zIndex', -1);\n          const container = shape.get('parent');\n          container.sort();\n        };\n      }\n\n      return ShapeAction.fadeIn;\n    }\n\n  },\n  area: {\n    enter(coord) {\n      if (coord.isPolar) return null;\n      return ShapeAction.fadeIn;\n    }\n\n  },\n  line: {\n    enter(coord) {\n      if (coord.isPolar) return null;\n      return ShapeAction.fadeIn;\n    }\n\n  },\n  path: {\n    enter(coord) {\n      if (coord.isPolar) return null;\n      return ShapeAction.fadeIn;\n    }\n\n  }\n};\nconst GROUP_ANIMATION = {\n  line(coord) {\n    if (coord.isPolar) {\n      return GroupAction.groupScaleInXY;\n    }\n\n    return GroupAction.groupWaveIn;\n  },\n\n  area(coord) {\n    if (coord.isPolar) {\n      return GroupAction.groupScaleInXY;\n    }\n\n    return GroupAction.groupWaveIn;\n  },\n\n  path(coord) {\n    if (coord.isPolar) {\n      return GroupAction.groupScaleInXY;\n    }\n\n    return GroupAction.groupWaveIn;\n  },\n\n  point() {\n    return GroupAction.shapesScaleInXY;\n  },\n\n  interval(coord) {\n    let result;\n\n    if (coord.isPolar) {\n      // polar coodinate\n      result = GroupAction.groupScaleInXY;\n\n      if (coord.transposed) {\n        // pie chart\n        result = GroupAction.groupWaveIn;\n      }\n    } else {\n      result = coord.transposed ? GroupAction.groupScaleInX : GroupAction.groupScaleInY;\n    }\n\n    return result;\n  },\n\n  schema() {\n    return GroupAction.groupWaveIn;\n  }\n\n};\n\nfunction diff(fromAttrs, toAttrs) {\n  const endState = {};\n\n  for (const k in toAttrs) {\n    if (Util.isNumber(fromAttrs[k]) && fromAttrs[k] !== toAttrs[k]) {\n      endState[k] = toAttrs[k];\n    } else if (Util.isArray(fromAttrs[k]) && JSON.stringify(fromAttrs[k]) !== JSON.stringify(toAttrs[k])) {\n      endState[k] = toAttrs[k];\n    }\n  }\n\n  return endState;\n} // Add a unique id identifier to each shape\n\n\nfunction _getShapeId(geom, dataObj, geomIdx) {\n  const type = geom.get('type');\n  let id = 'geom' + geomIdx + '-' + type;\n  const xScale = geom.getXScale();\n  const yScale = geom.getYScale();\n  const xField = xScale.field || 'x';\n  const yField = yScale.field || 'y';\n  const yVal = dataObj[yField];\n  let xVal;\n\n  if (xScale.isIdentity) {\n    xVal = xScale.value;\n  } else {\n    xVal = dataObj[xField];\n  }\n\n  if (type === 'interval' || type === 'schema') {\n    id += '-' + xVal;\n  } else if (type === 'line' || type === 'area' || type === 'path') {\n    id += '-' + type;\n  } else {\n    id += xScale.isCategory ? '-' + xVal : '-' + xVal + '-' + yVal;\n  }\n\n  const groupScales = geom._getGroupScales();\n\n  Util.each(groupScales, groupScale => {\n    const field = groupScale.field;\n\n    if (groupScale.type !== 'identity') {\n      id += '-' + dataObj[field];\n    }\n  });\n  return id;\n} // get geometry's shapes\n\n\nfunction getShapes(geoms, chart, coord) {\n  const shapes = [];\n  Util.each(geoms, (geom, geomIdx) => {\n    const geomContainer = geom.get('container');\n    const geomShapes = geomContainer.get('children');\n    const type = geom.get('type');\n    const animateCfg = Util.isNil(geom.get('animateCfg')) ? _getAnimateCfgByShapeType(type, chart) : geom.get('animateCfg');\n\n    if (animateCfg !== false) {\n      Util.each(geomShapes, (shape, index) => {\n        if (shape.get('className') === type) {\n          shape._id = _getShapeId(geom, shape.get('origin')._origin, geomIdx);\n          shape.set('coord', coord);\n          shape.set('animateCfg', animateCfg);\n          shape.set('index', index);\n          shapes.push(shape);\n        }\n      });\n    }\n\n    geom.set('shapes', geomShapes);\n  });\n  return shapes;\n}\n\nfunction cache(shapes) {\n  const rst = {};\n\n  for (let i = 0, len = shapes.length; i < len; i++) {\n    const shape = shapes[i];\n    if (!shape._id || shape.isClip) continue;\n    const id = shape._id;\n    rst[id] = {\n      _id: id,\n      type: shape.get('type'),\n      // the type of shape\n      attrs: Util.mix({}, shape._attrs.attrs),\n      // the graphics attributes of shape\n      className: shape.get('className'),\n      geomType: shape.get('className'),\n      index: shape.get('index'),\n      coord: shape.get('coord'),\n      animateCfg: shape.get('animateCfg')\n    };\n  }\n\n  return rst;\n}\n\nfunction getAnimate(geomType, coord, animationType, animationName) {\n  let result;\n\n  if (Util.isFunction(animationName)) {\n    result = animationName;\n  } else if (Util.isString(animationName)) {\n    result = Animate.Action[animationName];\n  } else {\n    result = Animate.getAnimation(geomType, coord, animationType);\n  }\n\n  return result;\n}\n\nfunction getAnimateCfg(geomType, animationType, animateCfg) {\n  if (animateCfg === false || Util.isObject(animateCfg) && animateCfg[animationType] === false) {\n    return false;\n  }\n\n  const defaultCfg = Animate.getAnimateCfg(geomType, animationType);\n\n  if (animateCfg && animateCfg[animationType]) {\n    return Util.deepMix({}, defaultCfg, animateCfg[animationType]);\n  }\n\n  return defaultCfg;\n}\n\nfunction addAnimate(cache, shapes, canvas) {\n  let animate;\n  let animateCfg; // the order of animation: leave -> update -> enter\n\n  const updateShapes = [];\n  const newShapes = [];\n  Util.each(shapes, shape => {\n    const result = cache[shape._id];\n\n    if (!result) {\n      newShapes.push(shape);\n    } else {\n      shape.set('cacheShape', result);\n      updateShapes.push(shape);\n      delete cache[shape._id];\n    }\n  }); // first do the leave animation\n\n  Util.each(cache, deletedShape => {\n    const {\n      className,\n      coord,\n      _id,\n      attrs,\n      index,\n      type\n    } = deletedShape;\n    animateCfg = getAnimateCfg(className, 'leave', deletedShape.animateCfg);\n    if (animateCfg === false) return true;\n    animate = getAnimate(className, coord, 'leave', animateCfg.animation);\n\n    if (Util.isFunction(animate)) {\n      const tempShape = canvas.addShape(type, {\n        attrs,\n        index,\n        canvas,\n        className\n      });\n      tempShape._id = _id;\n      animate(tempShape, animateCfg, coord);\n    }\n  }); // then do the update animation\n\n  Util.each(updateShapes, updateShape => {\n    const className = updateShape.get('className');\n    animateCfg = getAnimateCfg(className, 'update', updateShape.get('animateCfg'));\n    if (animateCfg === false) return true;\n    const coord = updateShape.get('coord');\n    const cacheAttrs = updateShape.get('cacheShape').attrs;\n    const endState = diff(cacheAttrs, updateShape._attrs.attrs); // 判断如果属性相同的话就不进行变换\n\n    if (Object.keys(endState).length) {\n      animate = getAnimate(className, coord, 'update', animateCfg.animation);\n\n      if (Util.isFunction(animate)) {\n        animate(updateShape, animateCfg, coord);\n      } else {\n        updateShape.attr(cacheAttrs);\n        updateShape.animate().to({\n          attrs: endState,\n          duration: animateCfg.duration,\n          easing: animateCfg.easing,\n          delay: animateCfg.delay\n        }).onEnd(function () {\n          updateShape.set('cacheShape', null);\n        });\n      }\n    }\n  }); // last, enter animation\n\n  Util.each(newShapes, newShape => {\n    // 新图形元素的进场元素\n    const className = newShape.get('className');\n    const coord = newShape.get('coord');\n    animateCfg = getAnimateCfg(className, 'enter', newShape.get('animateCfg'));\n    if (animateCfg === false) return true;\n    animate = getAnimate(className, coord, 'enter', animateCfg.animation);\n\n    if (Util.isFunction(animate)) {\n      if (className === 'interval' && coord.isPolar && coord.transposed) {\n        const index = newShape.get('index');\n        const lastShape = updateShapes[index - 1];\n        animate(newShape, animateCfg, lastShape);\n      } else {\n        animate(newShape, animateCfg, coord);\n      }\n    }\n  });\n}\n\nfunction _getAnimateCfgByShapeType(type, chart) {\n  if (!type) {\n    return null;\n  }\n\n  const animateCfg = chart.get('animate');\n\n  if (type.indexOf('guide-tag') > -1) {\n    type = 'guide-tag';\n  }\n\n  if (Util.isObject(animateCfg)) {\n    return animateCfg[type];\n  }\n\n  if (animateCfg === false) {\n    return false;\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  afterCanvasInit()\n  /* chart */\n  {\n    timeline = new Timeline();\n    timeline.play();\n  },\n\n  beforeCanvasDraw(chart) {\n    if (chart.get('animate') === false) {\n      return;\n    }\n\n    let isUpdate = chart.get('isUpdate');\n    const canvas = chart.get('canvas');\n    const coord = chart.get('coord');\n    const geoms = chart.get('geoms');\n    const caches = canvas.get('caches') || [];\n\n    if (caches.length === 0) {\n      isUpdate = false;\n    }\n\n    const cacheShapes = getShapes(geoms, chart, coord);\n    const {\n      frontPlot,\n      backPlot\n    } = chart.get('axisController');\n    const axisShapes = frontPlot.get('children').concat(backPlot.get('children'));\n    let guideShapes = [];\n\n    if (chart.get('guideController')) {\n      guideShapes = chart.get('guideController').guideShapes;\n    }\n\n    const componentShapes = [];\n    axisShapes.concat(guideShapes).forEach(s => {\n      const className = s.get('className');\n\n      const animateCfg = _getAnimateCfgByShapeType(className, chart);\n\n      s.set('coord', coord);\n      s.set('animateCfg', animateCfg);\n      componentShapes.push(s);\n      cacheShapes.push(s);\n    });\n    canvas.set('caches', cache(cacheShapes));\n\n    if (isUpdate) {\n      addAnimate(caches, cacheShapes, canvas);\n    } else {\n      // do the appear animation\n      let animateCfg;\n      let animate;\n      Util.each(geoms, geom => {\n        const type = geom.get('type');\n        const geomCfg = Util.isNil(geom.get('animateCfg')) ? _getAnimateCfgByShapeType(type, chart) : geom.get('animateCfg');\n\n        if (geomCfg !== false) {\n          animateCfg = getAnimateCfg(type, 'appear', geomCfg);\n          animate = getAnimate(type, coord, 'appear', animateCfg.animation);\n\n          if (Util.isFunction(animate)) {\n            const shapes = geom.get('shapes');\n            Util.each(shapes, shape => {\n              animate(shape, animateCfg, coord);\n            });\n          } else if (GROUP_ANIMATION[type]) {\n            // do the default animation\n            animate = GroupAction[animateCfg.animation] || GROUP_ANIMATION[type](coord);\n            const yScale = geom.getYScale();\n            const zeroY = coord.convertPoint({\n              x: 0,\n              y: yScale.scale(geom.getYMinValue())\n            });\n            const container = geom.get('container');\n            animate && animate(container, animateCfg, coord, zeroY);\n          }\n        }\n      }); // do the animation of components\n\n      Util.each(componentShapes, shape => {\n        const animateCfg = shape.get('animateCfg');\n        const className = shape.get('className');\n\n        if (animateCfg && animateCfg.appear) {\n          // if user configure\n          const defaultCfg = Animate.getAnimateCfg(className, 'appear');\n          const appearCfg = Util.deepMix({}, defaultCfg, animateCfg.appear);\n          const animate = getAnimate(className, coord, 'appear', appearCfg.animation);\n\n          if (Util.isFunction(animate)) {\n            animate(shape, appearCfg, coord);\n          }\n        }\n      });\n    }\n  },\n\n  afterCanvasDestroyed()\n  /* chart */\n  {\n    timeline.stop();\n  }\n\n};","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/animation/detail.js"],"names":["Util","require","Element","Timeline","Animator","Animate","ShapeAction","GroupAction","Chart","timeline","prototype","animate","attrs","mix","get","cfg","set","Action","defaultCfg","interval","enter","coord","isPolar","transposed","shape","container","sort","fadeIn","area","line","path","GROUP_ANIMATION","groupScaleInXY","groupWaveIn","point","shapesScaleInXY","result","groupScaleInX","groupScaleInY","schema","diff","fromAttrs","toAttrs","endState","k","isNumber","isArray","JSON","stringify","_getShapeId","geom","dataObj","geomIdx","type","id","xScale","getXScale","yScale","getYScale","xField","field","yField","yVal","xVal","isIdentity","value","isCategory","groupScales","_getGroupScales","each","groupScale","getShapes","geoms","chart","shapes","geomContainer","geomShapes","animateCfg","isNil","_getAnimateCfgByShapeType","index","_id","_origin","push","cache","rst","i","len","length","isClip","_attrs","className","geomType","getAnimate","animationType","animationName","isFunction","isString","getAnimation","getAnimateCfg","isObject","deepMix","addAnimate","canvas","updateShapes","newShapes","deletedShape","animation","tempShape","addShape","updateShape","cacheAttrs","Object","keys","attr","to","duration","easing","delay","onEnd","newShape","lastShape","indexOf","module","exports","afterCanvasInit","play","beforeCanvasDraw","isUpdate","caches","cacheShapes","frontPlot","backPlot","axisShapes","concat","guideShapes","componentShapes","forEach","s","geomCfg","zeroY","convertPoint","x","y","scale","getYMinValue","appear","appearCfg","afterCanvasDestroyed","stop"],"mappings":"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","sourcesContent":["/**\n * Handle the detail animations\n * @author sima.zhang1990@gmail.com\n */\nconst Util = require('../util/common');\nconst Element = require('../graphic/element');\nconst Timeline = require('../graphic/animate/timeline');\nconst Animator = require('../graphic/animate/animator');\nconst Animate = require('./animate');\nconst ShapeAction = require('./shape-action');\nconst GroupAction = require('./group-action');\nconst Chart = require('../chart/chart');\n\nlet timeline;\nElement.prototype.animate = function() {\n  const attrs = Util.mix({}, this.get('attrs'));\n  return new Animator(this, attrs, timeline);\n};\n\nChart.prototype.animate = function(cfg) {\n  this.set('animate', cfg);\n  return this;\n};\n\nAnimate.Action = ShapeAction;\nAnimate.defaultCfg = {\n  interval: {\n    enter(coord) {\n      if (coord.isPolar && coord.transposed) { // for pie chart\n        return function(shape) {\n          shape.set('zIndex', -1);\n          const container = shape.get('parent');\n          container.sort();\n        };\n      }\n      return ShapeAction.fadeIn;\n    }\n  },\n  area: {\n    enter(coord) {\n      if (coord.isPolar) return null;\n      return ShapeAction.fadeIn;\n    }\n  },\n  line: {\n    enter(coord) {\n      if (coord.isPolar) return null;\n\n      return ShapeAction.fadeIn;\n    }\n  },\n  path: {\n    enter(coord) {\n      if (coord.isPolar) return null;\n\n      return ShapeAction.fadeIn;\n    }\n  }\n};\n\nconst GROUP_ANIMATION = {\n  line(coord) {\n    if (coord.isPolar) {\n      return GroupAction.groupScaleInXY;\n    }\n    return GroupAction.groupWaveIn;\n  },\n  area(coord) {\n    if (coord.isPolar) {\n      return GroupAction.groupScaleInXY;\n    }\n    return GroupAction.groupWaveIn;\n  },\n  path(coord) {\n    if (coord.isPolar) {\n      return GroupAction.groupScaleInXY;\n    }\n    return GroupAction.groupWaveIn;\n  },\n  point() {\n    return GroupAction.shapesScaleInXY;\n  },\n  interval(coord) {\n    let result;\n    if (coord.isPolar) { // polar coodinate\n      result = GroupAction.groupScaleInXY;\n      if (coord.transposed) { // pie chart\n        result = GroupAction.groupWaveIn;\n      }\n    } else {\n      result = coord.transposed ? GroupAction.groupScaleInX : GroupAction.groupScaleInY;\n    }\n    return result;\n  },\n  schema() {\n    return GroupAction.groupWaveIn;\n  }\n};\n\nfunction diff(fromAttrs, toAttrs) {\n  const endState = {};\n  for (const k in toAttrs) {\n    if (Util.isNumber(fromAttrs[k]) && fromAttrs[k] !== toAttrs[k]) {\n      endState[k] = toAttrs[k];\n    } else if (Util.isArray(fromAttrs[k]) && JSON.stringify(fromAttrs[k]) !== JSON.stringify(toAttrs[k])) {\n      endState[k] = toAttrs[k];\n    }\n  }\n  return endState;\n}\n\n// Add a unique id identifier to each shape\nfunction _getShapeId(geom, dataObj, geomIdx) {\n  const type = geom.get('type');\n  let id = 'geom' + geomIdx + '-' + type;\n  const xScale = geom.getXScale();\n  const yScale = geom.getYScale();\n  const xField = xScale.field || 'x';\n  const yField = yScale.field || 'y';\n  const yVal = dataObj[yField];\n  let xVal;\n  if (xScale.isIdentity) {\n    xVal = xScale.value;\n  } else {\n    xVal = dataObj[xField];\n  }\n\n  if (type === 'interval' || type === 'schema') {\n    id += '-' + xVal;\n  } else if (type === 'line' || type === 'area' || type === 'path') {\n    id += '-' + type;\n  } else {\n    id += xScale.isCategory ? '-' + xVal : '-' + xVal + '-' + yVal;\n  }\n\n  const groupScales = geom._getGroupScales();\n  Util.each(groupScales, groupScale => {\n    const field = groupScale.field;\n    if (groupScale.type !== 'identity') {\n      id += '-' + dataObj[field];\n    }\n  });\n\n  return id;\n}\n\n// get geometry's shapes\nfunction getShapes(geoms, chart, coord) {\n  const shapes = [];\n\n  Util.each(geoms, (geom, geomIdx) => {\n    const geomContainer = geom.get('container');\n    const geomShapes = geomContainer.get('children');\n    const type = geom.get('type');\n    const animateCfg = Util.isNil(geom.get('animateCfg')) ? _getAnimateCfgByShapeType(type, chart) : geom.get('animateCfg');\n    if (animateCfg !== false) {\n      Util.each(geomShapes, (shape, index) => {\n        if (shape.get('className') === type) {\n          shape._id = _getShapeId(geom, shape.get('origin')._origin, geomIdx);\n          shape.set('coord', coord);\n          shape.set('animateCfg', animateCfg);\n          shape.set('index', index);\n          shapes.push(shape);\n        }\n      });\n    }\n    geom.set('shapes', geomShapes);\n  });\n  return shapes;\n}\n\nfunction cache(shapes) {\n  const rst = {};\n  for (let i = 0, len = shapes.length; i < len; i++) {\n    const shape = shapes[i];\n    if (!shape._id || shape.isClip) continue;\n    const id = shape._id;\n    rst[id] = {\n      _id: id,\n      type: shape.get('type'), // the type of shape\n      attrs: Util.mix({}, shape._attrs.attrs), // the graphics attributes of shape\n      className: shape.get('className'),\n      geomType: shape.get('className'),\n      index: shape.get('index'),\n      coord: shape.get('coord'),\n      animateCfg: shape.get('animateCfg')\n    };\n  }\n  return rst;\n}\n\nfunction getAnimate(geomType, coord, animationType, animationName) {\n  let result;\n\n  if (Util.isFunction(animationName)) {\n    result = animationName;\n  } else if (Util.isString(animationName)) {\n    result = Animate.Action[animationName];\n  } else {\n    result = Animate.getAnimation(geomType, coord, animationType);\n  }\n  return result;\n}\n\nfunction getAnimateCfg(geomType, animationType, animateCfg) {\n  if (animateCfg === false || (Util.isObject(animateCfg) && (animateCfg[animationType] === false))) {\n    return false;\n  }\n\n  const defaultCfg = Animate.getAnimateCfg(geomType, animationType);\n  if (animateCfg && animateCfg[animationType]) {\n    return Util.deepMix({}, defaultCfg, animateCfg[animationType]);\n  }\n  return defaultCfg;\n}\n\nfunction addAnimate(cache, shapes, canvas) {\n  let animate;\n  let animateCfg;\n\n  // the order of animation: leave -> update -> enter\n  const updateShapes = [];\n  const newShapes = [];\n  Util.each(shapes, shape => {\n    const result = cache[shape._id];\n    if (!result) {\n      newShapes.push(shape);\n    } else {\n      shape.set('cacheShape', result);\n      updateShapes.push(shape);\n      delete cache[shape._id];\n    }\n  });\n\n  // first do the leave animation\n  Util.each(cache, deletedShape => {\n    const { className, coord, _id, attrs, index, type } = deletedShape;\n\n    animateCfg = getAnimateCfg(className, 'leave', deletedShape.animateCfg);\n    if (animateCfg === false) return true;\n\n    animate = getAnimate(className, coord, 'leave', animateCfg.animation);\n    if (Util.isFunction(animate)) {\n      const tempShape = canvas.addShape(type, {\n        attrs,\n        index,\n        canvas,\n        className\n      });\n      tempShape._id = _id;\n      animate(tempShape, animateCfg, coord);\n    }\n  });\n\n  // then do the update animation\n  Util.each(updateShapes, updateShape => {\n    const className = updateShape.get('className');\n\n    animateCfg = getAnimateCfg(className, 'update', updateShape.get('animateCfg'));\n    if (animateCfg === false) return true;\n    const coord = updateShape.get('coord');\n    const cacheAttrs = updateShape.get('cacheShape').attrs;\n    const endState = diff(cacheAttrs, updateShape._attrs.attrs); // 判断如果属性相同的话就不进行变换\n    if (Object.keys(endState).length) {\n      animate = getAnimate(className, coord, 'update', animateCfg.animation);\n      if (Util.isFunction(animate)) {\n        animate(updateShape, animateCfg, coord);\n      } else {\n        updateShape.attr(cacheAttrs);\n        updateShape.animate().to({\n          attrs: endState,\n          duration: animateCfg.duration,\n          easing: animateCfg.easing,\n          delay: animateCfg.delay\n        }).onEnd(function() {\n          updateShape.set('cacheShape', null);\n        });\n      }\n    }\n  });\n\n  // last, enter animation\n  Util.each(newShapes, newShape => {\n    // 新图形元素的进场元素\n    const className = newShape.get('className');\n    const coord = newShape.get('coord');\n\n    animateCfg = getAnimateCfg(className, 'enter', newShape.get('animateCfg'));\n    if (animateCfg === false) return true;\n\n    animate = getAnimate(className, coord, 'enter', animateCfg.animation);\n    if (Util.isFunction(animate)) {\n      if (className === 'interval' && coord.isPolar && coord.transposed) {\n        const index = (newShape.get('index'));\n        const lastShape = updateShapes[index - 1];\n        animate(newShape, animateCfg, lastShape);\n      } else {\n        animate(newShape, animateCfg, coord);\n      }\n    }\n  });\n}\n\nfunction _getAnimateCfgByShapeType(type, chart) {\n  if (!type) {\n    return null;\n  }\n  const animateCfg = chart.get('animate');\n\n  if (type.indexOf('guide-tag') > -1) {\n    type = 'guide-tag';\n  }\n\n  if (Util.isObject(animateCfg)) {\n    return animateCfg[type];\n  }\n\n  if (animateCfg === false) {\n    return false;\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  afterCanvasInit(/* chart */) {\n    timeline = new Timeline();\n    timeline.play();\n  },\n  beforeCanvasDraw(chart) {\n    if (chart.get('animate') === false) {\n      return;\n    }\n\n    let isUpdate = chart.get('isUpdate');\n    const canvas = chart.get('canvas');\n    const coord = chart.get('coord');\n    const geoms = chart.get('geoms');\n\n    const caches = canvas.get('caches') || [];\n    if (caches.length === 0) {\n      isUpdate = false;\n    }\n\n    const cacheShapes = getShapes(geoms, chart, coord);\n    const { frontPlot, backPlot } = chart.get('axisController');\n    const axisShapes = frontPlot.get('children').concat(backPlot.get('children'));\n    let guideShapes = [];\n    if (chart.get('guideController')) {\n      guideShapes = chart.get('guideController').guideShapes;\n    }\n    const componentShapes = [];\n    axisShapes.concat(guideShapes).forEach(s => {\n      const className = s.get('className');\n      const animateCfg = _getAnimateCfgByShapeType(className, chart);\n      s.set('coord', coord);\n      s.set('animateCfg', animateCfg);\n      componentShapes.push(s);\n      cacheShapes.push(s);\n    });\n    canvas.set('caches', cache(cacheShapes));\n\n    if (isUpdate) {\n      addAnimate(caches, cacheShapes, canvas);\n    } else { // do the appear animation\n      let animateCfg;\n      let animate;\n      Util.each(geoms, geom => {\n        const type = geom.get('type');\n        const geomCfg = Util.isNil(geom.get('animateCfg')) ? _getAnimateCfgByShapeType(type, chart) : geom.get('animateCfg');\n        if (geomCfg !== false) {\n          animateCfg = getAnimateCfg(type, 'appear', geomCfg);\n          animate = getAnimate(type, coord, 'appear', animateCfg.animation);\n          if (Util.isFunction(animate)) {\n            const shapes = geom.get('shapes');\n            Util.each(shapes, shape => {\n              animate(shape, animateCfg, coord);\n            });\n          } else if (GROUP_ANIMATION[type]) { // do the default animation\n            animate = GroupAction[animateCfg.animation] || GROUP_ANIMATION[type](coord);\n\n            const yScale = geom.getYScale();\n            const zeroY = coord.convertPoint({\n              x: 0,\n              y: yScale.scale(geom.getYMinValue())\n            });\n\n            const container = geom.get('container');\n            animate && animate(container, animateCfg, coord, zeroY);\n          }\n        }\n      });\n\n      // do the animation of components\n      Util.each(componentShapes, shape => {\n        const animateCfg = shape.get('animateCfg');\n        const className = shape.get('className');\n        if (animateCfg && animateCfg.appear) { // if user configure\n          const defaultCfg = Animate.getAnimateCfg(className, 'appear');\n          const appearCfg = Util.deepMix({}, defaultCfg, animateCfg.appear);\n          const animate = getAnimate(className, coord, 'appear', appearCfg.animation);\n          if (Util.isFunction(animate)) {\n            animate(shape, appearCfg, coord);\n          }\n        }\n      });\n    }\n  },\n  afterCanvasDestroyed(/* chart */) {\n    timeline.stop();\n  }\n};\n"]},"metadata":{},"sourceType":"script"}