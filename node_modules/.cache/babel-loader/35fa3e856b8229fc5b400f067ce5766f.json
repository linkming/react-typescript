{"ast":null,"code":"const Util = require('../../util/common');\n\nconst Abstract = require('./abstract');\n\nclass Circle extends Abstract {\n  _initDefaultCfg() {\n    super._initDefaultCfg();\n\n    this.startAngle = -Math.PI / 2; // start angle，in radian\n\n    this.endAngle = Math.PI * 3 / 2; // end angle, in radian\n\n    this.radius = null; // radius\n\n    this.center = null; // center\n  }\n\n  getOffsetPoint(value) {\n    const {\n      startAngle,\n      endAngle\n    } = this;\n    const angle = startAngle + (endAngle - startAngle) * value;\n    return this._getCirclePoint(angle);\n  }\n\n  _getCirclePoint(angle, radius) {\n    const self = this;\n    const center = self.center;\n    radius = radius || self.radius;\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  }\n\n  getTextAlignInfo(point, offset) {\n    const self = this;\n    const offsetVector = self.getOffsetVector(point, offset);\n    let align;\n    let baseLine = 'middle';\n\n    if (offsetVector[0] > 0) {\n      align = 'left';\n    } else if (offsetVector[0] < 0) {\n      align = 'right';\n    } else {\n      align = 'center';\n\n      if (offsetVector[1] > 0) {\n        baseLine = 'top';\n      } else if (offsetVector[1] < 0) {\n        baseLine = 'bottom';\n      }\n    }\n\n    return {\n      textAlign: align,\n      textBaseline: baseLine\n    };\n  }\n\n  getAxisVector(point) {\n    const center = this.center;\n    const factor = this.offsetFactor;\n    return [(point.y - center.y) * factor, (point.x - center.x) * -1 * factor];\n  }\n\n  drawLine(lineCfg) {\n    const {\n      center,\n      radius,\n      startAngle,\n      endAngle\n    } = this;\n    const container = this.getContainer(lineCfg.top);\n    container.addShape('arc', {\n      className: 'axis-line',\n      attrs: Util.mix({\n        x: center.x,\n        y: center.y,\n        r: radius,\n        startAngle,\n        endAngle\n      }, lineCfg)\n    });\n  }\n\n}\n\nAbstract.Circle = Circle;\nmodule.exports = Circle;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/component/axis/circle.js"],"names":["Util","require","Abstract","Circle","_initDefaultCfg","startAngle","Math","PI","endAngle","radius","center","getOffsetPoint","value","angle","_getCirclePoint","self","x","cos","y","sin","getTextAlignInfo","point","offset","offsetVector","getOffsetVector","align","baseLine","textAlign","textBaseline","getAxisVector","factor","offsetFactor","drawLine","lineCfg","container","getContainer","top","addShape","className","attrs","mix","r","module","exports"],"mappings":"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","sourcesContent":["const Util = require('../../util/common');\nconst Abstract = require('./abstract');\n\nclass Circle extends Abstract {\n  _initDefaultCfg() {\n    super._initDefaultCfg();\n    this.startAngle = -Math.PI / 2; // start angle，in radian\n    this.endAngle = Math.PI * 3 / 2; // end angle, in radian\n    this.radius = null; // radius\n    this.center = null; // center\n  }\n\n  getOffsetPoint(value) {\n    const { startAngle, endAngle } = this;\n    const angle = startAngle + (endAngle - startAngle) * value;\n    return this._getCirclePoint(angle);\n  }\n\n  _getCirclePoint(angle, radius) {\n    const self = this;\n    const center = self.center;\n    radius = radius || self.radius;\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  }\n\n  getTextAlignInfo(point, offset) {\n    const self = this;\n    const offsetVector = self.getOffsetVector(point, offset);\n    let align;\n    let baseLine = 'middle';\n    if (offsetVector[0] > 0) {\n      align = 'left';\n    } else if (offsetVector[0] < 0) {\n      align = 'right';\n    } else {\n      align = 'center';\n      if (offsetVector[1] > 0) {\n        baseLine = 'top';\n      } else if (offsetVector[1] < 0) {\n        baseLine = 'bottom';\n      }\n    }\n    return {\n      textAlign: align,\n      textBaseline: baseLine\n    };\n  }\n\n  getAxisVector(point) {\n    const center = this.center;\n    const factor = this.offsetFactor;\n    return [ (point.y - center.y) * factor, (point.x - center.x) * -1 * factor ];\n  }\n\n  drawLine(lineCfg) {\n    const { center, radius, startAngle, endAngle } = this;\n    const container = this.getContainer(lineCfg.top);\n    container.addShape('arc', {\n      className: 'axis-line',\n      attrs: Util.mix({\n        x: center.x,\n        y: center.y,\n        r: radius,\n        startAngle,\n        endAngle\n      }, lineCfg)\n    });\n  }\n}\n\nAbstract.Circle = Circle;\nmodule.exports = Circle;\n"]},"metadata":{},"sourceType":"script"}