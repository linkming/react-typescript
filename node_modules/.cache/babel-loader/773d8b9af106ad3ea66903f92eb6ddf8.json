{"ast":null,"code":"const Util = require('../../util/common');\n\nfunction _mod(n, m) {\n  return (n % m + m) % m;\n}\n\nfunction _addStop(steps, gradient) {\n  Util.each(steps, item => {\n    item = item.split(':');\n    gradient.addColorStop(Number(item[0]), item[1]);\n  });\n} // the string format: 'l(0) 0:#ffffff 0.5:#7ec2f3 1:#1890ff'\n\n\nfunction _parseLineGradient(color, shape, context) {\n  const arr = color.split(' ');\n  let angle = arr[0].slice(2, arr[0].length - 1);\n  angle = _mod(parseFloat(angle) * Math.PI / 180, Math.PI * 2);\n  const steps = arr.slice(1);\n  const {\n    minX,\n    minY,\n    maxX,\n    maxY\n  } = shape.getBBox();\n  let start;\n  let end;\n\n  if (angle >= 0 && angle < 0.5 * Math.PI) {\n    start = {\n      x: minX,\n      y: minY\n    };\n    end = {\n      x: maxX,\n      y: maxY\n    };\n  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {\n    start = {\n      x: maxX,\n      y: minY\n    };\n    end = {\n      x: minX,\n      y: maxY\n    };\n  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {\n    start = {\n      x: maxX,\n      y: maxY\n    };\n    end = {\n      x: minX,\n      y: minY\n    };\n  } else {\n    start = {\n      x: minX,\n      y: maxY\n    };\n    end = {\n      x: maxX,\n      y: minY\n    };\n  }\n\n  const tanTheta = Math.tan(angle);\n  const tanTheta2 = tanTheta * tanTheta;\n  const x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n  const y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;\n  const gradient = context.createLinearGradient(start.x, start.y, x, y);\n\n  _addStop(steps, gradient);\n\n  return gradient;\n} // the string format: 'r(0.5, 0.5, 0.1) 0:#ffffff 1:#1890ff'\n\n\nfunction _parseRadialGradient(color, shape, context) {\n  const arr = color.split(' ');\n  let circleCfg = arr[0].slice(2, arr[0].length - 1);\n  circleCfg = circleCfg.split(',');\n  const fx = parseFloat(circleCfg[0]);\n  const fy = parseFloat(circleCfg[1]);\n  const fr = parseFloat(circleCfg[2]);\n  const steps = arr.slice(1); // if radius is 0, no gradient, stroke with the last color\n\n  if (fr === 0) {\n    const color = steps[steps.length - 1];\n    return color.split(':')[1];\n  }\n\n  const {\n    width,\n    height,\n    minX,\n    minY\n  } = shape.getBBox();\n  const r = Math.sqrt(width * width + height * height) / 2;\n  const gradient = context.createRadialGradient(minX + width * fx, minY + height * fy, fr * r, minX + width / 2, minY + height / 2, r);\n\n  _addStop(steps, gradient);\n\n  return gradient;\n}\n\nmodule.exports = {\n  parseStyle(color, shape, context) {\n    if (color[1] === '(') {\n      try {\n        const firstCode = color[0];\n\n        if (firstCode === 'l') {\n          return _parseLineGradient(color, shape, context);\n        } else if (firstCode === 'r') {\n          return _parseRadialGradient(color, shape, context);\n        }\n      } catch (ev) {\n        console.error('error in parsing gradient string, please check if there are any extra whitespaces.');\n        console.error(ev);\n      }\n    }\n\n    return color;\n  }\n\n};","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/graphic/util/style-parse.js"],"names":["Util","require","_mod","n","m","_addStop","steps","gradient","each","item","split","addColorStop","Number","_parseLineGradient","color","shape","context","arr","angle","slice","length","parseFloat","Math","PI","minX","minY","maxX","maxY","getBBox","start","end","x","y","tanTheta","tan","tanTheta2","createLinearGradient","_parseRadialGradient","circleCfg","fx","fy","fr","width","height","r","sqrt","createRadialGradient","module","exports","parseStyle","firstCode","ev","console","error"],"mappings":"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","sourcesContent":["const Util = require('../../util/common');\n\nfunction _mod(n, m) {\n  return ((n % m) + m) % m;\n}\n\nfunction _addStop(steps, gradient) {\n  Util.each(steps, item => {\n    item = item.split(':');\n    gradient.addColorStop(Number(item[0]), item[1]);\n  });\n}\n\n// the string format: 'l(0) 0:#ffffff 0.5:#7ec2f3 1:#1890ff'\nfunction _parseLineGradient(color, shape, context) {\n  const arr = color.split(' ');\n  let angle = arr[0].slice(2, arr[0].length - 1);\n  angle = _mod((parseFloat(angle) * Math.PI) / 180, Math.PI * 2);\n  const steps = arr.slice(1);\n\n  const { minX, minY, maxX, maxY } = shape.getBBox();\n  let start;\n  let end;\n\n  if (angle >= 0 && angle < 0.5 * Math.PI) {\n    start = {\n      x: minX,\n      y: minY\n    };\n    end = {\n      x: maxX,\n      y: maxY\n    };\n  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {\n    start = {\n      x: maxX,\n      y: minY\n    };\n    end = {\n      x: minX,\n      y: maxY\n    };\n  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {\n    start = {\n      x: maxX,\n      y: maxY\n    };\n    end = {\n      x: minX,\n      y: minY\n    };\n  } else {\n    start = {\n      x: minX,\n      y: maxY\n    };\n    end = {\n      x: maxX,\n      y: minY\n    };\n  }\n\n  const tanTheta = Math.tan(angle);\n  const tanTheta2 = tanTheta * tanTheta;\n\n  const x = ((end.x - start.x) + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n  const y = tanTheta * ((end.x - start.x) + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;\n  const gradient = context.createLinearGradient(start.x, start.y, x, y);\n  _addStop(steps, gradient);\n  return gradient;\n}\n\n// the string format: 'r(0.5, 0.5, 0.1) 0:#ffffff 1:#1890ff'\nfunction _parseRadialGradient(color, shape, context) {\n  const arr = color.split(' ');\n  let circleCfg = arr[0].slice(2, arr[0].length - 1);\n  circleCfg = circleCfg.split(',');\n  const fx = parseFloat(circleCfg[0]);\n  const fy = parseFloat(circleCfg[1]);\n  const fr = parseFloat(circleCfg[2]);\n  const steps = arr.slice(1);\n  // if radius is 0, no gradient, stroke with the last color\n  if (fr === 0) {\n    const color = steps[steps.length - 1];\n    return color.split(':')[1];\n  }\n  const { width, height, minX, minY } = shape.getBBox();\n  const r = Math.sqrt(width * width + height * height) / 2;\n  const gradient = context.createRadialGradient(minX + width * fx, minY + height * fy, fr * r, minX + width / 2, minY + height / 2, r);\n  _addStop(steps, gradient);\n  return gradient;\n}\n\nmodule.exports = {\n  parseStyle(color, shape, context) {\n    if (color[1] === '(') {\n      try {\n        const firstCode = color[0];\n        if (firstCode === 'l') {\n          return _parseLineGradient(color, shape, context);\n        } else if (firstCode === 'r') {\n          return _parseRadialGradient(color, shape, context);\n        }\n      } catch (ev) {\n        console.error('error in parsing gradient string, please check if there are any extra whitespaces.');\n        console.error(ev);\n      }\n    }\n    return color;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}