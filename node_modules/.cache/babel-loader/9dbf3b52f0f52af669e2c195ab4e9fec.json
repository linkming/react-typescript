{"ast":null,"code":"const Util = require('../../util/common');\n\nconst Shape = require('../shape');\n\nconst RectUtil = require('../util/rect');\n\nlet textWidthCacheCounter = 0;\nlet textWidthCache = {};\nconst TEXT_CACHE_MAX = 5000;\n\nclass Text extends Shape {\n  _initProperties() {\n    super._initProperties();\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'text';\n  }\n\n  getDefaultAttrs() {\n    return {\n      lineWidth: 0,\n      lineCount: 1,\n      fontSize: 12,\n      fontFamily: 'sans-serif',\n      fontStyle: 'normal',\n      fontWeight: 'normal',\n      fontVariant: 'normal',\n      textAlign: 'start',\n      textBaseline: 'bottom',\n      lineHeight: null,\n      textArr: null\n    };\n  }\n\n  _getFontStyle() {\n    const attrs = this._attrs.attrs;\n    const {\n      fontSize,\n      fontFamily,\n      fontWeight,\n      fontStyle,\n      fontVariant\n    } = attrs;\n    return `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}px ${fontFamily}`;\n  }\n\n  _afterAttrsSet() {\n    const attrs = this._attrs.attrs;\n    attrs.font = this._getFontStyle();\n\n    if (attrs.text) {\n      const text = attrs.text;\n      let textArr = null;\n      let lineCount = 1;\n\n      if (Util.isString(text) && text.indexOf('\\n') !== -1) {\n        textArr = text.split('\\n');\n        lineCount = textArr.length;\n      }\n\n      attrs.lineCount = lineCount;\n      attrs.textArr = textArr;\n    }\n\n    this.set('attrs', attrs);\n  }\n\n  _getTextHeight() {\n    const attrs = this._attrs.attrs;\n\n    if (attrs.height) {\n      return attrs.height;\n    }\n\n    const lineCount = attrs.lineCount;\n    const fontSize = attrs.fontSize * 1;\n\n    if (lineCount > 1) {\n      const spaceingY = this._getSpaceingY();\n\n      return fontSize * lineCount + spaceingY * (lineCount - 1);\n    }\n\n    return fontSize;\n  }\n\n  _getSpaceingY() {\n    const attrs = this._attrs.attrs;\n    const lineHeight = attrs.lineHeight;\n    const fontSize = attrs.fontSize * 1;\n    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n  }\n\n  drawInner(context) {\n    const self = this;\n    const attrs = self._attrs.attrs;\n    const text = attrs.text;\n    let x = attrs.x;\n    let y = attrs.y;\n\n    if (Util.isNil(text) || isNaN(x) || isNaN(y)) {\n      // text will be 0\n      return;\n    }\n\n    const textArr = attrs.textArr;\n    const fontSize = attrs.fontSize * 1;\n\n    const spaceingY = self._getSpaceingY();\n\n    if (attrs.rotate) {\n      // do rotation\n      context.translate(x, y);\n      context.rotate(attrs.rotate);\n      x = 0;\n      y = 0;\n    }\n\n    const textBaseline = attrs.textBaseline;\n    let height;\n\n    if (textArr) {\n      height = self._getTextHeight();\n    }\n\n    let subY; // context.beginPath();\n\n    if (self.hasFill()) {\n      const fillOpacity = attrs.fillOpacity;\n\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n      }\n\n      if (textArr) {\n        for (let i = 0, len = textArr.length; i < len; i++) {\n          const subText = textArr[i];\n          subY = y + i * (spaceingY + fontSize) - height + fontSize; // bottom;\n\n          if (textBaseline === 'middle') {\n            subY += height - fontSize - (height - fontSize) / 2;\n          }\n\n          if (textBaseline === 'top') {\n            subY += height - fontSize;\n          }\n\n          context.fillText(subText, x, subY);\n        }\n      } else {\n        context.fillText(text, x, y);\n      }\n    }\n\n    if (self.hasStroke()) {\n      if (textArr) {\n        for (let i = 0, len = textArr.length; i < len; i++) {\n          const subText = textArr[i];\n          subY = y + i * (spaceingY + fontSize) - height + fontSize; // bottom;\n\n          if (textBaseline === 'middle') {\n            subY += height - fontSize - (height - fontSize) / 2;\n          }\n\n          if (textBaseline === 'top') {\n            subY += height - fontSize;\n          }\n\n          context.strokeText(subText, x, subY);\n        }\n      } else {\n        context.strokeText(text, x, y);\n      }\n    }\n  }\n\n  calculateBox() {\n    const self = this;\n    const attrs = self._attrs.attrs;\n    const {\n      x,\n      y,\n      textAlign,\n      textBaseline\n    } = attrs;\n\n    let width = self._getTextWidth(); // attrs.width\n\n\n    if (!width) {\n      return {\n        minX: x,\n        minY: y,\n        maxX: x,\n        maxY: y\n      };\n    }\n\n    let height = self._getTextHeight(); // attrs.height\n\n\n    if (attrs.rotate) {\n      const rotatedBox = RectUtil.calcRotatedBox({\n        width,\n        height,\n        rotate: attrs.rotate\n      });\n      width = rotatedBox.width;\n      height = rotatedBox.height;\n    }\n\n    const point = {\n      x,\n      y: y - height\n    }; // default textAlign: start, textBaseline: bottom\n\n    if (textAlign) {\n      if (textAlign === 'end' || textAlign === 'right') {\n        point.x -= width;\n      } else if (textAlign === 'center') {\n        point.x -= width / 2;\n      }\n    }\n\n    if (textBaseline) {\n      if (textBaseline === 'top') {\n        point.y += height;\n      } else if (textBaseline === 'middle') {\n        point.y += height / 2;\n      }\n    }\n\n    return {\n      minX: point.x,\n      minY: point.y,\n      maxX: point.x + width,\n      maxY: point.y + height\n    };\n  }\n\n  _getTextWidth() {\n    const attrs = this._attrs.attrs;\n\n    if (attrs.width) {\n      return attrs.width;\n    }\n\n    const text = attrs.text;\n    const context = this.get('context');\n    if (Util.isNil(text)) return undefined;\n    const font = attrs.font;\n    const textArr = attrs.textArr;\n    const key = text + '' + font;\n\n    if (textWidthCache[key]) {\n      return textWidthCache[key];\n    }\n\n    let width = 0;\n\n    if (textArr) {\n      for (let i = 0, length = textArr.length; i < length; i++) {\n        const subText = textArr[i];\n        width = Math.max(width, Util.measureText(subText, font, context).width);\n      }\n    } else {\n      width = Util.measureText(text, font, context).width;\n    }\n\n    if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n      textWidthCacheCounter = 0;\n      textWidthCache = {};\n    }\n\n    textWidthCacheCounter++;\n    textWidthCache[key] = width;\n    return width;\n  }\n\n}\n\nShape.Text = Text;\nmodule.exports = Text;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/graphic/shape/text.js"],"names":["Util","require","Shape","RectUtil","textWidthCacheCounter","textWidthCache","TEXT_CACHE_MAX","Text","_initProperties","_attrs","canFill","canStroke","type","getDefaultAttrs","lineWidth","lineCount","fontSize","fontFamily","fontStyle","fontWeight","fontVariant","textAlign","textBaseline","lineHeight","textArr","_getFontStyle","attrs","_afterAttrsSet","font","text","isString","indexOf","split","length","set","_getTextHeight","height","spaceingY","_getSpaceingY","drawInner","context","self","x","y","isNil","isNaN","rotate","translate","subY","hasFill","fillOpacity","globalAlpha","i","len","subText","fillText","hasStroke","strokeText","calculateBox","width","_getTextWidth","minX","minY","maxX","maxY","rotatedBox","calcRotatedBox","point","get","undefined","key","Math","max","measureText","module","exports"],"mappings":"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","sourcesContent":["const Util = require('../../util/common');\nconst Shape = require('../shape');\nconst RectUtil = require('../util/rect');\n\nlet textWidthCacheCounter = 0;\nlet textWidthCache = {};\nconst TEXT_CACHE_MAX = 5000;\n\nclass Text extends Shape {\n  _initProperties() {\n    super._initProperties();\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'text';\n  }\n\n  getDefaultAttrs() {\n    return {\n      lineWidth: 0,\n      lineCount: 1,\n      fontSize: 12,\n      fontFamily: 'sans-serif',\n      fontStyle: 'normal',\n      fontWeight: 'normal',\n      fontVariant: 'normal',\n      textAlign: 'start',\n      textBaseline: 'bottom',\n      lineHeight: null,\n      textArr: null\n    };\n  }\n\n  _getFontStyle() {\n    const attrs = this._attrs.attrs;\n    const { fontSize, fontFamily, fontWeight, fontStyle, fontVariant } = attrs;\n    return `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}px ${fontFamily}`;\n  }\n\n  _afterAttrsSet() {\n    const attrs = this._attrs.attrs;\n    attrs.font = this._getFontStyle();\n\n    if (attrs.text) {\n      const text = attrs.text;\n      let textArr = null;\n      let lineCount = 1;\n      if (Util.isString(text) && (text.indexOf('\\n') !== -1)) {\n        textArr = text.split('\\n');\n        lineCount = textArr.length;\n      }\n      attrs.lineCount = lineCount;\n      attrs.textArr = textArr;\n    }\n    this.set('attrs', attrs);\n  }\n\n  _getTextHeight() {\n    const attrs = this._attrs.attrs;\n    if (attrs.height) {\n      return attrs.height;\n    }\n    const lineCount = attrs.lineCount;\n    const fontSize = attrs.fontSize * 1;\n    if (lineCount > 1) {\n      const spaceingY = this._getSpaceingY();\n      return fontSize * lineCount + spaceingY * (lineCount - 1);\n    }\n    return fontSize;\n  }\n\n  _getSpaceingY() {\n    const attrs = this._attrs.attrs;\n    const lineHeight = attrs.lineHeight;\n    const fontSize = attrs.fontSize * 1;\n    return lineHeight ? (lineHeight - fontSize) : fontSize * 0.14;\n  }\n\n  drawInner(context) {\n    const self = this;\n    const attrs = self._attrs.attrs;\n    const text = attrs.text;\n    let x = attrs.x;\n    let y = attrs.y;\n    if (Util.isNil(text) || isNaN(x) || isNaN(y)) { // text will be 0\n      return;\n    }\n    const textArr = attrs.textArr;\n    const fontSize = attrs.fontSize * 1;\n    const spaceingY = self._getSpaceingY();\n\n    if (attrs.rotate) { // do rotation\n      context.translate(x, y);\n      context.rotate(attrs.rotate);\n      x = 0;\n      y = 0;\n    }\n\n    const textBaseline = attrs.textBaseline;\n    let height;\n    if (textArr) {\n      height = self._getTextHeight();\n    }\n    let subY;\n\n    // context.beginPath();\n    if (self.hasFill()) {\n      const fillOpacity = attrs.fillOpacity;\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n      }\n      if (textArr) {\n        for (let i = 0, len = textArr.length; i < len; i++) {\n          const subText = textArr[i];\n          subY = y + i * (spaceingY + fontSize) - height + fontSize; // bottom;\n          if (textBaseline === 'middle') {\n            subY += height - fontSize - (height - fontSize) / 2;\n          }\n          if (textBaseline === 'top') {\n            subY += height - fontSize;\n          }\n          context.fillText(subText, x, subY);\n        }\n      } else {\n        context.fillText(text, x, y);\n      }\n    }\n\n    if (self.hasStroke()) {\n      if (textArr) {\n        for (let i = 0, len = textArr.length; i < len; i++) {\n          const subText = textArr[i];\n          subY = y + i * (spaceingY + fontSize) - height + fontSize; // bottom;\n          if (textBaseline === 'middle') {\n            subY += height - fontSize - (height - fontSize) / 2;\n          }\n          if (textBaseline === 'top') {\n            subY += height - fontSize;\n          }\n          context.strokeText(subText, x, subY);\n        }\n      } else {\n        context.strokeText(text, x, y);\n      }\n    }\n  }\n\n  calculateBox() {\n    const self = this;\n    const attrs = self._attrs.attrs;\n    const { x, y, textAlign, textBaseline } = attrs;\n    let width = self._getTextWidth(); // attrs.width\n    if (!width) {\n      return {\n        minX: x,\n        minY: y,\n        maxX: x,\n        maxY: y\n      };\n    }\n    let height = self._getTextHeight(); // attrs.height\n\n    if (attrs.rotate) {\n      const rotatedBox = RectUtil.calcRotatedBox({\n        width,\n        height,\n        rotate: attrs.rotate\n      });\n      width = rotatedBox.width;\n      height = rotatedBox.height;\n    }\n    const point = {\n      x,\n      y: y - height\n    }; // default textAlign: start, textBaseline: bottom\n\n    if (textAlign) {\n      if (textAlign === 'end' || textAlign === 'right') {\n        point.x -= width;\n      } else if (textAlign === 'center') {\n        point.x -= width / 2;\n      }\n    }\n\n    if (textBaseline) {\n      if (textBaseline === 'top') {\n        point.y += height;\n      } else if (textBaseline === 'middle') {\n        point.y += height / 2;\n      }\n    }\n\n    return {\n      minX: point.x,\n      minY: point.y,\n      maxX: point.x + width,\n      maxY: point.y + height\n    };\n  }\n\n  _getTextWidth() {\n    const attrs = this._attrs.attrs;\n    if (attrs.width) {\n      return attrs.width;\n    }\n    const text = attrs.text;\n    const context = this.get('context');\n\n    if (Util.isNil(text)) return undefined;\n\n    const font = attrs.font;\n    const textArr = attrs.textArr;\n    const key = text + '' + font;\n    if (textWidthCache[key]) {\n      return textWidthCache[key];\n    }\n\n    let width = 0;\n    if (textArr) {\n      for (let i = 0, length = textArr.length; i < length; i++) {\n        const subText = textArr[i];\n        width = Math.max(width, Util.measureText(subText, font, context).width);\n      }\n    } else {\n      width = Util.measureText(text, font, context).width;\n    }\n\n    if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n      textWidthCacheCounter = 0;\n      textWidthCache = {};\n    }\n    textWidthCacheCounter++;\n    textWidthCache[key] = width;\n\n    return width;\n  }\n}\n\nShape.Text = Text;\nmodule.exports = Text;\n"]},"metadata":{},"sourceType":"script"}