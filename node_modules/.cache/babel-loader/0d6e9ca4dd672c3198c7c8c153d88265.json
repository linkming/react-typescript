{"ast":null,"code":"/**\n * @fileOverview 自动计算数字坐标轴\n * @author dxq613@gmail.com\n */\nvar isNil = require('@antv/util/lib/type/is-nil');\n\nvar isNumber = require('@antv/util/lib/type/is-number');\n\nvar AutoUtil = require('./util');\n\nvar MIN_COUNT = 5;\nvar MAX_COUNT = 7;\nvar SNAP_COUNT_ARRAY = [0, 1, 1.2, 1.5, 1.6, 2, 2.2, 2.4, 2.5, 3, 4, 5, 6, 7.5, 8, 10];\nvar SNAP_ARRAY = [0, 1, 2, 4, 5, 10];\nvar EPS = 1e-12;\n\nmodule.exports = function (info) {\n  var min = info.min;\n  var max = info.max;\n  var interval = info.interval;\n  var minTickInterval = info.minTickInterval;\n  var ticks = [];\n  var minCount = info.minCount || MIN_COUNT;\n  var maxCount = info.maxCount || MAX_COUNT;\n  var isFixedCount = minCount === maxCount; // 是否限定死了个数\n\n  var minLimit = isNil(info.minLimit) ? -Infinity : info.minLimit; // 限定的最小值\n\n  var maxLimit = isNil(info.maxLimit) ? Infinity : info.maxLimit; // 限定最大值\n\n  var avgCount = (minCount + maxCount) / 2;\n  var count = avgCount; // 用户传入的逼近数组\n\n  var snapArray = info.snapArray ? info.snapArray : isFixedCount ? SNAP_COUNT_ARRAY : SNAP_ARRAY; // 如果限定大小范围，同时大小范围等于用户传入的范围，同时限定了个数，interval 按照个数均分\n\n  if (min === minLimit && max === maxLimit && isFixedCount) {\n    interval = (max - min) / (count - 1);\n  }\n\n  if (isNil(min)) {\n    min = 0;\n  }\n\n  if (isNil(max)) {\n    max = 0;\n  }\n\n  if (Math.abs(max - min) < EPS) {\n    if (min === 0) {\n      max = 1;\n    } else {\n      if (min > 0) {\n        min = 0;\n      } else {\n        max = 0;\n      }\n    }\n\n    if (max - min < 5 && !interval && max - min >= 1) {\n      interval = 1;\n    }\n  }\n\n  if (isNil(interval)) {\n    // 计算间距\n    var temp = (max - min) / (avgCount - 1);\n    interval = AutoUtil.snapFactorTo(temp, snapArray, 'ceil');\n\n    if (maxCount !== minCount) {\n      count = parseInt((max - min) / interval, 10);\n\n      if (count > maxCount) {\n        count = maxCount;\n      }\n\n      if (count < minCount) {\n        count = minCount;\n      } // 不确定tick的个数时，使得tick偏小\n\n\n      interval = AutoUtil.snapFactorTo((max - min) / (count - 1), snapArray, 'floor');\n    }\n  } // interval should not be less than minTickInterval\n\n\n  if (isNumber(minTickInterval) && interval < minTickInterval) {\n    interval = minTickInterval;\n  }\n\n  if (info.interval || maxCount !== minCount) {\n    // 校正 max 和 min\n    max = Math.min(AutoUtil.snapMultiple(max, interval, 'ceil'), maxLimit); // 向上逼近\n\n    min = Math.max(AutoUtil.snapMultiple(min, interval, 'floor'), minLimit); // 向下逼近\n\n    count = Math.round((max - min) / interval);\n    min = AutoUtil.fixedBase(min, interval); // 当min为负数的时候，fixedBase后，min可能会大于minLimit，导致最终产出的tick是大于minLimit的，所以必须进行修正\n\n    max = AutoUtil.fixedBase(max, interval);\n    var prevMin = null;\n\n    while (min > minLimit && minLimit > -Infinity && (prevMin === null || min < prevMin)) {\n      // 保证计算出来的刻度最小值 min， 不大于数据最小值 min\n      prevMin = min;\n      min = AutoUtil.fixedBase(min - interval, interval);\n    }\n  } else {\n    avgCount = parseInt(avgCount, 10); // 取整\n\n    var avg = (max + min) / 2;\n    var avgTick = AutoUtil.snapMultiple(avg, interval, 'ceil');\n    var sideCount = Math.floor((avgCount - 2) / 2);\n    var maxTick = avgTick + sideCount * interval;\n    var minTick;\n\n    if (avgCount % 2 === 0) {\n      minTick = avgTick - sideCount * interval;\n    } else {\n      minTick = avgTick - (sideCount + 1) * interval;\n    }\n\n    var prevMaxTick = null; // 如果减去intervl, fixBase后，新的minTick没有大于之前的值，就退出，防止死循环\n\n    while (maxTick < max && (prevMaxTick === null || maxTick > prevMaxTick)) {\n      // 保证计算出来的刻度最大值 maxTick 不小于数据最大值 max\n      prevMaxTick = maxTick;\n      maxTick = AutoUtil.fixedBase(maxTick + interval, interval);\n    }\n\n    var prevMinTick = null; // 如果减去intervl, fixBase后，新的minTick没有小于之前的值，就退出，防止死循环\n\n    while (minTick > min && (prevMinTick === null || minTick < prevMinTick)) {\n      // 保证计算出来的刻度最小值 minTick 不大于数据最小值 min\n      prevMinTick = minTick;\n      minTick = AutoUtil.fixedBase(minTick - interval, interval); // 防止超常浮点数计算问题\n    }\n\n    max = maxTick;\n    min = minTick;\n  }\n\n  max = Math.min(max, maxLimit);\n  min = Math.max(min, minLimit);\n  ticks.push(min);\n\n  for (var i = 1; i < count; i++) {\n    var tickValue = AutoUtil.fixedBase(interval * i + min, interval);\n\n    if (tickValue < max) {\n      ticks.push(tickValue);\n    }\n  }\n\n  if (ticks[ticks.length - 1] < max) {\n    ticks.push(max);\n  }\n\n  return {\n    min: min,\n    max: max,\n    interval: interval,\n    count: count,\n    ticks: ticks\n  };\n};","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_scale@0.1.4@@antv/scale/lib/auto/number.js"],"names":["isNil","require","isNumber","AutoUtil","MIN_COUNT","MAX_COUNT","SNAP_COUNT_ARRAY","SNAP_ARRAY","EPS","module","exports","info","min","max","interval","minTickInterval","ticks","minCount","maxCount","isFixedCount","minLimit","Infinity","maxLimit","avgCount","count","snapArray","Math","abs","temp","snapFactorTo","parseInt","snapMultiple","round","fixedBase","prevMin","avg","avgTick","sideCount","floor","maxTick","minTick","prevMaxTick","prevMinTick","push","i","tickValue","length"],"mappings":"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","sourcesContent":["/**\n * @fileOverview 自动计算数字坐标轴\n * @author dxq613@gmail.com\n */\nvar isNil = require('@antv/util/lib/type/is-nil');\n\nvar isNumber = require('@antv/util/lib/type/is-number');\n\nvar AutoUtil = require('./util');\n\nvar MIN_COUNT = 5;\nvar MAX_COUNT = 7;\nvar SNAP_COUNT_ARRAY = [0, 1, 1.2, 1.5, 1.6, 2, 2.2, 2.4, 2.5, 3, 4, 5, 6, 7.5, 8, 10];\nvar SNAP_ARRAY = [0, 1, 2, 4, 5, 10];\nvar EPS = 1e-12;\n\nmodule.exports = function (info) {\n  var min = info.min;\n  var max = info.max;\n  var interval = info.interval;\n  var minTickInterval = info.minTickInterval;\n  var ticks = [];\n  var minCount = info.minCount || MIN_COUNT;\n  var maxCount = info.maxCount || MAX_COUNT;\n  var isFixedCount = minCount === maxCount; // 是否限定死了个数\n\n  var minLimit = isNil(info.minLimit) ? -Infinity : info.minLimit; // 限定的最小值\n\n  var maxLimit = isNil(info.maxLimit) ? Infinity : info.maxLimit; // 限定最大值\n\n  var avgCount = (minCount + maxCount) / 2;\n  var count = avgCount; // 用户传入的逼近数组\n\n  var snapArray = info.snapArray ? info.snapArray : isFixedCount ? SNAP_COUNT_ARRAY : SNAP_ARRAY; // 如果限定大小范围，同时大小范围等于用户传入的范围，同时限定了个数，interval 按照个数均分\n\n  if (min === minLimit && max === maxLimit && isFixedCount) {\n    interval = (max - min) / (count - 1);\n  }\n\n  if (isNil(min)) {\n    min = 0;\n  }\n\n  if (isNil(max)) {\n    max = 0;\n  }\n\n  if (Math.abs(max - min) < EPS) {\n    if (min === 0) {\n      max = 1;\n    } else {\n      if (min > 0) {\n        min = 0;\n      } else {\n        max = 0;\n      }\n    }\n\n    if (max - min < 5 && !interval && max - min >= 1) {\n      interval = 1;\n    }\n  }\n\n  if (isNil(interval)) {\n    // 计算间距\n    var temp = (max - min) / (avgCount - 1);\n    interval = AutoUtil.snapFactorTo(temp, snapArray, 'ceil');\n\n    if (maxCount !== minCount) {\n      count = parseInt((max - min) / interval, 10);\n\n      if (count > maxCount) {\n        count = maxCount;\n      }\n\n      if (count < minCount) {\n        count = minCount;\n      } // 不确定tick的个数时，使得tick偏小\n\n\n      interval = AutoUtil.snapFactorTo((max - min) / (count - 1), snapArray, 'floor');\n    }\n  } // interval should not be less than minTickInterval\n\n\n  if (isNumber(minTickInterval) && interval < minTickInterval) {\n    interval = minTickInterval;\n  }\n\n  if (info.interval || maxCount !== minCount) {\n    // 校正 max 和 min\n    max = Math.min(AutoUtil.snapMultiple(max, interval, 'ceil'), maxLimit); // 向上逼近\n\n    min = Math.max(AutoUtil.snapMultiple(min, interval, 'floor'), minLimit); // 向下逼近\n\n    count = Math.round((max - min) / interval);\n    min = AutoUtil.fixedBase(min, interval); // 当min为负数的时候，fixedBase后，min可能会大于minLimit，导致最终产出的tick是大于minLimit的，所以必须进行修正\n\n    max = AutoUtil.fixedBase(max, interval);\n    var prevMin = null;\n\n    while (min > minLimit && minLimit > -Infinity && (prevMin === null || min < prevMin)) {\n      // 保证计算出来的刻度最小值 min， 不大于数据最小值 min\n      prevMin = min;\n      min = AutoUtil.fixedBase(min - interval, interval);\n    }\n  } else {\n    avgCount = parseInt(avgCount, 10); // 取整\n\n    var avg = (max + min) / 2;\n    var avgTick = AutoUtil.snapMultiple(avg, interval, 'ceil');\n    var sideCount = Math.floor((avgCount - 2) / 2);\n    var maxTick = avgTick + sideCount * interval;\n    var minTick;\n\n    if (avgCount % 2 === 0) {\n      minTick = avgTick - sideCount * interval;\n    } else {\n      minTick = avgTick - (sideCount + 1) * interval;\n    }\n\n    var prevMaxTick = null; // 如果减去intervl, fixBase后，新的minTick没有大于之前的值，就退出，防止死循环\n\n    while (maxTick < max && (prevMaxTick === null || maxTick > prevMaxTick)) {\n      // 保证计算出来的刻度最大值 maxTick 不小于数据最大值 max\n      prevMaxTick = maxTick;\n      maxTick = AutoUtil.fixedBase(maxTick + interval, interval);\n    }\n\n    var prevMinTick = null; // 如果减去intervl, fixBase后，新的minTick没有小于之前的值，就退出，防止死循环\n\n    while (minTick > min && (prevMinTick === null || minTick < prevMinTick)) {\n      // 保证计算出来的刻度最小值 minTick 不大于数据最小值 min\n      prevMinTick = minTick;\n      minTick = AutoUtil.fixedBase(minTick - interval, interval); // 防止超常浮点数计算问题\n    }\n\n    max = maxTick;\n    min = minTick;\n  }\n\n  max = Math.min(max, maxLimit);\n  min = Math.max(min, minLimit);\n  ticks.push(min);\n\n  for (var i = 1; i < count; i++) {\n    var tickValue = AutoUtil.fixedBase(interval * i + min, interval);\n\n    if (tickValue < max) {\n      ticks.push(tickValue);\n    }\n  }\n\n  if (ticks[ticks.length - 1] < max) {\n    ticks.push(max);\n  }\n\n  return {\n    min: min,\n    max: max,\n    interval: interval,\n    count: count,\n    ticks: ticks\n  };\n};"]},"metadata":{},"sourceType":"script"}