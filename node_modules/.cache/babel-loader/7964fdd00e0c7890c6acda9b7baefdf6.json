{"ast":null,"code":"const Shape = require('../shape');\n\nconst Smooth = require('../util/smooth');\n\nconst bbox = require('../util/bbox'); // filter the point which x or y is NaN\n\n\nfunction _filterPoints(points) {\n  const filteredPoints = [];\n\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      filteredPoints.push(point);\n    }\n  }\n\n  return filteredPoints;\n}\n\nclass Polyline extends Shape {\n  _initProperties() {\n    super._initProperties();\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'polyline';\n  }\n\n  getDefaultAttrs() {\n    return {\n      points: null,\n      lineWidth: 1,\n      smooth: false\n    };\n  }\n\n  createPath(context) {\n    const self = this;\n    const attrs = self.get('attrs');\n    const {\n      points,\n      smooth\n    } = attrs;\n\n    const filteredPoints = _filterPoints(points);\n\n    context.beginPath();\n\n    if (filteredPoints.length) {\n      context.moveTo(filteredPoints[0].x, filteredPoints[0].y);\n\n      if (smooth) {\n        const constaint = [[0, 0], [1, 1]];\n        const sps = Smooth.smooth(filteredPoints, false, constaint);\n\n        for (let i = 0, n = sps.length; i < n; i++) {\n          const sp = sps[i];\n          context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\n        }\n      } else {\n        let i;\n        let l;\n\n        for (i = 1, l = filteredPoints.length - 1; i < l; i++) {\n          context.lineTo(filteredPoints[i].x, filteredPoints[i].y);\n        }\n\n        context.lineTo(filteredPoints[l].x, filteredPoints[l].y);\n      }\n    }\n  }\n\n  calculateBox() {\n    const attrs = this.get('attrs');\n    const {\n      points,\n      smooth,\n      lineWidth\n    } = attrs;\n\n    const filteredPoints = _filterPoints(points);\n\n    if (smooth) {\n      const newPoints = [];\n      const constaint = [[0, 0], [1, 1]];\n      const sps = Smooth.smooth(filteredPoints, false, constaint);\n\n      for (let i = 0, n = sps.length; i < n; i++) {\n        const sp = sps[i];\n\n        if (i === 0) {\n          newPoints.push([filteredPoints[0].x, filteredPoints[0].y, sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);\n        } else {\n          const lastPoint = sps[i - 1];\n          newPoints.push([lastPoint[5], lastPoint[6], sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);\n        }\n      }\n\n      return bbox.getBBoxFromBezierGroup(newPoints, lineWidth);\n    }\n\n    return bbox.getBBoxFromPoints(filteredPoints, lineWidth);\n  }\n\n}\n\nShape.Polyline = Polyline;\nmodule.exports = Polyline;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/graphic/shape/polyline.js"],"names":["Shape","require","Smooth","bbox","_filterPoints","points","filteredPoints","i","len","length","point","isNaN","x","y","push","Polyline","_initProperties","_attrs","canFill","canStroke","type","getDefaultAttrs","lineWidth","smooth","createPath","context","self","attrs","get","beginPath","moveTo","constaint","sps","n","sp","bezierCurveTo","l","lineTo","calculateBox","newPoints","lastPoint","getBBoxFromBezierGroup","getBBoxFromPoints","module","exports"],"mappings":"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","sourcesContent":["const Shape = require('../shape');\nconst Smooth = require('../util/smooth');\nconst bbox = require('../util/bbox');\n\n// filter the point which x or y is NaN\nfunction _filterPoints(points) {\n  const filteredPoints = [];\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      filteredPoints.push(point);\n    }\n  }\n\n  return filteredPoints;\n}\n\nclass Polyline extends Shape {\n  _initProperties() {\n    super._initProperties();\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'polyline';\n  }\n\n  getDefaultAttrs() {\n    return {\n      points: null,\n      lineWidth: 1,\n      smooth: false\n    };\n  }\n\n  createPath(context) {\n    const self = this;\n    const attrs = self.get('attrs');\n    const { points, smooth } = attrs;\n\n    const filteredPoints = _filterPoints(points);\n\n    context.beginPath();\n    if (filteredPoints.length) {\n      context.moveTo(filteredPoints[0].x, filteredPoints[0].y);\n      if (smooth) {\n        const constaint = [\n          [ 0, 0 ],\n          [ 1, 1 ]\n        ];\n        const sps = Smooth.smooth(filteredPoints, false, constaint);\n        for (let i = 0, n = sps.length; i < n; i++) {\n          const sp = sps[i];\n          context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\n        }\n      } else {\n        let i;\n        let l;\n        for (i = 1, l = filteredPoints.length - 1; i < l; i++) {\n          context.lineTo(filteredPoints[i].x, filteredPoints[i].y);\n        }\n        context.lineTo(filteredPoints[l].x, filteredPoints[l].y);\n      }\n    }\n  }\n\n  calculateBox() {\n    const attrs = this.get('attrs');\n    const { points, smooth, lineWidth } = attrs;\n\n    const filteredPoints = _filterPoints(points);\n    if (smooth) {\n      const newPoints = [];\n      const constaint = [\n        [ 0, 0 ],\n        [ 1, 1 ]\n      ];\n      const sps = Smooth.smooth(filteredPoints, false, constaint);\n      for (let i = 0, n = sps.length; i < n; i++) {\n        const sp = sps[i];\n        if (i === 0) {\n          newPoints.push([ filteredPoints[0].x, filteredPoints[0].y, sp[1], sp[2], sp[3], sp[4], sp[5], sp[6] ]);\n        } else {\n          const lastPoint = sps[ i - 1 ];\n          newPoints.push([ lastPoint[5], lastPoint[6], sp[1], sp[2], sp[3], sp[4], sp[5], sp[6] ]);\n        }\n      }\n      return bbox.getBBoxFromBezierGroup(newPoints, lineWidth);\n    }\n    return bbox.getBBoxFromPoints(filteredPoints, lineWidth);\n  }\n}\n\nShape.Polyline = Polyline;\nmodule.exports = Polyline;\n"]},"metadata":{},"sourceType":"script"}