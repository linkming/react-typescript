{"ast":null,"code":"const Util = require('../../util/common');\n\nconst Global = require('../../global');\n\nconst Vector2 = require('../../graphic/util/vector2');\n\nclass Abastract {\n  _initDefaultCfg() {\n    /**\n     * ticks\n     * @type {Array}\n     */\n    this.ticks = [];\n    /**\n     * the configuration for tickLine\n     * @type {Object}\n     */\n\n    this.tickLine = {};\n    /**\n     * the direction of ticks, 1 means clockwise\n     * @type {Number}\n     */\n\n    this.offsetFactor = 1;\n    /**\n     * the top container\n     * @type {container}\n     */\n\n    this.frontContainer = null;\n    /**\n     * the back container\n     * @type {[type]}\n     */\n\n    this.backContainer = null;\n    /**\n     * points for draw grid line\n     * @type {Array}\n     */\n\n    this.gridPoints = [];\n  }\n\n  constructor(cfg) {\n    this._initDefaultCfg();\n\n    Util.mix(this, cfg);\n    this.draw();\n  }\n\n  draw() {\n    const {\n      line,\n      tickLine,\n      label,\n      grid\n    } = this;\n    grid && this.drawGrid(grid); // draw the grid lines\n\n    tickLine && this.drawTicks(tickLine); // draw the tickLine\n\n    line && this.drawLine(line); // draw axis line\n\n    label && this.drawLabels(); // draw ticks\n  }\n\n  drawTicks(tickCfg) {\n    const self = this;\n    const ticks = self.ticks;\n    const length = tickCfg.length;\n    const container = self.getContainer(tickCfg.top);\n    Util.each(ticks, function (tick) {\n      const start = self.getOffsetPoint(tick.value);\n      const end = self.getSidePoint(start, length);\n      const shape = container.addShape('line', {\n        className: 'axis-tick',\n        attrs: Util.mix({\n          x1: start.x,\n          y1: start.y,\n          x2: end.x,\n          y2: end.y\n        }, tickCfg)\n      });\n      shape._id = self._id + '-ticks';\n    });\n  }\n\n  drawLabels() {\n    const self = this;\n    const labelOffset = self.labelOffset;\n    const labels = self.labels;\n    Util.each(labels, labelShape => {\n      const container = self.getContainer(labelShape.get('top'));\n      const start = self.getOffsetPoint(labelShape.get('value'));\n      const {\n        x,\n        y\n      } = self.getSidePoint(start, labelOffset);\n      labelShape.attr(Util.mix({\n        x,\n        y\n      }, self.getTextAlignInfo(start, labelOffset), labelShape.get('textStyle')));\n      labelShape._id = self._id + '-' + labelShape.attr('text');\n      container.add(labelShape);\n    });\n  }\n\n  drawLine() {}\n\n  drawGrid(grid) {\n    const self = this;\n    const {\n      gridPoints,\n      ticks\n    } = self;\n    let gridCfg = grid;\n    const count = gridPoints.length;\n    Util.each(gridPoints, function (subPoints, index) {\n      if (Util.isFunction(grid)) {\n        const tick = ticks[index] || {};\n        const executedGrid = grid(tick.text, index, count);\n        gridCfg = executedGrid ? Util.mix({}, Global._defaultAxis.grid, executedGrid) : null;\n      }\n\n      if (gridCfg) {\n        const type = gridCfg.type; // has two types: 'line' and 'arc'\n\n        const points = subPoints.points;\n        const container = self.getContainer(gridCfg.top);\n        let shape;\n\n        if (type === 'arc') {\n          const {\n            center,\n            startAngle,\n            endAngle\n          } = self;\n          const radius = Vector2.length([points[0].x - center.x, points[0].y - center.y]);\n          shape = container.addShape('Arc', {\n            className: 'axis-grid',\n            attrs: Util.mix({\n              x: center.x,\n              y: center.y,\n              startAngle,\n              endAngle,\n              r: radius\n            }, gridCfg)\n          });\n        } else {\n          shape = container.addShape('Polyline', {\n            className: 'axis-grid',\n            attrs: Util.mix({\n              points\n            }, gridCfg)\n          });\n        }\n\n        shape._id = subPoints._id;\n      }\n    });\n  }\n\n  getOffsetPoint() {}\n\n  getAxisVector() {}\n\n  getOffsetVector(point, offset) {\n    const self = this;\n    const axisVector = self.getAxisVector(point);\n    const normal = Vector2.normalize([], axisVector);\n    const factor = self.offsetFactor;\n    const verticalVector = [normal[1] * -1 * factor, normal[0] * factor];\n    return Vector2.scale([], verticalVector, offset);\n  }\n\n  getSidePoint(point, offset) {\n    const self = this;\n    const offsetVector = self.getOffsetVector(point, offset);\n    return {\n      x: point.x + offsetVector[0],\n      y: point.y + offsetVector[1]\n    };\n  }\n\n  getTextAlignInfo(point, offset) {\n    const self = this;\n    const offsetVector = self.getOffsetVector(point, offset);\n    let align;\n    let baseLine;\n\n    if (offsetVector[0] > 0) {\n      align = 'left';\n    } else if (offsetVector[0] < 0) {\n      align = 'right';\n    } else {\n      align = 'center';\n    }\n\n    if (offsetVector[1] > 0) {\n      baseLine = 'top';\n    } else if (offsetVector[1] < 0) {\n      baseLine = 'bottom';\n    } else {\n      baseLine = 'middle';\n    }\n\n    return {\n      textAlign: align,\n      textBaseline: baseLine\n    };\n  }\n\n  getContainer(isTop) {\n    const {\n      frontContainer,\n      backContainer\n    } = this;\n    return isTop ? frontContainer : backContainer;\n  }\n\n}\n\nmodule.exports = Abastract;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/component/axis/abstract.js"],"names":["Util","require","Global","Vector2","Abastract","_initDefaultCfg","ticks","tickLine","offsetFactor","frontContainer","backContainer","gridPoints","constructor","cfg","mix","draw","line","label","grid","drawGrid","drawTicks","drawLine","drawLabels","tickCfg","self","length","container","getContainer","top","each","tick","start","getOffsetPoint","value","end","getSidePoint","shape","addShape","className","attrs","x1","x","y1","y","x2","y2","_id","labelOffset","labels","labelShape","get","attr","getTextAlignInfo","add","gridCfg","count","subPoints","index","isFunction","executedGrid","text","_defaultAxis","type","points","center","startAngle","endAngle","radius","r","getAxisVector","getOffsetVector","point","offset","axisVector","normal","normalize","factor","verticalVector","scale","offsetVector","align","baseLine","textAlign","textBaseline","isTop","module","exports"],"mappings":"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","sourcesContent":["const Util = require('../../util/common');\nconst Global = require('../../global');\nconst Vector2 = require('../../graphic/util/vector2');\n\nclass Abastract {\n  _initDefaultCfg() {\n    /**\n     * ticks\n     * @type {Array}\n     */\n    this.ticks = [];\n    /**\n     * the configuration for tickLine\n     * @type {Object}\n     */\n    this.tickLine = {};\n    /**\n     * the direction of ticks, 1 means clockwise\n     * @type {Number}\n     */\n    this.offsetFactor = 1;\n    /**\n     * the top container\n     * @type {container}\n     */\n    this.frontContainer = null;\n    /**\n     * the back container\n     * @type {[type]}\n     */\n    this.backContainer = null;\n    /**\n     * points for draw grid line\n     * @type {Array}\n     */\n    this.gridPoints = [];\n  }\n\n  constructor(cfg) {\n    this._initDefaultCfg();\n    Util.mix(this, cfg);\n    this.draw();\n  }\n\n  draw() {\n    const { line, tickLine, label, grid } = this;\n\n    grid && this.drawGrid(grid); // draw the grid lines\n    tickLine && this.drawTicks(tickLine); // draw the tickLine\n    line && this.drawLine(line); // draw axis line\n    label && this.drawLabels(); // draw ticks\n  }\n\n  drawTicks(tickCfg) {\n    const self = this;\n    const ticks = self.ticks;\n    const length = tickCfg.length;\n    const container = self.getContainer(tickCfg.top);\n    Util.each(ticks, function(tick) {\n      const start = self.getOffsetPoint(tick.value);\n      const end = self.getSidePoint(start, length);\n      const shape = container.addShape('line', {\n        className: 'axis-tick',\n        attrs: Util.mix({\n          x1: start.x,\n          y1: start.y,\n          x2: end.x,\n          y2: end.y\n        }, tickCfg)\n      });\n      shape._id = self._id + '-ticks';\n    });\n  }\n\n  drawLabels() {\n    const self = this;\n    const labelOffset = self.labelOffset;\n    const labels = self.labels;\n    Util.each(labels, labelShape => {\n      const container = self.getContainer(labelShape.get('top'));\n      const start = self.getOffsetPoint(labelShape.get('value'));\n      const { x, y } = self.getSidePoint(start, labelOffset);\n      labelShape.attr(Util.mix({\n        x,\n        y\n      }, self.getTextAlignInfo(start, labelOffset), labelShape.get('textStyle')));\n      labelShape._id = self._id + '-' + labelShape.attr('text');\n      container.add(labelShape);\n    });\n  }\n\n  drawLine() {}\n\n  drawGrid(grid) {\n    const self = this;\n    const { gridPoints, ticks } = self;\n    let gridCfg = grid;\n    const count = gridPoints.length;\n\n    Util.each(gridPoints, function(subPoints, index) {\n      if (Util.isFunction(grid)) {\n        const tick = ticks[index] || {};\n        const executedGrid = grid(tick.text, index, count);\n        gridCfg = executedGrid ? Util.mix({}, Global._defaultAxis.grid, executedGrid) : null;\n      }\n\n      if (gridCfg) {\n        const type = gridCfg.type; // has two types: 'line' and 'arc'\n        const points = subPoints.points;\n        const container = self.getContainer(gridCfg.top);\n        let shape;\n\n        if (type === 'arc') {\n          const { center, startAngle, endAngle } = self;\n          const radius = Vector2.length([ points[0].x - center.x, points[0].y - center.y ]);\n          shape = container.addShape('Arc', {\n            className: 'axis-grid',\n            attrs: Util.mix({\n              x: center.x,\n              y: center.y,\n              startAngle,\n              endAngle,\n              r: radius\n            }, gridCfg)\n          });\n        } else {\n          shape = container.addShape('Polyline', {\n            className: 'axis-grid',\n            attrs: Util.mix({\n              points\n            }, gridCfg)\n          });\n        }\n\n        shape._id = subPoints._id;\n      }\n    });\n  }\n\n  getOffsetPoint() {}\n  getAxisVector() {}\n\n  getOffsetVector(point, offset) {\n    const self = this;\n    const axisVector = self.getAxisVector(point);\n    const normal = Vector2.normalize([], axisVector);\n    const factor = self.offsetFactor;\n    const verticalVector = [ normal[1] * -1 * factor, normal[0] * factor ];\n    return Vector2.scale([], verticalVector, offset);\n  }\n\n  getSidePoint(point, offset) {\n    const self = this;\n    const offsetVector = self.getOffsetVector(point, offset);\n    return {\n      x: point.x + offsetVector[0],\n      y: point.y + offsetVector[1]\n    };\n  }\n\n  getTextAlignInfo(point, offset) {\n    const self = this;\n    const offsetVector = self.getOffsetVector(point, offset);\n    let align;\n    let baseLine;\n    if (offsetVector[0] > 0) {\n      align = 'left';\n    } else if (offsetVector[0] < 0) {\n      align = 'right';\n    } else {\n      align = 'center';\n    }\n    if (offsetVector[1] > 0) {\n      baseLine = 'top';\n    } else if (offsetVector[1] < 0) {\n      baseLine = 'bottom';\n    } else {\n      baseLine = 'middle';\n    }\n    return {\n      textAlign: align,\n      textBaseline: baseLine\n    };\n  }\n\n  getContainer(isTop) {\n    const { frontContainer, backContainer } = this;\n    return isTop ? frontContainer : backContainer;\n  }\n}\n\nmodule.exports = Abastract;\n"]},"metadata":{},"sourceType":"script"}