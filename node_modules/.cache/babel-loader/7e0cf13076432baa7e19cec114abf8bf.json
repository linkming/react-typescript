{"ast":null,"code":"const Util = require('../util/common');\n\nconst Global = require('../global');\n\nconst Tooltip = require('../component/tooltip');\n\nconst Helper = require('../util/helper'); // Register the default configuration for Tooltip\n\n\nGlobal.tooltip = Util.deepMix({\n  triggerOn: ['touchstart', 'touchmove'],\n  // triggerOff: 'touchend',\n  alwaysShow: false,\n  showTitle: false,\n  showCrosshairs: false,\n  crosshairsStyle: {\n    stroke: 'rgba(0, 0, 0, 0.25)',\n    lineWidth: 1\n  },\n  showTooltipMarker: true,\n  background: {\n    radius: 1,\n    fill: 'rgba(0, 0, 0, 0.65)',\n    padding: [3, 5]\n  },\n  titleStyle: {\n    fontSize: 12,\n    fill: '#fff',\n    textAlign: 'start',\n    textBaseline: 'top'\n  },\n  nameStyle: {\n    fontSize: 12,\n    fill: 'rgba(255, 255, 255, 0.65)',\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  valueStyle: {\n    fontSize: 12,\n    fill: '#fff',\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  showItemMarker: true,\n  itemMarkerStyle: {\n    radius: 3,\n    symbol: 'circle',\n    lineWidth: 1,\n    stroke: '#fff'\n  },\n  layout: 'horizontal',\n  snap: false\n}, Global.tooltip || {});\n\nfunction _getTooltipValueScale(geom) {\n  const colorAttr = geom.getAttr('color');\n\n  if (colorAttr) {\n    const colorScale = colorAttr.getScale(colorAttr.type);\n\n    if (colorScale.isLinear) {\n      return colorScale;\n    }\n  }\n\n  const xScale = geom.getXScale();\n  const yScale = geom.getYScale();\n\n  if (yScale) {\n    return yScale;\n  }\n\n  return xScale;\n}\n\nfunction getTooltipName(geom, origin) {\n  let name;\n  let nameScale;\n\n  const groupScales = geom._getGroupScales();\n\n  if (groupScales.length) {\n    Util.each(groupScales, function (scale) {\n      nameScale = scale;\n      return false;\n    });\n  }\n\n  if (nameScale) {\n    const field = nameScale.field;\n    name = nameScale.getText(origin[field]);\n  } else {\n    const valueScale = _getTooltipValueScale(geom);\n\n    name = valueScale.alias || valueScale.field;\n  }\n\n  return name;\n}\n\nfunction getTooltipValue(geom, origin) {\n  const scale = _getTooltipValueScale(geom);\n\n  return scale.getText(origin[scale.field]);\n}\n\nfunction getTooltipTitle(geom, origin) {\n  const position = geom.getAttr('position');\n  const field = position.getFields()[0];\n  const scale = geom.get('scales')[field];\n  return scale.getText(origin[scale.field]);\n}\n\nfunction _indexOfArray(items, item) {\n  let rst = -1;\n  Util.each(items, function (sub, index) {\n    if (sub.title === item.title && sub.name === item.name && sub.value === item.value && sub.color === item.color) {\n      rst = index;\n      return false;\n    }\n  });\n  return rst;\n}\n\nfunction _uniqItems(items) {\n  const tmp = [];\n  Util.each(items, function (item) {\n    const index = _indexOfArray(tmp, item);\n\n    if (index === -1) {\n      tmp.push(item);\n    } else {\n      tmp[index] = item;\n    }\n  });\n  return tmp;\n}\n\nfunction isEqual(arr1, arr2) {\n  return JSON.stringify(arr1) === JSON.stringify(arr2);\n}\n\nclass TooltipController {\n  constructor(cfg) {\n    this.enable = true;\n    this.cfg = {};\n    this.tooltip = null;\n    this.chart = null;\n    this.timeStamp = 0;\n    Util.mix(this, cfg);\n    const chart = this.chart;\n    this.canvasDom = chart.get('canvas').get('el');\n  }\n\n  _setCrosshairsCfg() {\n    const self = this;\n    const chart = self.chart;\n    const defaultCfg = Util.mix({}, Global.tooltip);\n    const geoms = chart.get('geoms');\n    const shapes = [];\n    Util.each(geoms, geom => {\n      const type = geom.get('type');\n\n      if (shapes.indexOf(type) === -1) {\n        shapes.push(type);\n      }\n    });\n    const coordType = chart.get('coord').type;\n\n    if (geoms.length && (coordType === 'cartesian' || coordType === 'rect')) {\n      if (shapes.length === 1 && ['line', 'area', 'path', 'point'].indexOf(shapes[0]) !== -1) {\n        Util.mix(defaultCfg, {\n          showCrosshairs: true\n        });\n      }\n    }\n\n    return defaultCfg;\n  }\n\n  _getMaxLength(cfg = {}) {\n    const {\n      layout,\n      plotRange\n    } = cfg;\n    return layout === 'horizontal' ? plotRange.br.x - plotRange.bl.x : plotRange.bl.y - plotRange.tr.y;\n  }\n\n  render() {\n    const self = this;\n\n    if (self.tooltip) {\n      return;\n    }\n\n    const chart = self.chart;\n    const canvas = chart.get('canvas');\n    const frontPlot = chart.get('frontPlot').addGroup({\n      className: 'tooltipContainer',\n      zIndex: 10\n    });\n    const backPlot = chart.get('backPlot').addGroup({\n      className: 'tooltipContainer'\n    });\n    const plotRange = chart.get('plotRange');\n    const coord = chart.get('coord');\n\n    const defaultCfg = self._setCrosshairsCfg();\n\n    const cfg = self.cfg; // 通过 chart.tooltip() 接口传入的 tooltip 配置项\n\n    const tooltipCfg = Util.deepMix({\n      plotRange,\n      frontPlot,\n      backPlot,\n      canvas,\n      fixed: coord.transposed || coord.isPolar\n    }, defaultCfg, cfg); // 创建 tooltip 实例需要的配置，不应该修改 this.cfg，即用户传入的配置\n\n    tooltipCfg.maxLength = self._getMaxLength(tooltipCfg);\n    this._tooltipCfg = tooltipCfg;\n    const tooltip = new Tooltip(tooltipCfg);\n    self.tooltip = tooltip;\n    self.bindEvents();\n  }\n\n  clear() {\n    const tooltip = this.tooltip;\n\n    if (tooltip) {\n      tooltip.destroy();\n      this.unBindEvents();\n    }\n\n    this.tooltip = null;\n    this.prePoint = null;\n    this._lastActive = null;\n  }\n\n  _getTooltipMarkerStyle(cfg = {}) {\n    const {\n      type,\n      items\n    } = cfg;\n    const tooltipCfg = this._tooltipCfg;\n\n    if (type === 'rect') {\n      let x;\n      let y;\n      let width;\n      let height;\n      const chart = this.chart;\n      const {\n        tl,\n        br\n      } = chart.get('plotRange');\n      const coord = chart.get('coord');\n      const firstItem = items[0];\n      const lastItem = items[items.length - 1];\n      const intervalWidth = firstItem.width;\n\n      if (coord.transposed) {\n        x = tl.x;\n        y = lastItem.y - intervalWidth * 0.75;\n        width = br.x - tl.x;\n        height = firstItem.y - lastItem.y + 1.5 * intervalWidth;\n      } else {\n        x = firstItem.x - intervalWidth * 0.75;\n        y = tl.y;\n        width = lastItem.x - firstItem.x + 1.5 * intervalWidth;\n        height = br.y - tl.y;\n      }\n\n      cfg.style = Util.mix({\n        x,\n        y,\n        width,\n        height,\n        fill: '#CCD6EC',\n        opacity: 0.3\n      }, tooltipCfg.tooltipMarkerStyle);\n    } else {\n      cfg.style = Util.mix({\n        radius: 4,\n        fill: '#fff',\n        lineWidth: 2\n      }, tooltipCfg.tooltipMarkerStyle);\n    }\n\n    return cfg;\n  }\n\n  _setTooltip(point, items, tooltipMarkerCfg = {}) {\n    const lastActive = this._lastActive;\n    const tooltip = this.tooltip;\n    const cfg = this._tooltipCfg;\n    items = _uniqItems(items);\n    const chart = this.chart;\n    const coord = chart.get('coord');\n    const yScale = chart.getYScales()[0];\n    const snap = cfg.snap;\n\n    if (snap === false && yScale.isLinear) {\n      const invertPoint = coord.invertPoint(point);\n      const plot = chart.get('plotRange');\n      let tip;\n      let pos;\n\n      if (Helper.isPointInPlot(point, plot)) {\n        if (coord.transposed) {\n          tip = yScale.invert(invertPoint.x);\n          pos = point.x;\n          tooltip.setXTipContent(tip);\n          tooltip.setXTipPosition(pos);\n          tooltip.setYCrosshairPosition(pos);\n        } else {\n          tip = yScale.invert(invertPoint.y);\n          pos = point.y;\n          tooltip.setYTipContent(tip);\n          tooltip.setYTipPosition(pos);\n          tooltip.setXCrosshairPosition(pos);\n        }\n      }\n    }\n\n    if (cfg.onShow) {\n      cfg.onShow({\n        x: point.x,\n        y: point.y,\n        tooltip,\n        items,\n        tooltipMarkerCfg\n      });\n    }\n\n    if (isEqual(lastActive, items)) {\n      if (snap === false && (Util.directionEnabled(cfg.crosshairsType, 'y') || cfg.showYTip)) {\n        const canvas = this.chart.get('canvas');\n        canvas.draw();\n      }\n\n      return;\n    }\n\n    this._lastActive = items;\n    const onChange = cfg.onChange;\n\n    if (onChange) {\n      onChange({\n        x: point.x,\n        y: point.y,\n        tooltip,\n        items,\n        tooltipMarkerCfg\n      });\n    }\n\n    const first = items[0];\n    const title = first.title || first.name;\n    let xTipPosX = first.x;\n\n    if (items.length > 1) {\n      xTipPosX = (items[0].x + items[items.length - 1].x) / 2;\n    }\n\n    tooltip.setContent(title, items, coord.transposed);\n    tooltip.setPosition(items, point);\n\n    if (coord.transposed) {\n      let yTipPosY = first.y;\n\n      if (items.length > 1) {\n        yTipPosY = (items[0].y + items[items.length - 1].y) / 2;\n      }\n\n      tooltip.setYTipContent(title);\n      tooltip.setYTipPosition(yTipPosY);\n      tooltip.setXCrosshairPosition(yTipPosY);\n\n      if (snap) {\n        tooltip.setXTipContent(first.value);\n        tooltip.setXTipPosition(xTipPosX);\n        tooltip.setYCrosshairPosition(xTipPosX);\n      }\n    } else {\n      tooltip.setXTipContent(title);\n      tooltip.setXTipPosition(xTipPosX);\n      tooltip.setYCrosshairPosition(xTipPosX);\n\n      if (snap) {\n        tooltip.setYTipContent(first.value);\n        tooltip.setYTipPosition(first.y);\n        tooltip.setXCrosshairPosition(first.y);\n      }\n    }\n\n    const markerItems = tooltipMarkerCfg.items;\n\n    if (cfg.showTooltipMarker && markerItems.length) {\n      tooltipMarkerCfg = this._getTooltipMarkerStyle(tooltipMarkerCfg);\n      tooltip.setMarkers(tooltipMarkerCfg);\n    } else {\n      tooltip.clearMarkers();\n    }\n\n    tooltip.show();\n  }\n\n  showTooltip(point) {\n    const self = this;\n    const chart = self.chart;\n    let tooltipMarkerType;\n    const tooltipMarkerItems = [];\n    const items = [];\n    const cfg = self._tooltipCfg;\n    let marker;\n\n    if (cfg.showItemMarker) {\n      marker = cfg.itemMarkerStyle;\n    }\n\n    const geoms = chart.get('geoms');\n    const coord = chart.get('coord');\n    Util.each(geoms, geom => {\n      if (geom.get('visible')) {\n        const type = geom.get('type');\n        const records = geom.getSnapRecords(point);\n        const adjust = geom.get('adjust'); // 漏斗图和金子塔图tooltip位置有问题，暂时不开放显示\n\n        if (type === 'interval' && adjust && adjust.type === 'symmetric') {\n          return;\n        }\n\n        Util.each(records, record => {\n          if (record.x && record.y) {\n            const {\n              x,\n              y,\n              _origin,\n              color\n            } = record;\n            const tooltipItem = {\n              x,\n              y: Util.isArray(y) ? y[1] : y,\n              color: color || Global.defaultColor,\n              origin: _origin,\n              name: getTooltipName(geom, _origin),\n              value: getTooltipValue(geom, _origin),\n              title: getTooltipTitle(geom, _origin)\n            };\n\n            if (marker) {\n              tooltipItem.marker = Util.mix({\n                fill: color || Global.defaultColor\n              }, marker);\n            }\n\n            items.push(tooltipItem);\n\n            if (['line', 'area', 'path'].indexOf(type) !== -1) {\n              tooltipMarkerType = 'circle';\n              tooltipMarkerItems.push(tooltipItem);\n            } else if (type === 'interval' && (coord.type === 'cartesian' || coord.type === 'rect')) {\n              tooltipMarkerType = 'rect';\n              tooltipItem.width = geom.getSize(record._origin);\n              tooltipMarkerItems.push(tooltipItem);\n            }\n          }\n        });\n      }\n    });\n\n    if (items.length) {\n      const tooltipMarkerCfg = {\n        items: tooltipMarkerItems,\n        type: tooltipMarkerType\n      };\n\n      self._setTooltip(point, items, tooltipMarkerCfg);\n    } else {\n      self.hideTooltip();\n    }\n  }\n\n  hideTooltip() {\n    const cfg = this._tooltipCfg;\n    this._lastActive = null;\n    const tooltip = this.tooltip;\n\n    if (tooltip) {\n      tooltip.hide();\n\n      if (cfg.onHide) {\n        cfg.onHide({\n          tooltip\n        });\n      }\n\n      const canvas = this.chart.get('canvas');\n      canvas.draw();\n    }\n  }\n\n  handleShowEvent(ev) {\n    const chart = this.chart;\n    if (!this.enable || chart.get('_closeTooltip')) return;\n    const plot = chart.get('plotRange');\n    const point = Util.createEvent(ev, chart);\n\n    if (!Helper.isPointInPlot(point, plot) && !this._tooltipCfg.alwaysShow) {\n      // not in chart plot\n      this.hideTooltip();\n      return;\n    }\n\n    const lastTimeStamp = this.timeStamp;\n    const timeStamp = +new Date();\n\n    if (timeStamp - lastTimeStamp > 16) {\n      this.showTooltip(point);\n      this.timeStamp = timeStamp;\n    }\n  }\n\n  handleHideEvent() {\n    const chart = this.chart;\n    if (!this.enable || chart.get('_closeTooltip')) return;\n    this.hideTooltip();\n  }\n\n  _handleEvent(methodName, method, action) {\n    const canvasDom = this.canvasDom;\n    Util.each([].concat(methodName), aMethod => {\n      if (action === 'bind') {\n        Util.addEventListener(canvasDom, aMethod, method);\n      } else {\n        Util.removeEventListener(canvasDom, aMethod, method);\n      }\n    });\n  }\n\n  bindEvents() {\n    const cfg = this._tooltipCfg;\n    const canvasElement = this.canvasDom;\n    const {\n      triggerOn,\n      triggerOff,\n      alwaysShow\n    } = cfg;\n    const showMethod = Util.wrapBehavior(this, 'handleShowEvent');\n    const hideMethod = Util.wrapBehavior(this, 'handleHideEvent');\n    triggerOn && this._handleEvent(triggerOn, showMethod, 'bind');\n    triggerOff && this._handleEvent(triggerOff, hideMethod, 'bind'); // 如果 !alwaysShow, 则在手势离开后就隐藏\n\n    if (!alwaysShow && !triggerOff) {\n      Util.addEventListener(canvasElement, 'touchend', hideMethod);\n    }\n  }\n\n  unBindEvents() {\n    const cfg = this._tooltipCfg;\n    const canvasElement = this.canvasDom;\n    const {\n      triggerOn,\n      triggerOff,\n      alwaysShow\n    } = cfg;\n    const showMethod = Util.getWrapBehavior(this, 'handleShowEvent');\n    const hideMethod = Util.getWrapBehavior(this, 'handleHideEvent');\n    triggerOn && this._handleEvent(triggerOn, showMethod, 'unBind');\n    triggerOff && this._handleEvent(triggerOff, hideMethod, 'unBind');\n\n    if (!alwaysShow) {\n      const docMethod = Util.getWrapBehavior(this, 'handleDocEvent');\n      Util.removeEventListener(canvasElement, 'touchend', docMethod);\n    }\n  }\n\n}\n\nmodule.exports = {\n  init(chart) {\n    const tooltipController = new TooltipController({\n      chart\n    });\n    chart.set('tooltipController', tooltipController);\n\n    chart.tooltip = function (enable, cfg) {\n      if (Util.isObject(enable)) {\n        cfg = enable;\n        enable = true;\n      }\n\n      tooltipController.enable = enable;\n\n      if (cfg) {\n        tooltipController.cfg = cfg;\n      }\n\n      return this;\n    };\n  },\n\n  afterGeomDraw(chart) {\n    const tooltipController = chart.get('tooltipController');\n    tooltipController.render();\n\n    chart.showTooltip = function (point) {\n      tooltipController.showTooltip(point);\n      return this;\n    };\n\n    chart.hideTooltip = function () {\n      tooltipController.hideTooltip();\n      return this;\n    };\n  },\n\n  clearInner(chart) {\n    const tooltipController = chart.get('tooltipController');\n    tooltipController.clear();\n  }\n\n};","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/plugin/tooltip.js"],"names":["Util","require","Global","Tooltip","Helper","tooltip","deepMix","triggerOn","alwaysShow","showTitle","showCrosshairs","crosshairsStyle","stroke","lineWidth","showTooltipMarker","background","radius","fill","padding","titleStyle","fontSize","textAlign","textBaseline","nameStyle","valueStyle","showItemMarker","itemMarkerStyle","symbol","layout","snap","_getTooltipValueScale","geom","colorAttr","getAttr","colorScale","getScale","type","isLinear","xScale","getXScale","yScale","getYScale","getTooltipName","origin","name","nameScale","groupScales","_getGroupScales","length","each","scale","field","getText","valueScale","alias","getTooltipValue","getTooltipTitle","position","getFields","get","_indexOfArray","items","item","rst","sub","index","title","value","color","_uniqItems","tmp","push","isEqual","arr1","arr2","JSON","stringify","TooltipController","constructor","cfg","enable","chart","timeStamp","mix","canvasDom","_setCrosshairsCfg","self","defaultCfg","geoms","shapes","indexOf","coordType","_getMaxLength","plotRange","br","x","bl","y","tr","render","canvas","frontPlot","addGroup","className","zIndex","backPlot","coord","tooltipCfg","fixed","transposed","isPolar","maxLength","_tooltipCfg","bindEvents","clear","destroy","unBindEvents","prePoint","_lastActive","_getTooltipMarkerStyle","width","height","tl","firstItem","lastItem","intervalWidth","style","opacity","tooltipMarkerStyle","_setTooltip","point","tooltipMarkerCfg","lastActive","getYScales","invertPoint","plot","tip","pos","isPointInPlot","invert","setXTipContent","setXTipPosition","setYCrosshairPosition","setYTipContent","setYTipPosition","setXCrosshairPosition","onShow","directionEnabled","crosshairsType","showYTip","draw","onChange","first","xTipPosX","setContent","setPosition","yTipPosY","markerItems","setMarkers","clearMarkers","show","showTooltip","tooltipMarkerType","tooltipMarkerItems","marker","records","getSnapRecords","adjust","record","_origin","tooltipItem","isArray","defaultColor","getSize","hideTooltip","hide","onHide","handleShowEvent","ev","createEvent","lastTimeStamp","Date","handleHideEvent","_handleEvent","methodName","method","action","concat","aMethod","addEventListener","removeEventListener","canvasElement","triggerOff","showMethod","wrapBehavior","hideMethod","getWrapBehavior","docMethod","module","exports","init","tooltipController","set","isObject","afterGeomDraw","clearInner"],"mappings":"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","sourcesContent":["const Util = require('../util/common');\nconst Global = require('../global');\nconst Tooltip = require('../component/tooltip');\nconst Helper = require('../util/helper');\n\n// Register the default configuration for Tooltip\nGlobal.tooltip = Util.deepMix({\n  triggerOn: [ 'touchstart', 'touchmove' ],\n  // triggerOff: 'touchend',\n  alwaysShow: false,\n  showTitle: false,\n  showCrosshairs: false,\n  crosshairsStyle: {\n    stroke: 'rgba(0, 0, 0, 0.25)',\n    lineWidth: 1\n  },\n  showTooltipMarker: true,\n  background: {\n    radius: 1,\n    fill: 'rgba(0, 0, 0, 0.65)',\n    padding: [ 3, 5 ]\n  },\n  titleStyle: {\n    fontSize: 12,\n    fill: '#fff',\n    textAlign: 'start',\n    textBaseline: 'top'\n  },\n  nameStyle: {\n    fontSize: 12,\n    fill: 'rgba(255, 255, 255, 0.65)',\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  valueStyle: {\n    fontSize: 12,\n    fill: '#fff',\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  showItemMarker: true,\n  itemMarkerStyle: {\n    radius: 3,\n    symbol: 'circle',\n    lineWidth: 1,\n    stroke: '#fff'\n  },\n  layout: 'horizontal',\n  snap: false\n}, Global.tooltip || {});\n\nfunction _getTooltipValueScale(geom) {\n  const colorAttr = geom.getAttr('color');\n  if (colorAttr) {\n    const colorScale = colorAttr.getScale(colorAttr.type);\n    if (colorScale.isLinear) {\n      return colorScale;\n    }\n  }\n  const xScale = geom.getXScale();\n  const yScale = geom.getYScale();\n  if (yScale) {\n    return yScale;\n  }\n\n  return xScale;\n}\n\nfunction getTooltipName(geom, origin) {\n  let name;\n  let nameScale;\n  const groupScales = geom._getGroupScales();\n  if (groupScales.length) {\n    Util.each(groupScales, function(scale) {\n      nameScale = scale;\n      return false;\n    });\n  }\n  if (nameScale) {\n    const field = nameScale.field;\n    name = nameScale.getText(origin[field]);\n  } else {\n    const valueScale = _getTooltipValueScale(geom);\n    name = valueScale.alias || valueScale.field;\n  }\n  return name;\n}\n\nfunction getTooltipValue(geom, origin) {\n  const scale = _getTooltipValueScale(geom);\n  return scale.getText(origin[scale.field]);\n}\n\nfunction getTooltipTitle(geom, origin) {\n  const position = geom.getAttr('position');\n  const field = position.getFields()[0];\n  const scale = geom.get('scales')[field];\n  return scale.getText(origin[scale.field]);\n}\n\nfunction _indexOfArray(items, item) {\n  let rst = -1;\n  Util.each(items, function(sub, index) {\n    if (sub.title === item.title && sub.name === item.name && sub.value === item.value && sub.color === item.color) {\n      rst = index;\n      return false;\n    }\n  });\n  return rst;\n}\n\nfunction _uniqItems(items) {\n  const tmp = [];\n  Util.each(items, function(item) {\n    const index = _indexOfArray(tmp, item);\n    if (index === -1) {\n      tmp.push(item);\n    } else {\n      tmp[index] = item;\n    }\n  });\n  return tmp;\n}\n\nfunction isEqual(arr1, arr2) {\n  return JSON.stringify(arr1) === JSON.stringify(arr2);\n}\n\nclass TooltipController {\n  constructor(cfg) {\n    this.enable = true;\n    this.cfg = {};\n    this.tooltip = null;\n    this.chart = null;\n    this.timeStamp = 0;\n    Util.mix(this, cfg);\n    const chart = this.chart;\n    this.canvasDom = chart.get('canvas').get('el');\n  }\n\n  _setCrosshairsCfg() {\n    const self = this;\n    const chart = self.chart;\n    const defaultCfg = Util.mix({}, Global.tooltip);\n    const geoms = chart.get('geoms');\n    const shapes = [];\n    Util.each(geoms, geom => {\n      const type = geom.get('type');\n      if (shapes.indexOf(type) === -1) {\n        shapes.push(type);\n      }\n    });\n    const coordType = chart.get('coord').type;\n    if (geoms.length && (coordType === 'cartesian' || coordType === 'rect')) {\n      if (shapes.length === 1 && [ 'line', 'area', 'path', 'point' ].indexOf(shapes[0]) !== -1) {\n        Util.mix(defaultCfg, {\n          showCrosshairs: true\n        });\n      }\n    }\n\n    return defaultCfg;\n  }\n\n  _getMaxLength(cfg = {}) {\n    const { layout, plotRange } = cfg;\n    return (layout === 'horizontal') ? plotRange.br.x - plotRange.bl.x : plotRange.bl.y - plotRange.tr.y;\n  }\n\n  render() {\n    const self = this;\n\n    if (self.tooltip) {\n      return;\n    }\n\n    const chart = self.chart;\n    const canvas = chart.get('canvas');\n    const frontPlot = chart.get('frontPlot').addGroup({\n      className: 'tooltipContainer',\n      zIndex: 10\n    });\n    const backPlot = chart.get('backPlot').addGroup({\n      className: 'tooltipContainer'\n    });\n    const plotRange = chart.get('plotRange');\n    const coord = chart.get('coord');\n\n    const defaultCfg = self._setCrosshairsCfg();\n    const cfg = self.cfg; // 通过 chart.tooltip() 接口传入的 tooltip 配置项\n    const tooltipCfg = Util.deepMix({\n      plotRange,\n      frontPlot,\n      backPlot,\n      canvas,\n      fixed: coord.transposed || coord.isPolar\n    }, defaultCfg, cfg); // 创建 tooltip 实例需要的配置，不应该修改 this.cfg，即用户传入的配置\n    tooltipCfg.maxLength = self._getMaxLength(tooltipCfg);\n    this._tooltipCfg = tooltipCfg;\n    const tooltip = new Tooltip(tooltipCfg);\n    self.tooltip = tooltip;\n    self.bindEvents();\n  }\n\n  clear() {\n    const tooltip = this.tooltip;\n    if (tooltip) {\n      tooltip.destroy();\n      this.unBindEvents();\n    }\n    this.tooltip = null;\n    this.prePoint = null;\n    this._lastActive = null;\n  }\n\n  _getTooltipMarkerStyle(cfg = {}) {\n    const { type, items } = cfg;\n    const tooltipCfg = this._tooltipCfg;\n    if (type === 'rect') {\n      let x;\n      let y;\n      let width;\n      let height;\n      const chart = this.chart;\n      const { tl, br } = chart.get('plotRange');\n      const coord = chart.get('coord');\n      const firstItem = items[0];\n      const lastItem = items[items.length - 1];\n      const intervalWidth = firstItem.width;\n      if (coord.transposed) {\n        x = tl.x;\n        y = lastItem.y - intervalWidth * 0.75;\n        width = br.x - tl.x;\n        height = firstItem.y - lastItem.y + 1.5 * intervalWidth;\n      } else {\n        x = firstItem.x - intervalWidth * 0.75;\n        y = tl.y;\n        width = lastItem.x - firstItem.x + 1.5 * intervalWidth;\n        height = br.y - tl.y;\n      }\n\n      cfg.style = Util.mix({\n        x,\n        y,\n        width,\n        height,\n        fill: '#CCD6EC',\n        opacity: 0.3\n      }, tooltipCfg.tooltipMarkerStyle);\n    } else {\n      cfg.style = Util.mix({\n        radius: 4,\n        fill: '#fff',\n        lineWidth: 2\n      }, tooltipCfg.tooltipMarkerStyle);\n    }\n\n    return cfg;\n  }\n\n  _setTooltip(point, items, tooltipMarkerCfg = {}) {\n    const lastActive = this._lastActive;\n    const tooltip = this.tooltip;\n    const cfg = this._tooltipCfg;\n    items = _uniqItems(items);\n\n    const chart = this.chart;\n    const coord = chart.get('coord');\n    const yScale = chart.getYScales()[0];\n    const snap = cfg.snap;\n\n    if (snap === false && yScale.isLinear) {\n      const invertPoint = coord.invertPoint(point);\n      const plot = chart.get('plotRange');\n\n      let tip;\n      let pos;\n      if (Helper.isPointInPlot(point, plot)) {\n        if (coord.transposed) {\n          tip = yScale.invert(invertPoint.x);\n          pos = point.x;\n          tooltip.setXTipContent(tip);\n          tooltip.setXTipPosition(pos);\n          tooltip.setYCrosshairPosition(pos);\n        } else {\n          tip = yScale.invert(invertPoint.y);\n          pos = point.y;\n          tooltip.setYTipContent(tip);\n          tooltip.setYTipPosition(pos);\n          tooltip.setXCrosshairPosition(pos);\n        }\n      }\n    }\n\n\n    if (cfg.onShow) {\n      cfg.onShow({\n        x: point.x,\n        y: point.y,\n        tooltip,\n        items,\n        tooltipMarkerCfg\n      });\n    }\n    if (isEqual(lastActive, items)) {\n      if (snap === false && (Util.directionEnabled(cfg.crosshairsType, 'y') || cfg.showYTip)) {\n        const canvas = this.chart.get('canvas');\n        canvas.draw();\n      }\n      return;\n    }\n    this._lastActive = items;\n\n    const onChange = cfg.onChange;\n    if (onChange) {\n      onChange({\n        x: point.x,\n        y: point.y,\n        tooltip,\n        items,\n        tooltipMarkerCfg\n      });\n    }\n\n    const first = items[0];\n    const title = first.title || first.name;\n    let xTipPosX = first.x;\n    if (items.length > 1) {\n      xTipPosX = (items[0].x + items[items.length - 1].x) / 2;\n    }\n    tooltip.setContent(title, items, coord.transposed);\n    tooltip.setPosition(items, point);\n\n    if (coord.transposed) {\n      let yTipPosY = first.y;\n      if (items.length > 1) {\n        yTipPosY = (items[0].y + items[items.length - 1].y) / 2;\n      }\n      tooltip.setYTipContent(title);\n      tooltip.setYTipPosition(yTipPosY);\n      tooltip.setXCrosshairPosition(yTipPosY);\n\n      if (snap) {\n        tooltip.setXTipContent(first.value);\n        tooltip.setXTipPosition(xTipPosX);\n        tooltip.setYCrosshairPosition(xTipPosX);\n      }\n\n    } else {\n      tooltip.setXTipContent(title);\n      tooltip.setXTipPosition(xTipPosX);\n      tooltip.setYCrosshairPosition(xTipPosX);\n\n      if (snap) {\n        tooltip.setYTipContent(first.value);\n        tooltip.setYTipPosition(first.y);\n        tooltip.setXCrosshairPosition(first.y);\n      }\n    }\n\n    const markerItems = tooltipMarkerCfg.items;\n    if (cfg.showTooltipMarker && markerItems.length) {\n      tooltipMarkerCfg = this._getTooltipMarkerStyle(tooltipMarkerCfg);\n      tooltip.setMarkers(tooltipMarkerCfg);\n    } else {\n      tooltip.clearMarkers();\n    }\n\n    tooltip.show();\n  }\n\n  showTooltip(point) {\n    const self = this;\n    const chart = self.chart;\n\n    let tooltipMarkerType;\n    const tooltipMarkerItems = [];\n    const items = [];\n    const cfg = self._tooltipCfg;\n    let marker;\n    if (cfg.showItemMarker) {\n      marker = cfg.itemMarkerStyle;\n    }\n\n    const geoms = chart.get('geoms');\n    const coord = chart.get('coord');\n    Util.each(geoms, geom => {\n      if (geom.get('visible')) {\n        const type = geom.get('type');\n        const records = geom.getSnapRecords(point);\n        const adjust = geom.get('adjust');\n        // 漏斗图和金子塔图tooltip位置有问题，暂时不开放显示\n        if (type === 'interval' && adjust && adjust.type === 'symmetric') {\n          return;\n        }\n        Util.each(records, record => {\n          if (record.x && record.y) {\n            const { x, y, _origin, color } = record;\n            const tooltipItem = {\n              x,\n              y: Util.isArray(y) ? y[1] : y,\n              color: color || Global.defaultColor,\n              origin: _origin,\n              name: getTooltipName(geom, _origin),\n              value: getTooltipValue(geom, _origin),\n              title: getTooltipTitle(geom, _origin)\n            };\n            if (marker) {\n              tooltipItem.marker = Util.mix({\n                fill: color || Global.defaultColor\n              }, marker);\n            }\n            items.push(tooltipItem);\n\n            if ([ 'line', 'area', 'path' ].indexOf(type) !== -1) {\n              tooltipMarkerType = 'circle';\n              tooltipMarkerItems.push(tooltipItem);\n            } else if (type === 'interval' && (coord.type === 'cartesian' || coord.type === 'rect')) {\n              tooltipMarkerType = 'rect';\n              tooltipItem.width = geom.getSize(record._origin);\n              tooltipMarkerItems.push(tooltipItem);\n            }\n          }\n        });\n      }\n    });\n\n    if (items.length) {\n      const tooltipMarkerCfg = {\n        items: tooltipMarkerItems,\n        type: tooltipMarkerType\n      };\n      self._setTooltip(point, items, tooltipMarkerCfg);\n    } else {\n      self.hideTooltip();\n    }\n  }\n\n  hideTooltip() {\n    const cfg = this._tooltipCfg;\n    this._lastActive = null;\n    const tooltip = this.tooltip;\n    if (tooltip) {\n      tooltip.hide();\n      if (cfg.onHide) {\n        cfg.onHide({\n          tooltip\n        });\n      }\n      const canvas = this.chart.get('canvas');\n      canvas.draw();\n    }\n  }\n\n  handleShowEvent(ev) {\n    const chart = this.chart;\n    if (!this.enable || chart.get('_closeTooltip')) return;\n\n    const plot = chart.get('plotRange');\n    const point = Util.createEvent(ev, chart);\n    if (!Helper.isPointInPlot(point, plot) && !this._tooltipCfg.alwaysShow) { // not in chart plot\n      this.hideTooltip();\n      return;\n    }\n\n    const lastTimeStamp = this.timeStamp;\n    const timeStamp = +new Date();\n    if ((timeStamp - lastTimeStamp) > 16) {\n      this.showTooltip(point);\n      this.timeStamp = timeStamp;\n    }\n  }\n\n  handleHideEvent() {\n    const chart = this.chart;\n    if (!this.enable || chart.get('_closeTooltip')) return;\n\n    this.hideTooltip();\n  }\n\n  _handleEvent(methodName, method, action) {\n    const canvasDom = this.canvasDom;\n    Util.each([].concat(methodName), aMethod => {\n      if (action === 'bind') {\n        Util.addEventListener(canvasDom, aMethod, method);\n      } else {\n        Util.removeEventListener(canvasDom, aMethod, method);\n      }\n    });\n  }\n\n  bindEvents() {\n    const cfg = this._tooltipCfg;\n    const canvasElement = this.canvasDom;\n    const { triggerOn, triggerOff, alwaysShow } = cfg;\n    const showMethod = Util.wrapBehavior(this, 'handleShowEvent');\n    const hideMethod = Util.wrapBehavior(this, 'handleHideEvent');\n\n    triggerOn && this._handleEvent(triggerOn, showMethod, 'bind');\n    triggerOff && this._handleEvent(triggerOff, hideMethod, 'bind');\n    // 如果 !alwaysShow, 则在手势离开后就隐藏\n    if (!alwaysShow && !triggerOff) {\n      Util.addEventListener(canvasElement, 'touchend', hideMethod);\n    }\n  }\n\n  unBindEvents() {\n    const cfg = this._tooltipCfg;\n    const canvasElement = this.canvasDom;\n    const { triggerOn, triggerOff, alwaysShow } = cfg;\n    const showMethod = Util.getWrapBehavior(this, 'handleShowEvent');\n    const hideMethod = Util.getWrapBehavior(this, 'handleHideEvent');\n\n    triggerOn && this._handleEvent(triggerOn, showMethod, 'unBind');\n    triggerOff && this._handleEvent(triggerOff, hideMethod, 'unBind');\n\n    if (!alwaysShow) {\n      const docMethod = Util.getWrapBehavior(this, 'handleDocEvent');\n      Util.removeEventListener(canvasElement, 'touchend', docMethod);\n    }\n  }\n}\n\nmodule.exports = {\n  init(chart) {\n    const tooltipController = new TooltipController({\n      chart\n    });\n    chart.set('tooltipController', tooltipController);\n\n    chart.tooltip = function(enable, cfg) {\n      if (Util.isObject(enable)) {\n        cfg = enable;\n        enable = true;\n      }\n      tooltipController.enable = enable;\n      if (cfg) {\n        tooltipController.cfg = cfg;\n      }\n      return this;\n    };\n  },\n  afterGeomDraw(chart) {\n    const tooltipController = chart.get('tooltipController');\n    tooltipController.render();\n\n    chart.showTooltip = function(point) {\n      tooltipController.showTooltip(point);\n      return this;\n    };\n\n    chart.hideTooltip = function() {\n      tooltipController.hideTooltip();\n      return this;\n    };\n  },\n  clearInner(chart) {\n    const tooltipController = chart.get('tooltipController');\n    tooltipController.clear();\n  }\n};\n"]},"metadata":{},"sourceType":"script"}