{"ast":null,"code":"import { isArray, isNil, each } from '@antv/util';\n\nfunction merge(dataArray) {\n  let rst = [];\n\n  for (let i = 0, len = dataArray.length; i < len; i++) {\n    rst = rst.concat(dataArray[i]);\n  }\n\n  return rst;\n}\n\nfunction values(data, name) {\n  const rst = [];\n  const tmpMap = {};\n\n  for (let i = 0, len = data.length; i < len; i++) {\n    const obj = data[i];\n    const value = obj[name];\n\n    if (!isNil(value)) {\n      if (!isArray(value)) {\n        if (!tmpMap[value]) {\n          rst.push(value);\n          tmpMap[value] = true;\n        }\n      } else {\n        each(value, val => {\n          if (!tmpMap[val]) {\n            rst.push(val);\n            tmpMap[val] = true;\n          }\n        });\n      }\n    }\n  }\n\n  return rst;\n}\n\nfunction firstValue(data, name) {\n  let rst = null;\n\n  for (let i = 0, len = data.length; i < len; i++) {\n    const obj = data[i];\n    const value = obj[name];\n\n    if (!isNil(value)) {\n      if (isArray(value)) {\n        rst = value[0];\n      } else {\n        rst = value;\n      }\n\n      break;\n    }\n  }\n\n  return rst;\n}\n\nfunction groupToMap(data, fields) {\n  if (!fields) {\n    return {\n      0: data\n    };\n  }\n\n  const callback = function (row) {\n    let unique = '_';\n\n    for (let i = 0, l = fields.length; i < l; i++) {\n      unique += row[fields[i]] && row[fields[i]].toString();\n    }\n\n    return unique;\n  };\n\n  const groups = {};\n\n  for (let i = 0, len = data.length; i < len; i++) {\n    const row = data[i];\n    const key = callback(row);\n\n    if (groups[key]) {\n      groups[key].push(row);\n    } else {\n      groups[key] = [row];\n    }\n  }\n\n  return groups;\n}\n\nfunction group(data, fields, appendConditions = {}) {\n  if (!fields) {\n    return [data];\n  }\n\n  const groups = groupToMap(data, fields);\n  const array = [];\n\n  if (fields.length === 1 && appendConditions[fields[0]]) {\n    const values = appendConditions[fields[0]];\n    each(values, value => {\n      value = '_' + value;\n      array.push(groups[value]);\n    });\n  } else {\n    for (const i in groups) {\n      array.push(groups[i]);\n    }\n  }\n\n  return array;\n}\n\nfunction remove(arr, obj) {\n  if (!arr) {\n    return;\n  }\n\n  const index = arr.indexOf(obj);\n\n  if (index !== -1) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction getRange(values) {\n  if (!values.length) {\n    return {\n      min: 0,\n      max: 0\n    };\n  }\n\n  const max = Math.max.apply(null, values);\n  const min = Math.min.apply(null, values);\n  return {\n    min,\n    max\n  };\n}\n\nexport { merge, values, firstValue, group, groupToMap, remove, getRange };","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/util/array.js"],"names":["isArray","isNil","each","merge","dataArray","rst","i","len","length","concat","values","data","name","tmpMap","obj","value","push","val","firstValue","groupToMap","fields","callback","row","unique","l","toString","groups","key","group","appendConditions","array","remove","arr","index","indexOf","splice","getRange","min","max","Math","apply"],"mappings":"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","sourcesContent":["import {\n  isArray,\n  isNil,\n  each\n} from '@antv/util';\n\nfunction merge(dataArray) {\n  let rst = [];\n  for (let i = 0, len = dataArray.length; i < len; i++) {\n    rst = rst.concat(dataArray[i]);\n  }\n  return rst;\n}\n\nfunction values(data, name) {\n  const rst = [];\n  const tmpMap = {};\n  for (let i = 0, len = data.length; i < len; i++) {\n    const obj = data[i];\n    const value = obj[name];\n    if (!isNil(value)) {\n      if (!isArray(value)) {\n        if (!tmpMap[value]) {\n          rst.push(value);\n          tmpMap[value] = true;\n        }\n      } else {\n        each(value, val => {\n          if (!tmpMap[val]) {\n            rst.push(val);\n            tmpMap[val] = true;\n          }\n        });\n      }\n    }\n  }\n  return rst;\n}\n\nfunction firstValue(data, name) {\n  let rst = null;\n  for (let i = 0, len = data.length; i < len; i++) {\n    const obj = data[i];\n    const value = obj[name];\n    if (!isNil(value)) {\n      if (isArray(value)) {\n        rst = value[0];\n      } else {\n        rst = value;\n      }\n      break;\n    }\n  }\n  return rst;\n}\n\nfunction groupToMap(data, fields) {\n  if (!fields) {\n    return {\n      0: data\n    };\n  }\n\n  const callback = function(row) {\n    let unique = '_';\n    for (let i = 0, l = fields.length; i < l; i++) {\n      unique += row[fields[i]] && row[fields[i]].toString();\n    }\n    return unique;\n  };\n\n  const groups = {};\n  for (let i = 0, len = data.length; i < len; i++) {\n    const row = data[i];\n    const key = callback(row);\n    if (groups[key]) {\n      groups[key].push(row);\n    } else {\n      groups[key] = [ row ];\n    }\n  }\n\n  return groups;\n}\n\nfunction group(data, fields, appendConditions = {}) {\n  if (!fields) {\n    return [ data ];\n  }\n  const groups = groupToMap(data, fields);\n  const array = [];\n  if (fields.length === 1 && appendConditions[fields[0]]) {\n    const values = appendConditions[fields[0]];\n    each(values, value => {\n      value = '_' + value;\n      array.push(groups[value]);\n    });\n  } else {\n    for (const i in groups) {\n      array.push(groups[i]);\n    }\n  }\n\n  return array;\n}\n\nfunction remove(arr, obj) {\n  if (!arr) {\n    return;\n  }\n  const index = arr.indexOf(obj);\n  if (index !== -1) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction getRange(values) {\n  if (!values.length) {\n    return {\n      min: 0,\n      max: 0\n    };\n  }\n  const max = Math.max.apply(null, values);\n  const min = Math.min.apply(null, values);\n  return {\n    min,\n    max\n  };\n}\n\nexport {\n  merge,\n  values,\n  firstValue,\n  group,\n  groupToMap,\n  remove,\n  getRange\n};\n"]},"metadata":{},"sourceType":"module"}