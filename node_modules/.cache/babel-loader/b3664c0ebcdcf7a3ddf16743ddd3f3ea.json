{"ast":null,"code":"const Util = require('../util/common');\n\nconst List = require('../component/list');\n\nconst Global = require('../global');\n\nconst LEGEND_GAP = 12;\nconst MARKER_SIZE = 3;\nconst DEFAULT_CFG = {\n  itemMarginBottom: 12,\n  itemGap: 10,\n  showTitle: false,\n  titleStyle: {\n    fontSize: 12,\n    fill: '#808080',\n    textAlign: 'start',\n    textBaseline: 'top'\n  },\n  nameStyle: {\n    fill: '#808080',\n    fontSize: 12,\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  valueStyle: {\n    fill: '#000000',\n    fontSize: 12,\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  unCheckStyle: {\n    fill: '#bfbfbf'\n  },\n  itemWidth: 'auto',\n  wordSpace: 6,\n  selectedMode: 'multiple' // 'multiple' or 'single'\n\n}; // Register the default configuration for Legend\n\nGlobal.legend = Util.deepMix({\n  common: DEFAULT_CFG,\n  // common legend configuration\n  right: Util.mix({\n    position: 'right',\n    layout: 'vertical'\n  }, DEFAULT_CFG),\n  left: Util.mix({\n    position: 'left',\n    layout: 'vertical'\n  }, DEFAULT_CFG),\n  top: Util.mix({\n    position: 'top',\n    layout: 'horizontal'\n  }, DEFAULT_CFG),\n  bottom: Util.mix({\n    position: 'bottom',\n    layout: 'horizontal'\n  }, DEFAULT_CFG)\n}, Global.legend || {});\n\nfunction getPaddingByPos(pos, appendPadding) {\n  let padding = 0;\n  appendPadding = Util.parsePadding(appendPadding);\n\n  switch (pos) {\n    case 'top':\n      padding = appendPadding[0];\n      break;\n\n    case 'right':\n      padding = appendPadding[1];\n      break;\n\n    case 'bottom':\n      padding = appendPadding[2];\n      break;\n\n    case 'left':\n      padding = appendPadding[3];\n      break;\n\n    default:\n      break;\n  }\n\n  return padding;\n}\n\nclass LegendController {\n  constructor(cfg) {\n    this.legendCfg = {};\n    this.enable = true;\n    this.position = 'top';\n    Util.mix(this, cfg);\n    const chart = this.chart;\n    this.canvasDom = chart.get('canvas').get('el');\n    this.clear();\n  }\n\n  addLegend(scale, items, filteredVals) {\n    const self = this;\n    const legendCfg = self.legendCfg;\n    const field = scale.field;\n    const fieldCfg = legendCfg[field];\n\n    if (fieldCfg === false) {\n      return null;\n    }\n\n    if (fieldCfg && fieldCfg.custom) {\n      self.addCustomLegend(field);\n    } else {\n      let position = legendCfg.position || self.position;\n\n      if (fieldCfg && fieldCfg.position) {\n        position = fieldCfg.position;\n      }\n\n      if (scale.isCategory) {\n        self._addCategoryLegend(scale, items, position, filteredVals);\n      }\n    }\n  }\n\n  addCustomLegend(field) {\n    const self = this;\n    let legendCfg = self.legendCfg;\n\n    if (field && legendCfg[field]) {\n      legendCfg = legendCfg[field];\n    }\n\n    const position = legendCfg.position || self.position;\n    const legends = self.legends;\n    legends[position] = legends[position] || [];\n    const items = legendCfg.items;\n\n    if (!items) {\n      return null;\n    }\n\n    const container = self.container;\n    Util.each(items, item => {\n      if (!Util.isPlainObject(item.marker)) {\n        item.marker = {\n          symbol: item.marker || 'circle',\n          fill: item.fill,\n          radius: MARKER_SIZE\n        };\n      } else {\n        item.marker.radius = item.marker.radius || MARKER_SIZE;\n      }\n\n      item.checked = Util.isNil(item.checked) ? true : item.checked;\n      item.name = item.name || item.value;\n    });\n    const legend = new List(Util.deepMix({}, Global.legend[position], legendCfg, {\n      maxLength: self._getMaxLength(position),\n      items,\n      parent: container\n    }));\n    legends[position].push(legend);\n  }\n\n  clear() {\n    const legends = this.legends;\n    Util.each(legends, legendItems => {\n      Util.each(legendItems, legend => {\n        legend.clear();\n      });\n    });\n    this.legends = {};\n    this.unBindEvents();\n  }\n\n  _isFiltered(scale, values, value) {\n    let rst = false;\n    Util.each(values, val => {\n      rst = rst || scale.getText(val) === scale.getText(value);\n\n      if (rst) {\n        return false;\n      }\n    });\n    return rst;\n  }\n\n  _getMaxLength(position) {\n    const chart = this.chart;\n    const appendPadding = Util.parsePadding(chart.get('appendPadding'));\n    return position === 'right' || position === 'left' ? chart.get('height') - (appendPadding[0] + appendPadding[2]) : chart.get('width') - (appendPadding[1] + appendPadding[3]);\n  }\n\n  _addCategoryLegend(scale, items, position, filteredVals) {\n    const self = this;\n    const {\n      legendCfg,\n      legends,\n      container,\n      chart\n    } = self;\n    const field = scale.field;\n    legends[position] = legends[position] || [];\n    let symbol = 'circle';\n\n    if (legendCfg[field] && legendCfg[field].marker) {\n      symbol = legendCfg[field].marker;\n    } else if (legendCfg.marker) {\n      symbol = legendCfg.marker;\n    }\n\n    Util.each(items, item => {\n      if (Util.isPlainObject(symbol)) {\n        Util.mix(item.marker, symbol);\n      } else {\n        item.marker.symbol = symbol;\n      }\n\n      if (filteredVals) {\n        item.checked = !self._isFiltered(scale, filteredVals, item.dataValue);\n      }\n    });\n    const legendItems = chart.get('legendItems');\n    legendItems[field] = items;\n    const lastCfg = Util.deepMix({}, Global.legend[position], legendCfg[field] || legendCfg, {\n      maxLength: self._getMaxLength(position),\n      items,\n      field,\n      filteredVals,\n      parent: container\n    });\n\n    if (lastCfg.showTitle) {\n      Util.deepMix(lastCfg, {\n        title: scale.alias || scale.field\n      });\n    }\n\n    const legend = new List(lastCfg);\n    legends[position].push(legend);\n    return legend;\n  }\n\n  _alignLegend(legend, pre, position) {\n    const self = this;\n    const {\n      tl,\n      bl\n    } = self.plotRange;\n    const chart = self.chart;\n    let offsetX = legend.offsetX || 0;\n    let offsetY = legend.offsetY || 0;\n    const chartWidth = chart.get('width');\n    const chartHeight = chart.get('height');\n    const appendPadding = Util.parsePadding(chart.get('appendPadding'));\n    const legendHeight = legend.getHeight();\n    const legendWidth = legend.getWidth();\n    let x = 0;\n    let y = 0;\n\n    if (position === 'left' || position === 'right') {\n      const verticalAlign = legend.verticalAlign || 'middle';\n      const height = Math.abs(tl.y - bl.y);\n      x = position === 'left' ? appendPadding[3] : chartWidth - legendWidth - appendPadding[1];\n      y = (height - legendHeight) / 2 + tl.y;\n\n      if (verticalAlign === 'top') {\n        y = tl.y;\n      } else if (verticalAlign === 'bottom') {\n        y = bl.y - legendHeight;\n      }\n\n      if (pre) {\n        y = pre.get('y') - legendHeight - LEGEND_GAP;\n      }\n    } else {\n      const align = legend.align || 'left';\n      x = appendPadding[3];\n\n      if (align === 'center') {\n        x = chartWidth / 2 - legendWidth / 2;\n      } else if (align === 'right') {\n        x = chartWidth - (legendWidth + appendPadding[1]);\n      }\n\n      y = position === 'top' ? appendPadding[0] + Math.abs(legend.container.getBBox().minY) : chartHeight - legendHeight;\n\n      if (pre) {\n        const preWidth = pre.getWidth();\n        x = pre.x + preWidth + LEGEND_GAP;\n      }\n    }\n\n    if (position === 'bottom' && offsetY > 0) {\n      offsetY = 0;\n    }\n\n    if (position === 'right' && offsetX > 0) {\n      offsetX = 0;\n    }\n\n    legend.moveTo(x + offsetX, y + offsetY);\n  }\n\n  alignLegends() {\n    const self = this;\n    const legends = self.legends;\n    Util.each(legends, (legendItems, position) => {\n      Util.each(legendItems, (legend, index) => {\n        const pre = legendItems[index - 1];\n\n        self._alignLegend(legend, pre, position);\n      });\n    });\n    return self;\n  }\n\n  handleEvent(ev) {\n    const self = this;\n\n    function findItem(x, y) {\n      let result = null;\n      const legends = self.legends;\n      Util.each(legends, legendItems => {\n        Util.each(legendItems, legend => {\n          const {\n            itemsGroup,\n            legendHitBoxes\n          } = legend;\n          const children = itemsGroup.get('children');\n\n          if (children.length) {\n            const legendPosX = legend.x;\n            const legendPosY = legend.y;\n            Util.each(legendHitBoxes, (box, index) => {\n              if (x >= box.x + legendPosX && x <= box.x + box.width + legendPosX && y >= box.y + legendPosY && y <= box.height + box.y + legendPosY) {\n                // inbox\n                result = {\n                  clickedItem: children[index],\n                  clickedLegend: legend\n                };\n                return false;\n              }\n            });\n          }\n        });\n      });\n      return result;\n    }\n\n    const chart = self.chart;\n    const {\n      x,\n      y\n    } = Util.createEvent(ev, chart);\n    const clicked = findItem(x, y);\n\n    if (clicked && clicked.clickedLegend.clickable !== false) {\n      const {\n        clickedItem,\n        clickedLegend\n      } = clicked;\n\n      if (clickedLegend.onClick) {\n        ev.clickedItem = clickedItem;\n        clickedLegend.onClick(ev);\n      } else if (!clickedLegend.custom) {\n        const checked = clickedItem.get('checked');\n        const value = clickedItem.get('dataValue');\n        const {\n          filteredVals,\n          field,\n          selectedMode\n        } = clickedLegend;\n        const isSingeSelected = selectedMode === 'single';\n\n        if (isSingeSelected) {\n          chart.filter(field, val => {\n            return val === value;\n          });\n        } else {\n          if (checked) {\n            filteredVals.push(value);\n          } else {\n            Util.Array.remove(filteredVals, value);\n          }\n\n          chart.filter(field, val => {\n            return filteredVals.indexOf(val) === -1;\n          });\n        }\n\n        chart.repaint();\n      }\n    }\n  }\n\n  bindEvents() {\n    const legendCfg = this.legendCfg;\n    const triggerOn = legendCfg.triggerOn || 'touchstart';\n    const method = Util.wrapBehavior(this, 'handleEvent');\n    Util.addEventListener(this.canvasDom, triggerOn, method);\n  }\n\n  unBindEvents() {\n    const legendCfg = this.legendCfg;\n    const triggerOn = legendCfg.triggerOn || 'touchstart';\n    const method = Util.getWrapBehavior(this, 'handleEvent');\n    Util.removeEventListener(this.canvasDom, triggerOn, method);\n  }\n\n}\n\nmodule.exports = {\n  init(chart) {\n    const legendController = new LegendController({\n      container: chart.get('backPlot'),\n      plotRange: chart.get('plotRange'),\n      chart\n    });\n    chart.set('legendController', legendController);\n\n    chart.legend = function (field, cfg) {\n      let legendCfg = legendController.legendCfg;\n      legendController.enable = true;\n\n      if (Util.isBoolean(field)) {\n        legendController.enable = field;\n        legendCfg = cfg || {};\n      } else if (Util.isObject(field)) {\n        legendCfg = field;\n      } else {\n        legendCfg[field] = cfg;\n      }\n\n      legendController.legendCfg = legendCfg;\n      return this;\n    };\n  },\n\n  beforeGeomDraw(chart) {\n    const legendController = chart.get('legendController');\n    if (!legendController.enable) return null; // legend is not displayed\n\n    const legendCfg = legendController.legendCfg;\n\n    if (legendCfg && legendCfg.custom) {\n      legendController.addCustomLegend();\n    } else {\n      const legendItems = chart.getLegendItems();\n      const scales = chart.get('scales');\n      const filters = chart.get('filters');\n      Util.each(legendItems, (items, field) => {\n        const scale = scales[field];\n        const values = scale.values;\n        let filteredVals;\n\n        if (filters && filters[field]) {\n          filteredVals = values.filter(v => !filters[field](v));\n        } else {\n          filteredVals = [];\n        }\n\n        legendController.addLegend(scale, items, filteredVals);\n      });\n    }\n\n    if (legendCfg && legendCfg.clickable !== false) {\n      legendController.bindEvents();\n    }\n\n    const legends = legendController.legends;\n    const legendRange = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n    Util.each(legends, (legendItems, position) => {\n      let padding = 0;\n      Util.each(legendItems, legend => {\n        const width = legend.getWidth();\n        const height = legend.getHeight();\n\n        if (position === 'top' || position === 'bottom') {\n          padding = Math.max(padding, height);\n\n          if (legend.offsetY > 0) {\n            padding += legend.offsetY;\n          }\n        } else {\n          padding = Math.max(padding, width);\n\n          if (legend.offsetX > 0) {\n            padding += legend.offsetX;\n          }\n        }\n      });\n      legendRange[position] = padding + getPaddingByPos(position, chart.get('appendPadding'));\n    });\n    chart.set('legendRange', legendRange);\n  },\n\n  afterGeomDraw(chart) {\n    const legendController = chart.get('legendController');\n    legendController.alignLegends();\n  },\n\n  clearInner(chart) {\n    const legendController = chart.get('legendController');\n    legendController.clear();\n    chart.set('legendRange', null);\n  }\n\n};","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/plugin/legend.js"],"names":["Util","require","List","Global","LEGEND_GAP","MARKER_SIZE","DEFAULT_CFG","itemMarginBottom","itemGap","showTitle","titleStyle","fontSize","fill","textAlign","textBaseline","nameStyle","valueStyle","unCheckStyle","itemWidth","wordSpace","selectedMode","legend","deepMix","common","right","mix","position","layout","left","top","bottom","getPaddingByPos","pos","appendPadding","padding","parsePadding","LegendController","constructor","cfg","legendCfg","enable","chart","canvasDom","get","clear","addLegend","scale","items","filteredVals","self","field","fieldCfg","custom","addCustomLegend","isCategory","_addCategoryLegend","legends","container","each","item","isPlainObject","marker","symbol","radius","checked","isNil","name","value","maxLength","_getMaxLength","parent","push","legendItems","unBindEvents","_isFiltered","values","rst","val","getText","dataValue","lastCfg","title","alias","_alignLegend","pre","tl","bl","plotRange","offsetX","offsetY","chartWidth","chartHeight","legendHeight","getHeight","legendWidth","getWidth","x","y","verticalAlign","height","Math","abs","align","getBBox","minY","preWidth","moveTo","alignLegends","index","handleEvent","ev","findItem","result","itemsGroup","legendHitBoxes","children","length","legendPosX","legendPosY","box","width","clickedItem","clickedLegend","createEvent","clicked","clickable","onClick","isSingeSelected","filter","Array","remove","indexOf","repaint","bindEvents","triggerOn","method","wrapBehavior","addEventListener","getWrapBehavior","removeEventListener","module","exports","init","legendController","set","isBoolean","isObject","beforeGeomDraw","getLegendItems","scales","filters","v","legendRange","max","afterGeomDraw","clearInner"],"mappings":"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","sourcesContent":["const Util = require('../util/common');\nconst List = require('../component/list');\nconst Global = require('../global');\nconst LEGEND_GAP = 12;\nconst MARKER_SIZE = 3;\n\nconst DEFAULT_CFG = {\n  itemMarginBottom: 12,\n  itemGap: 10,\n  showTitle: false,\n  titleStyle: {\n    fontSize: 12,\n    fill: '#808080',\n    textAlign: 'start',\n    textBaseline: 'top'\n  },\n  nameStyle: {\n    fill: '#808080',\n    fontSize: 12,\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  valueStyle: {\n    fill: '#000000',\n    fontSize: 12,\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  unCheckStyle: {\n    fill: '#bfbfbf'\n  },\n  itemWidth: 'auto',\n  wordSpace: 6,\n  selectedMode: 'multiple' // 'multiple' or 'single'\n};\n\n\n// Register the default configuration for Legend\nGlobal.legend = Util.deepMix({\n  common: DEFAULT_CFG, // common legend configuration\n  right: Util.mix({\n    position: 'right',\n    layout: 'vertical'\n  }, DEFAULT_CFG),\n  left: Util.mix({\n    position: 'left',\n    layout: 'vertical'\n  }, DEFAULT_CFG),\n  top: Util.mix({\n    position: 'top',\n    layout: 'horizontal'\n  }, DEFAULT_CFG),\n  bottom: Util.mix({\n    position: 'bottom',\n    layout: 'horizontal'\n  }, DEFAULT_CFG)\n}, Global.legend || {});\n\nfunction getPaddingByPos(pos, appendPadding) {\n  let padding = 0;\n  appendPadding = Util.parsePadding(appendPadding);\n  switch (pos) {\n    case 'top':\n      padding = appendPadding[0];\n      break;\n    case 'right':\n      padding = appendPadding[1];\n      break;\n    case 'bottom':\n      padding = appendPadding[2];\n      break;\n    case 'left':\n      padding = appendPadding[3];\n      break;\n    default:\n      break;\n  }\n\n  return padding;\n}\n\nclass LegendController {\n  constructor(cfg) {\n    this.legendCfg = {};\n    this.enable = true;\n    this.position = 'top';\n    Util.mix(this, cfg);\n    const chart = this.chart;\n    this.canvasDom = chart.get('canvas').get('el');\n    this.clear();\n  }\n\n  addLegend(scale, items, filteredVals) {\n    const self = this;\n    const legendCfg = self.legendCfg;\n    const field = scale.field;\n    const fieldCfg = legendCfg[field];\n\n    if (fieldCfg === false) {\n      return null;\n    }\n\n    if (fieldCfg && fieldCfg.custom) {\n      self.addCustomLegend(field);\n    } else {\n      let position = legendCfg.position || self.position;\n      if (fieldCfg && fieldCfg.position) {\n        position = fieldCfg.position;\n      }\n      if (scale.isCategory) {\n        self._addCategoryLegend(scale, items, position, filteredVals);\n      }\n    }\n  }\n\n  addCustomLegend(field) {\n    const self = this;\n\n    let legendCfg = self.legendCfg;\n    if (field && legendCfg[field]) {\n      legendCfg = legendCfg[field];\n    }\n\n    const position = legendCfg.position || self.position;\n    const legends = self.legends;\n    legends[position] = legends[position] || [];\n    const items = legendCfg.items;\n    if (!items) {\n      return null;\n    }\n\n    const container = self.container;\n    Util.each(items, item => {\n      if (!Util.isPlainObject(item.marker)) {\n        item.marker = {\n          symbol: item.marker || 'circle',\n          fill: item.fill,\n          radius: MARKER_SIZE\n        };\n      } else {\n        item.marker.radius = item.marker.radius || MARKER_SIZE;\n      }\n      item.checked = Util.isNil(item.checked) ? true : item.checked;\n      item.name = item.name || item.value;\n    });\n    const legend = new List(Util.deepMix({}, Global.legend[position], legendCfg, {\n      maxLength: self._getMaxLength(position),\n      items,\n      parent: container\n    }));\n    legends[position].push(legend);\n  }\n\n  clear() {\n    const legends = this.legends;\n    Util.each(legends, legendItems => {\n      Util.each(legendItems, legend => {\n        legend.clear();\n      });\n    });\n\n    this.legends = {};\n    this.unBindEvents();\n  }\n\n  _isFiltered(scale, values, value) {\n    let rst = false;\n    Util.each(values, val => {\n      rst = rst || scale.getText(val) === scale.getText(value);\n      if (rst) {\n        return false;\n      }\n    });\n    return rst;\n  }\n\n  _getMaxLength(position) {\n    const chart = this.chart;\n    const appendPadding = Util.parsePadding(chart.get('appendPadding'));\n\n    return (position === 'right' || position === 'left') ?\n      chart.get('height') - (appendPadding[0] + appendPadding[2]) :\n      chart.get('width') - (appendPadding[1] + appendPadding[3]);\n  }\n\n  _addCategoryLegend(scale, items, position, filteredVals) {\n    const self = this;\n    const { legendCfg, legends, container, chart } = self;\n    const field = scale.field;\n    legends[position] = legends[position] || [];\n\n    let symbol = 'circle';\n    if (legendCfg[field] && legendCfg[field].marker) {\n      symbol = legendCfg[field].marker;\n    } else if (legendCfg.marker) {\n      symbol = legendCfg.marker;\n    }\n\n    Util.each(items, item => {\n      if (Util.isPlainObject(symbol)) {\n        Util.mix(item.marker, symbol);\n      } else {\n        item.marker.symbol = symbol;\n      }\n\n      if (filteredVals) {\n        item.checked = !self._isFiltered(scale, filteredVals, item.dataValue);\n      }\n    });\n\n    const legendItems = chart.get('legendItems');\n    legendItems[field] = items;\n\n    const lastCfg = Util.deepMix({}, Global.legend[position], legendCfg[field] || legendCfg, {\n      maxLength: self._getMaxLength(position),\n      items,\n      field,\n      filteredVals,\n      parent: container\n    });\n    if (lastCfg.showTitle) {\n      Util.deepMix(lastCfg, {\n        title: scale.alias || scale.field\n      });\n    }\n\n    const legend = new List(lastCfg);\n    legends[position].push(legend);\n    return legend;\n  }\n\n  _alignLegend(legend, pre, position) {\n    const self = this;\n    const { tl, bl } = self.plotRange;\n    const chart = self.chart;\n    let offsetX = legend.offsetX || 0;\n    let offsetY = legend.offsetY || 0;\n    const chartWidth = chart.get('width');\n    const chartHeight = chart.get('height');\n    const appendPadding = Util.parsePadding(chart.get('appendPadding'));\n    const legendHeight = legend.getHeight();\n    const legendWidth = legend.getWidth();\n\n    let x = 0;\n    let y = 0;\n    if (position === 'left' || position === 'right') {\n      const verticalAlign = legend.verticalAlign || 'middle';\n      const height = Math.abs(tl.y - bl.y);\n      x = (position === 'left') ? appendPadding[3] : (chartWidth - legendWidth - appendPadding[1]);\n      y = (height - legendHeight) / 2 + tl.y;\n      if (verticalAlign === 'top') {\n        y = tl.y;\n      } else if (verticalAlign === 'bottom') {\n        y = bl.y - legendHeight;\n      }\n\n      if (pre) {\n        y = pre.get('y') - legendHeight - LEGEND_GAP;\n      }\n    } else {\n      const align = legend.align || 'left';\n      x = appendPadding[3];\n\n      if (align === 'center') {\n        x = chartWidth / 2 - legendWidth / 2;\n      } else if (align === 'right') {\n        x = chartWidth - (legendWidth + appendPadding[1]);\n      }\n      y = (position === 'top') ? appendPadding[0] + Math.abs(legend.container.getBBox().minY) : (chartHeight - legendHeight);\n      if (pre) {\n        const preWidth = pre.getWidth();\n        x = pre.x + preWidth + LEGEND_GAP;\n      }\n    }\n    if (position === 'bottom' && offsetY > 0) {\n      offsetY = 0;\n    }\n    if (position === 'right' && offsetX > 0) {\n      offsetX = 0;\n    }\n    legend.moveTo(x + offsetX, y + offsetY);\n  }\n\n  alignLegends() {\n    const self = this;\n    const legends = self.legends;\n    Util.each(legends, (legendItems, position) => {\n      Util.each(legendItems, (legend, index) => {\n        const pre = legendItems[index - 1];\n        self._alignLegend(legend, pre, position);\n      });\n    });\n\n    return self;\n  }\n\n  handleEvent(ev) {\n    const self = this;\n\n    function findItem(x, y) {\n      let result = null;\n      const legends = self.legends;\n      Util.each(legends, legendItems => {\n        Util.each(legendItems, legend => {\n          const { itemsGroup, legendHitBoxes } = legend;\n          const children = itemsGroup.get('children');\n          if (children.length) {\n            const legendPosX = legend.x;\n            const legendPosY = legend.y;\n            Util.each(legendHitBoxes, (box, index) => {\n              if (x >= (box.x + legendPosX) && x <= (box.x + box.width + legendPosX) && y >= (box.y + legendPosY) && y <= (box.height + box.y + legendPosY)) { // inbox\n                result = {\n                  clickedItem: children[index],\n                  clickedLegend: legend\n                };\n                return false;\n              }\n            });\n          }\n        });\n      });\n      return result;\n    }\n\n    const chart = self.chart;\n    const { x, y } = Util.createEvent(ev, chart);\n    const clicked = findItem(x, y);\n    if (clicked && clicked.clickedLegend.clickable !== false) {\n      const { clickedItem, clickedLegend } = clicked;\n      if (clickedLegend.onClick) {\n        ev.clickedItem = clickedItem;\n        clickedLegend.onClick(ev);\n      } else if (!clickedLegend.custom) {\n        const checked = clickedItem.get('checked');\n        const value = clickedItem.get('dataValue');\n        const { filteredVals, field, selectedMode } = clickedLegend;\n        const isSingeSelected = selectedMode === 'single';\n\n        if (isSingeSelected) {\n          chart.filter(field, val => {\n            return val === value;\n          });\n        } else {\n          if (checked) {\n            filteredVals.push(value);\n          } else {\n            Util.Array.remove(filteredVals, value);\n          }\n\n          chart.filter(field, val => {\n            return filteredVals.indexOf(val) === -1;\n          });\n        }\n\n        chart.repaint();\n      }\n    }\n  }\n\n  bindEvents() {\n    const legendCfg = this.legendCfg;\n    const triggerOn = legendCfg.triggerOn || 'touchstart';\n    const method = Util.wrapBehavior(this, 'handleEvent');\n    Util.addEventListener(this.canvasDom, triggerOn, method);\n  }\n\n  unBindEvents() {\n    const legendCfg = this.legendCfg;\n    const triggerOn = legendCfg.triggerOn || 'touchstart';\n    const method = Util.getWrapBehavior(this, 'handleEvent');\n    Util.removeEventListener(this.canvasDom, triggerOn, method);\n  }\n}\nmodule.exports = {\n  init(chart) {\n    const legendController = new LegendController({\n      container: chart.get('backPlot'),\n      plotRange: chart.get('plotRange'),\n      chart\n    });\n    chart.set('legendController', legendController);\n\n    chart.legend = function(field, cfg) {\n      let legendCfg = legendController.legendCfg;\n      legendController.enable = true;\n\n      if (Util.isBoolean(field)) {\n        legendController.enable = field;\n        legendCfg = cfg || {};\n      } else if (Util.isObject(field)) {\n        legendCfg = field;\n      } else {\n        legendCfg[field] = cfg;\n      }\n\n      legendController.legendCfg = legendCfg;\n\n      return this;\n    };\n  },\n  beforeGeomDraw(chart) {\n    const legendController = chart.get('legendController');\n    if (!legendController.enable) return null; // legend is not displayed\n\n    const legendCfg = legendController.legendCfg;\n\n    if (legendCfg && legendCfg.custom) {\n      legendController.addCustomLegend();\n    } else {\n      const legendItems = chart.getLegendItems();\n      const scales = chart.get('scales');\n      const filters = chart.get('filters');\n      Util.each(legendItems, (items, field) => {\n        const scale = scales[field];\n        const values = scale.values;\n        let filteredVals;\n        if (filters && filters[field]) {\n          filteredVals = values.filter(v => !filters[field](v));\n        } else {\n          filteredVals = [];\n        }\n        legendController.addLegend(scale, items, filteredVals);\n      });\n    }\n\n    if (legendCfg && legendCfg.clickable !== false) {\n      legendController.bindEvents();\n    }\n\n    const legends = legendController.legends;\n    const legendRange = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n    Util.each(legends, (legendItems, position) => {\n      let padding = 0;\n      Util.each(legendItems, legend => {\n        const width = legend.getWidth();\n        const height = legend.getHeight();\n        if (position === 'top' || position === 'bottom') {\n          padding = Math.max(padding, height);\n          if (legend.offsetY > 0) {\n            padding += legend.offsetY;\n          }\n        } else {\n          padding = Math.max(padding, width);\n          if (legend.offsetX > 0) {\n            padding += legend.offsetX;\n          }\n        }\n      });\n      legendRange[position] = padding + getPaddingByPos(position, chart.get('appendPadding'));\n    });\n    chart.set('legendRange', legendRange);\n  },\n  afterGeomDraw(chart) {\n    const legendController = chart.get('legendController');\n    legendController.alignLegends();\n  },\n  clearInner(chart) {\n    const legendController = chart.get('legendController');\n    legendController.clear();\n    chart.set('legendRange', null);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}