{"ast":null,"code":"const Base = require('./base');\n\nconst Vector2 = require('../graphic/util/vector2');\n\nconst Matrix = require('../graphic/util/matrix');\n\nclass Polar extends Base {\n  _initDefaultCfg() {\n    this.type = 'polar';\n    this.startAngle = -Math.PI / 2;\n    this.endAngle = Math.PI * 3 / 2;\n    this.inner = 0;\n    this.innerRadius = 0; // alias\n\n    this.isPolar = true;\n    this.transposed = false;\n    this.center = null;\n    this.radius = null; // relative, 0 ~ 1\n  }\n\n  init(start, end) {\n    super.init(start, end);\n    const self = this;\n    const inner = self.inner || self.innerRadius;\n    const width = Math.abs(end.x - start.x);\n    const height = Math.abs(end.y - start.y);\n    let maxRadius;\n    let center;\n\n    if (self.startAngle === -Math.PI && self.endAngle === 0) {\n      maxRadius = Math.min(width / 2, height);\n      center = {\n        x: (start.x + end.x) / 2,\n        y: start.y\n      };\n    } else {\n      maxRadius = Math.min(width, height) / 2;\n      center = {\n        x: (start.x + end.x) / 2,\n        y: (start.y + end.y) / 2\n      };\n    }\n\n    const radius = self.radius;\n\n    if (radius > 0 && radius <= 1) {\n      maxRadius = maxRadius * radius;\n    }\n\n    this.x = {\n      start: self.startAngle,\n      end: self.endAngle\n    };\n    this.y = {\n      start: maxRadius * inner,\n      end: maxRadius\n    };\n    this.center = center;\n    this.circleRadius = maxRadius; // the radius value in px\n  }\n\n  _convertPoint(point) {\n    const self = this;\n    const center = self.center;\n    const transposed = self.transposed;\n    const xDim = transposed ? 'y' : 'x';\n    const yDim = transposed ? 'x' : 'y';\n    const x = self.x;\n    const y = self.y;\n    const angle = x.start + (x.end - x.start) * point[xDim];\n    const radius = y.start + (y.end - y.start) * point[yDim];\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  }\n\n  _invertPoint(point) {\n    const self = this;\n    const {\n      center,\n      transposed,\n      x,\n      y\n    } = self;\n    const xDim = transposed ? 'y' : 'x';\n    const yDim = transposed ? 'x' : 'y';\n    const m = [1, 0, 0, 1, 0, 0];\n    Matrix.rotate(m, m, x.start);\n    let startV = [1, 0];\n    Vector2.transformMat2d(startV, startV, m);\n    startV = [startV[0], startV[1]];\n    const pointV = [point.x - center.x, point.y - center.y];\n\n    if (Vector2.zero(pointV)) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n\n    let theta = Vector2.angleTo(startV, pointV, x.end < x.start);\n\n    if (Math.abs(theta - Math.PI * 2) < 0.001) {\n      theta = 0;\n    }\n\n    const l = Vector2.length(pointV);\n    let percentX = theta / (x.end - x.start);\n    percentX = x.end - x.start > 0 ? percentX : -percentX;\n    const percentY = (l - y.start) / (y.end - y.start);\n    const rst = {};\n    rst[xDim] = percentX;\n    rst[yDim] = percentY;\n    return rst;\n  }\n\n}\n\nBase.Polar = Polar;\nmodule.exports = Polar;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/coord/polar.js"],"names":["Base","require","Vector2","Matrix","Polar","_initDefaultCfg","type","startAngle","Math","PI","endAngle","inner","innerRadius","isPolar","transposed","center","radius","init","start","end","self","width","abs","x","height","y","maxRadius","min","circleRadius","_convertPoint","point","xDim","yDim","angle","cos","sin","_invertPoint","m","rotate","startV","transformMat2d","pointV","zero","theta","angleTo","l","length","percentX","percentY","rst","module","exports"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,yBAAD,CAAvB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,wBAAD,CAAtB;;AAEA,MAAMG,KAAN,SAAoBJ,IAApB,CAAyB;AACvBK,EAAAA,eAAe,GAAG;AAChB,SAAKC,IAAL,GAAY,OAAZ;AACA,SAAKC,UAAL,GAAkB,CAACC,IAAI,CAACC,EAAN,GAAW,CAA7B;AACA,SAAKC,QAAL,GAAgBF,IAAI,CAACC,EAAL,GAAU,CAAV,GAAc,CAA9B;AACA,SAAKE,KAAL,GAAa,CAAb;AACA,SAAKC,WAAL,GAAmB,CAAnB,CALgB,CAKM;;AACtB,SAAKC,OAAL,GAAe,IAAf;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,MAAL,GAAc,IAAd,CATgB,CASI;AACrB;;AAEDC,EAAAA,IAAI,CAACC,KAAD,EAAQC,GAAR,EAAa;AACf,UAAMF,IAAN,CAAWC,KAAX,EAAkBC,GAAlB;AACA,UAAMC,IAAI,GAAG,IAAb;AACA,UAAMT,KAAK,GAAGS,IAAI,CAACT,KAAL,IAAcS,IAAI,CAACR,WAAjC;AACA,UAAMS,KAAK,GAAGb,IAAI,CAACc,GAAL,CAASH,GAAG,CAACI,CAAJ,GAAQL,KAAK,CAACK,CAAvB,CAAd;AACA,UAAMC,MAAM,GAAGhB,IAAI,CAACc,GAAL,CAASH,GAAG,CAACM,CAAJ,GAAQP,KAAK,CAACO,CAAvB,CAAf;AAEA,QAAIC,SAAJ;AACA,QAAIX,MAAJ;;AACA,QAAIK,IAAI,CAACb,UAAL,KAAoB,CAACC,IAAI,CAACC,EAA1B,IAAgCW,IAAI,CAACV,QAAL,KAAkB,CAAtD,EAAyD;AACvDgB,MAAAA,SAAS,GAAGlB,IAAI,CAACmB,GAAL,CAASN,KAAK,GAAG,CAAjB,EAAoBG,MAApB,CAAZ;AACAT,MAAAA,MAAM,GAAG;AACPQ,QAAAA,CAAC,EAAE,CAACL,KAAK,CAACK,CAAN,GAAUJ,GAAG,CAACI,CAAf,IAAoB,CADhB;AAEPE,QAAAA,CAAC,EAAEP,KAAK,CAACO;AAFF,OAAT;AAID,KAND,MAMO;AACLC,MAAAA,SAAS,GAAGlB,IAAI,CAACmB,GAAL,CAASN,KAAT,EAAgBG,MAAhB,IAA0B,CAAtC;AACAT,MAAAA,MAAM,GAAG;AACPQ,QAAAA,CAAC,EAAE,CAACL,KAAK,CAACK,CAAN,GAAUJ,GAAG,CAACI,CAAf,IAAoB,CADhB;AAEPE,QAAAA,CAAC,EAAE,CAACP,KAAK,CAACO,CAAN,GAAUN,GAAG,CAACM,CAAf,IAAoB;AAFhB,OAAT;AAID;;AAED,UAAMT,MAAM,GAAGI,IAAI,CAACJ,MAApB;;AACA,QAAIA,MAAM,GAAG,CAAT,IAAcA,MAAM,IAAI,CAA5B,EAA+B;AAC7BU,MAAAA,SAAS,GAAGA,SAAS,GAAGV,MAAxB;AACD;;AAED,SAAKO,CAAL,GAAS;AACPL,MAAAA,KAAK,EAAEE,IAAI,CAACb,UADL;AAEPY,MAAAA,GAAG,EAAEC,IAAI,CAACV;AAFH,KAAT;AAKA,SAAKe,CAAL,GAAS;AACPP,MAAAA,KAAK,EAAEQ,SAAS,GAAGf,KADZ;AAEPQ,MAAAA,GAAG,EAAEO;AAFE,KAAT;AAIA,SAAKX,MAAL,GAAcA,MAAd;AACA,SAAKa,YAAL,GAAoBF,SAApB,CAtCe,CAsCgB;AAChC;;AAEDG,EAAAA,aAAa,CAACC,KAAD,EAAQ;AACnB,UAAMV,IAAI,GAAG,IAAb;AACA,UAAML,MAAM,GAAGK,IAAI,CAACL,MAApB;AACA,UAAMD,UAAU,GAAGM,IAAI,CAACN,UAAxB;AACA,UAAMiB,IAAI,GAAGjB,UAAU,GAAG,GAAH,GAAS,GAAhC;AACA,UAAMkB,IAAI,GAAGlB,UAAU,GAAG,GAAH,GAAS,GAAhC;AAEA,UAAMS,CAAC,GAAGH,IAAI,CAACG,CAAf;AACA,UAAME,CAAC,GAAGL,IAAI,CAACK,CAAf;AAEA,UAAMQ,KAAK,GAAGV,CAAC,CAACL,KAAF,GAAU,CAACK,CAAC,CAACJ,GAAF,GAAQI,CAAC,CAACL,KAAX,IAAoBY,KAAK,CAACC,IAAD,CAAjD;AACA,UAAMf,MAAM,GAAGS,CAAC,CAACP,KAAF,GAAU,CAACO,CAAC,CAACN,GAAF,GAAQM,CAAC,CAACP,KAAX,IAAoBY,KAAK,CAACE,IAAD,CAAlD;AAEA,WAAO;AACLT,MAAAA,CAAC,EAAER,MAAM,CAACQ,CAAP,GAAWf,IAAI,CAAC0B,GAAL,CAASD,KAAT,IAAkBjB,MAD3B;AAELS,MAAAA,CAAC,EAAEV,MAAM,CAACU,CAAP,GAAWjB,IAAI,CAAC2B,GAAL,CAASF,KAAT,IAAkBjB;AAF3B,KAAP;AAID;;AAEDoB,EAAAA,YAAY,CAACN,KAAD,EAAQ;AAClB,UAAMV,IAAI,GAAG,IAAb;AACA,UAAM;AAAEL,MAAAA,MAAF;AAAUD,MAAAA,UAAV;AAAsBS,MAAAA,CAAtB;AAAyBE,MAAAA;AAAzB,QAA+BL,IAArC;AACA,UAAMW,IAAI,GAAGjB,UAAU,GAAG,GAAH,GAAS,GAAhC;AACA,UAAMkB,IAAI,GAAGlB,UAAU,GAAG,GAAH,GAAS,GAAhC;AAEA,UAAMuB,CAAC,GAAG,CAAE,CAAF,EAAK,CAAL,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,CAAV;AACAlC,IAAAA,MAAM,CAACmC,MAAP,CAAcD,CAAd,EAAiBA,CAAjB,EAAoBd,CAAC,CAACL,KAAtB;AAEA,QAAIqB,MAAM,GAAG,CAAE,CAAF,EAAK,CAAL,CAAb;AACArC,IAAAA,OAAO,CAACsC,cAAR,CAAuBD,MAAvB,EAA+BA,MAA/B,EAAuCF,CAAvC;AACAE,IAAAA,MAAM,GAAG,CAAEA,MAAM,CAAC,CAAD,CAAR,EAAaA,MAAM,CAAC,CAAD,CAAnB,CAAT;AAEA,UAAME,MAAM,GAAG,CAAEX,KAAK,CAACP,CAAN,GAAUR,MAAM,CAACQ,CAAnB,EAAsBO,KAAK,CAACL,CAAN,GAAUV,MAAM,CAACU,CAAvC,CAAf;;AACA,QAAIvB,OAAO,CAACwC,IAAR,CAAaD,MAAb,CAAJ,EAA0B;AACxB,aAAO;AACLlB,QAAAA,CAAC,EAAE,CADE;AAELE,QAAAA,CAAC,EAAE;AAFE,OAAP;AAID;;AAED,QAAIkB,KAAK,GAAGzC,OAAO,CAAC0C,OAAR,CAAgBL,MAAhB,EAAwBE,MAAxB,EAAgClB,CAAC,CAACJ,GAAF,GAAQI,CAAC,CAACL,KAA1C,CAAZ;;AACA,QAAIV,IAAI,CAACc,GAAL,CAASqB,KAAK,GAAGnC,IAAI,CAACC,EAAL,GAAU,CAA3B,IAAgC,KAApC,EAA2C;AACzCkC,MAAAA,KAAK,GAAG,CAAR;AACD;;AACD,UAAME,CAAC,GAAG3C,OAAO,CAAC4C,MAAR,CAAeL,MAAf,CAAV;AACA,QAAIM,QAAQ,GAAGJ,KAAK,IAAIpB,CAAC,CAACJ,GAAF,GAAQI,CAAC,CAACL,KAAd,CAApB;AACA6B,IAAAA,QAAQ,GAAGxB,CAAC,CAACJ,GAAF,GAAQI,CAAC,CAACL,KAAV,GAAkB,CAAlB,GAAsB6B,QAAtB,GAAiC,CAACA,QAA7C;AACA,UAAMC,QAAQ,GAAG,CAACH,CAAC,GAAGpB,CAAC,CAACP,KAAP,KAAiBO,CAAC,CAACN,GAAF,GAAQM,CAAC,CAACP,KAA3B,CAAjB;AACA,UAAM+B,GAAG,GAAG,EAAZ;AACAA,IAAAA,GAAG,CAAClB,IAAD,CAAH,GAAYgB,QAAZ;AACAE,IAAAA,GAAG,CAACjB,IAAD,CAAH,GAAYgB,QAAZ;AACA,WAAOC,GAAP;AACD;;AA1GsB;;AA6GzBjD,IAAI,CAACI,KAAL,GAAaA,KAAb;AACA8C,MAAM,CAACC,OAAP,GAAiB/C,KAAjB","sourcesContent":["const Base = require('./base');\nconst Vector2 = require('../graphic/util/vector2');\nconst Matrix = require('../graphic/util/matrix');\n\nclass Polar extends Base {\n  _initDefaultCfg() {\n    this.type = 'polar';\n    this.startAngle = -Math.PI / 2;\n    this.endAngle = Math.PI * 3 / 2;\n    this.inner = 0;\n    this.innerRadius = 0; // alias\n    this.isPolar = true;\n    this.transposed = false;\n    this.center = null;\n    this.radius = null; // relative, 0 ~ 1\n  }\n\n  init(start, end) {\n    super.init(start, end);\n    const self = this;\n    const inner = self.inner || self.innerRadius;\n    const width = Math.abs(end.x - start.x);\n    const height = Math.abs(end.y - start.y);\n\n    let maxRadius;\n    let center;\n    if (self.startAngle === -Math.PI && self.endAngle === 0) {\n      maxRadius = Math.min(width / 2, height);\n      center = {\n        x: (start.x + end.x) / 2,\n        y: start.y\n      };\n    } else {\n      maxRadius = Math.min(width, height) / 2;\n      center = {\n        x: (start.x + end.x) / 2,\n        y: (start.y + end.y) / 2\n      };\n    }\n\n    const radius = self.radius;\n    if (radius > 0 && radius <= 1) {\n      maxRadius = maxRadius * radius;\n    }\n\n    this.x = {\n      start: self.startAngle,\n      end: self.endAngle\n    };\n\n    this.y = {\n      start: maxRadius * inner,\n      end: maxRadius\n    };\n    this.center = center;\n    this.circleRadius = maxRadius; // the radius value in px\n  }\n\n  _convertPoint(point) {\n    const self = this;\n    const center = self.center;\n    const transposed = self.transposed;\n    const xDim = transposed ? 'y' : 'x';\n    const yDim = transposed ? 'x' : 'y';\n\n    const x = self.x;\n    const y = self.y;\n\n    const angle = x.start + (x.end - x.start) * point[xDim];\n    const radius = y.start + (y.end - y.start) * point[yDim];\n\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  }\n\n  _invertPoint(point) {\n    const self = this;\n    const { center, transposed, x, y } = self;\n    const xDim = transposed ? 'y' : 'x';\n    const yDim = transposed ? 'x' : 'y';\n\n    const m = [ 1, 0, 0, 1, 0, 0 ];\n    Matrix.rotate(m, m, x.start);\n\n    let startV = [ 1, 0 ];\n    Vector2.transformMat2d(startV, startV, m);\n    startV = [ startV[0], startV[1] ];\n\n    const pointV = [ point.x - center.x, point.y - center.y ];\n    if (Vector2.zero(pointV)) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n\n    let theta = Vector2.angleTo(startV, pointV, x.end < x.start);\n    if (Math.abs(theta - Math.PI * 2) < 0.001) {\n      theta = 0;\n    }\n    const l = Vector2.length(pointV);\n    let percentX = theta / (x.end - x.start);\n    percentX = x.end - x.start > 0 ? percentX : -percentX;\n    const percentY = (l - y.start) / (y.end - y.start);\n    const rst = {};\n    rst[xDim] = percentX;\n    rst[yDim] = percentY;\n    return rst;\n  }\n}\n\nBase.Polar = Polar;\nmodule.exports = Polar;\n"]},"metadata":{},"sourceType":"script"}