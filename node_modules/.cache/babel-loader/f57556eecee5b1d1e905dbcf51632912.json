{"ast":null,"code":"const Util = require('../../util/common');\n\nconst Global = require('../../global');\n\nconst Scale = require('../../scale/');\n\nconst SCALE_TYPES_MAP = {\n  linear: 'Linear',\n  cat: 'Cat',\n  timeCat: 'TimeCat',\n  identity: 'Identity'\n};\n\nfunction isFullCircle(coord) {\n  if (!coord.isPolar) {\n    return false;\n  }\n\n  const startAngle = coord.startAngle;\n  const endAngle = coord.endAngle;\n\n  if (!Util.isNil(startAngle) && !Util.isNil(endAngle) && endAngle - startAngle < Math.PI * 2) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction clearObj(obj) {\n  Object.keys(obj).forEach(key => {\n    delete obj[key];\n  });\n}\n\nclass ScaleController {\n  constructor(cfg) {\n    // defs 列定义\n    this.defs = {}; // 已经实例化的scale\n\n    this.scales = {};\n    Util.mix(this, cfg);\n  }\n\n  setFieldDef(field, cfg) {\n    const {\n      defs\n    } = this;\n\n    if (Util.isObject(field)) {\n      Util.mix(defs, field);\n    } else {\n      defs[field] = cfg;\n    }\n\n    this.updateScales();\n  }\n\n  _getDef(field) {\n    const defs = this.defs;\n    let def = null;\n\n    if (Global.scales[field] || defs[field]) {\n      def = Util.mix({}, Global.scales[field]);\n      Util.each(defs[field], function (v, k) {\n        if (Util.isNil(v)) {\n          delete def[k];\n        } else {\n          def[k] = v;\n        }\n      });\n    }\n\n    return def;\n  }\n\n  _getDefaultType(field, data, def) {\n    if (def && def.type) {\n      return def.type;\n    }\n\n    let type = 'linear';\n    let value = Util.Array.firstValue(data, field);\n\n    if (Util.isArray(value)) {\n      value = value[0];\n    }\n\n    if (Util.isString(value)) {\n      type = 'cat';\n    }\n\n    return type;\n  }\n\n  _getScaleDef(type, field, data, def) {\n    let values;\n\n    if (def && def.values) {\n      values = def.values;\n    } else {\n      values = Util.Array.values(data, field);\n    }\n\n    const cfg = {\n      field,\n      values\n    };\n\n    if (type !== 'cat' && type !== 'timeCat') {\n      if (!def || !(def.min && def.max)) {\n        const {\n          min,\n          max\n        } = Util.Array.getRange(values);\n        cfg.min = min;\n        cfg.max = max;\n        cfg.nice = true;\n      }\n    } else {\n      cfg.isRounding = false; // used for tickCount calculation\n    }\n\n    return cfg;\n  } // 调整range，为了让图形居中\n\n\n  _adjustRange(type, cfg) {\n    const {\n      range,\n      values\n    } = cfg; // 如果是线性, 或者有自定义range都不处理\n\n    if (type === 'linear' || range || !values) {\n      return cfg;\n    }\n\n    const count = values.length; // 单只有一条数据时，在中间显示\n\n    if (count === 1) {\n      cfg.range = [0.5, 1];\n    } else {\n      const {\n        chart\n      } = this;\n      const coord = chart.get('coord');\n      const widthRatio = Global.widthRatio.multiplePie;\n      let offset = 0;\n\n      if (isFullCircle(coord)) {\n        if (!coord.transposed) {\n          cfg.range = [0, 1 - 1 / count];\n        } else {\n          offset = 1 / count * widthRatio;\n          cfg.range = [offset / 2, 1 - offset / 2];\n        }\n      } else {\n        // 为了让图形居中，所以才设置range\n        offset = 1 / count * 1 / 2;\n        cfg.range = [offset, 1 - offset];\n      }\n    }\n\n    return cfg;\n  }\n\n  _getScaleCfg(field, data) {\n    const self = this;\n\n    const def = self._getDef(field);\n\n    if (!data || !data.length) {\n      if (def && def.type) {\n        def.field = field;\n        return {\n          type: SCALE_TYPES_MAP[def.type],\n          cfg: def\n        };\n      }\n\n      return {\n        type: 'Identity',\n        cfg: {\n          value: field,\n          field: field.toString(),\n          values: [field]\n        }\n      };\n    }\n\n    const firstObj = data[0];\n    let firstValue = firstObj[field];\n\n    if (firstValue === null) {\n      firstValue = Util.Array.firstValue(data, field);\n    }\n\n    if (Util.isNumber(field) || Util.isNil(firstValue) && !def) {\n      return {\n        type: 'Identity',\n        cfg: {\n          value: field,\n          field: field.toString(),\n          values: [field]\n        }\n      };\n    }\n\n    const type = self._getDefaultType(field, data, def);\n\n    let cfg = self._getScaleDef(type, field, data, def);\n\n    def && Util.mix(cfg, def);\n    cfg = this._adjustRange(type, cfg);\n    return {\n      type: SCALE_TYPES_MAP[type],\n      cfg\n    };\n  }\n\n  createScale(field, data) {\n    const {\n      scales\n    } = this;\n\n    if (scales[field]) {\n      return scales[field];\n    }\n\n    const {\n      type,\n      cfg\n    } = this._getScaleCfg(field, data);\n\n    const scale = new Scale[type](cfg);\n    this.scales[field] = scale;\n    return scale;\n  }\n\n  _updateScale(scale) {\n    const {\n      field\n    } = scale;\n\n    const data = this.chart._getScaleData(field);\n\n    const {\n      cfg\n    } = this._getScaleCfg(field, data);\n\n    scale.change(cfg);\n  }\n\n  updateScales() {\n    const {\n      scales\n    } = this; // 修改完列定义后，需要更新已经实例化的scale\n    // 如果是还没有实例化的，在geom初始化的时候会被实例化，所以这里可以不用更新\n\n    Util.each(scales, scale => {\n      this._updateScale(scale);\n    });\n  } // 调整scale从0开始\n\n\n  adjustStartZero(scale) {\n    const {\n      defs\n    } = this;\n    const {\n      field,\n      min,\n      max\n    } = scale; // 如果有定义，则不处理\n\n    if (defs[field] && defs[field].min) {\n      return;\n    }\n\n    if (min > 0) {\n      scale.change({\n        min: 0\n      });\n    } else if (max < 0) {\n      scale.change({\n        max: 0\n      });\n    }\n  }\n\n  clear() {\n    // this.defs = {};\n    // this.scales = {};\n    clearObj(this.defs);\n    clearObj(this.scales);\n    this.data = null;\n  }\n\n}\n\nmodule.exports = ScaleController;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/chart/controller/scale.js"],"names":["Util","require","Global","Scale","SCALE_TYPES_MAP","linear","cat","timeCat","identity","isFullCircle","coord","isPolar","startAngle","endAngle","isNil","Math","PI","clearObj","obj","Object","keys","forEach","key","ScaleController","constructor","cfg","defs","scales","mix","setFieldDef","field","isObject","updateScales","_getDef","def","each","v","k","_getDefaultType","data","type","value","Array","firstValue","isArray","isString","_getScaleDef","values","min","max","getRange","nice","isRounding","_adjustRange","range","count","length","chart","get","widthRatio","multiplePie","offset","transposed","_getScaleCfg","self","toString","firstObj","isNumber","createScale","scale","_updateScale","_getScaleData","change","adjustStartZero","clear","module","exports"],"mappings":"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","sourcesContent":["const Util = require('../../util/common');\nconst Global = require('../../global');\nconst Scale = require('../../scale/');\nconst SCALE_TYPES_MAP = {\n  linear: 'Linear',\n  cat: 'Cat',\n  timeCat: 'TimeCat',\n  identity: 'Identity'\n};\n\nfunction isFullCircle(coord) {\n  if (!coord.isPolar) {\n    return false;\n  }\n  const startAngle = coord.startAngle;\n  const endAngle = coord.endAngle;\n  if (!Util.isNil(startAngle) && !Util.isNil(endAngle) && (endAngle - startAngle) < Math.PI * 2) {\n    return false;\n  }\n  return true;\n}\n\nfunction clearObj(obj) {\n  Object.keys(obj).forEach(key => {\n    delete obj[key];\n  });\n}\n\nclass ScaleController {\n  constructor(cfg) {\n    // defs 列定义\n    this.defs = {};\n    // 已经实例化的scale\n    this.scales = {};\n    Util.mix(this, cfg);\n  }\n\n  setFieldDef(field, cfg) {\n    const { defs } = this;\n    if (Util.isObject(field)) {\n      Util.mix(defs, field);\n    } else {\n      defs[field] = cfg;\n    }\n\n    this.updateScales();\n  }\n\n  _getDef(field) {\n    const defs = this.defs;\n    let def = null;\n    if (Global.scales[field] || defs[field]) {\n      def = Util.mix({}, Global.scales[field]);\n      Util.each(defs[field], function(v, k) {\n        if (Util.isNil(v)) {\n          delete def[k];\n        } else {\n          def[k] = v;\n        }\n      });\n    }\n    return def;\n  }\n\n  _getDefaultType(field, data, def) {\n    if (def && def.type) {\n      return def.type;\n    }\n    let type = 'linear';\n    let value = Util.Array.firstValue(data, field);\n    if (Util.isArray(value)) {\n      value = value[0];\n    }\n    if (Util.isString(value)) {\n      type = 'cat';\n    }\n    return type;\n  }\n\n  _getScaleDef(type, field, data, def) {\n    let values;\n    if (def && def.values) {\n      values = def.values;\n    } else {\n      values = Util.Array.values(data, field);\n    }\n    const cfg = {\n      field,\n      values\n    };\n\n    if (type !== 'cat' && type !== 'timeCat') {\n      if (!def || !(def.min && def.max)) {\n        const { min, max } = Util.Array.getRange(values);\n        cfg.min = min;\n        cfg.max = max;\n        cfg.nice = true;\n      }\n    } else {\n      cfg.isRounding = false; // used for tickCount calculation\n    }\n\n    return cfg;\n  }\n\n  // 调整range，为了让图形居中\n  _adjustRange(type, cfg) {\n    const { range, values } = cfg;\n    // 如果是线性, 或者有自定义range都不处理\n    if (type === 'linear' || range || !values) {\n      return cfg;\n    }\n    const count = values.length;\n    // 单只有一条数据时，在中间显示\n    if (count === 1) {\n      cfg.range = [ 0.5, 1 ];\n    } else {\n      const { chart } = this;\n      const coord = chart.get('coord');\n      const widthRatio = Global.widthRatio.multiplePie;\n      let offset = 0;\n      if (isFullCircle(coord)) {\n        if (!coord.transposed) {\n          cfg.range = [ 0, 1 - 1 / count ];\n        } else {\n          offset = 1 / count * widthRatio;\n          cfg.range = [ offset / 2, 1 - offset / 2 ];\n        }\n      } else {\n        // 为了让图形居中，所以才设置range\n        offset = 1 / count * 1 / 2;\n        cfg.range = [ offset, 1 - offset ];\n      }\n    }\n    return cfg;\n  }\n\n  _getScaleCfg(field, data) {\n    const self = this;\n    const def = self._getDef(field);\n    if (!data || !data.length) {\n      if (def && def.type) {\n        def.field = field;\n        return {\n          type: SCALE_TYPES_MAP[def.type],\n          cfg: def\n        };\n      }\n      return {\n        type: 'Identity',\n        cfg: {\n          value: field,\n          field: field.toString(),\n          values: [ field ]\n        }\n      };\n    }\n    const firstObj = data[0];\n    let firstValue = firstObj[field];\n    if (firstValue === null) {\n      firstValue = Util.Array.firstValue(data, field);\n    }\n\n    if (Util.isNumber(field) || (Util.isNil(firstValue)) && !def) {\n      return {\n        type: 'Identity',\n        cfg: {\n          value: field,\n          field: field.toString(),\n          values: [ field ]\n        }\n      };\n    }\n    const type = self._getDefaultType(field, data, def);\n    let cfg = self._getScaleDef(type, field, data, def);\n    def && Util.mix(cfg, def);\n    cfg = this._adjustRange(type, cfg);\n    return {\n      type: SCALE_TYPES_MAP[type],\n      cfg\n    };\n  }\n\n  createScale(field, data) {\n    const { scales } = this;\n    if (scales[field]) {\n      return scales[field];\n    }\n    const { type, cfg } = this._getScaleCfg(field, data);\n    const scale = new Scale[type](cfg);\n    this.scales[field] = scale;\n    return scale;\n  }\n\n  _updateScale(scale) {\n    const { field } = scale;\n    const data = this.chart._getScaleData(field);\n    const { cfg } = this._getScaleCfg(field, data);\n    scale.change(cfg);\n  }\n\n  updateScales() {\n    const { scales } = this;\n    // 修改完列定义后，需要更新已经实例化的scale\n    // 如果是还没有实例化的，在geom初始化的时候会被实例化，所以这里可以不用更新\n    Util.each(scales, scale => {\n      this._updateScale(scale);\n    });\n  }\n\n  // 调整scale从0开始\n  adjustStartZero(scale) {\n    const { defs } = this;\n    const { field, min, max } = scale;\n    // 如果有定义，则不处理\n    if (defs[field] && defs[field].min) {\n      return;\n    }\n    if (min > 0) {\n      scale.change({\n        min: 0\n      });\n    } else if (max < 0) {\n      scale.change({\n        max: 0\n      });\n    }\n  }\n\n  clear() {\n    // this.defs = {};\n    // this.scales = {};\n    clearObj(this.defs);\n    clearObj(this.scales);\n    this.data = null;\n  }\n}\n\nmodule.exports = ScaleController;\n"]},"metadata":{},"sourceType":"script"}