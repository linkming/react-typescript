{"ast":null,"code":"import * as Attr from '../attr/index';\n\nconst Util = require('../util/common');\n\nconst Base = require('../base');\n\nconst GROUP_ATTRS = ['color', 'size', 'shape'];\nconst FIELD_ORIGIN = '_origin';\nconst FIELD_ORIGIN_Y = '_originY';\n\nconst Global = require('../global');\n\nconst GeometryShape = require('./shape/shape');\n\nconst Adjust = require('@antv/adjust/lib/base');\n\nfunction parseFields(field) {\n  if (Util.isArray(field)) {\n    return field;\n  }\n\n  if (Util.isString(field)) {\n    return field.split('*');\n  }\n\n  return [field];\n}\n/**\n * The parent class for Geometry\n * @class Geom\n */\n\n\nclass Geom extends Base {\n  getDefaultCfg() {\n    return {\n      /**\n       * geometry type\n       * @type {String}\n       */\n      type: null,\n\n      /**\n       * the data of geometry\n       * @type {Array}\n       */\n      data: null,\n\n      /**\n       * the attrs of geo,etry\n       * @type {Object}\n       */\n      attrs: {},\n      scales: {},\n\n      /**\n       * group for storing the shapes\n       * @type {Canvas}\n       */\n      container: null,\n\n      /**\n       * style options\n       * @type {Object}\n       */\n      styleOptions: null,\n      chart: null,\n      shapeType: '',\n\n      /**\n       * wether to generate key points for each shape\n       * @protected\n       * @type {Boolean}\n       */\n      generatePoints: false,\n      attrOptions: {},\n      sortable: false,\n      startOnZero: true,\n      visible: true,\n      connectNulls: false,\n      // 是否丢弃没有值的分组。\n      ignoreEmptyGroup: false\n    };\n  }\n\n  init() {\n    const self = this;\n\n    self._initAttrs();\n\n    self._processData();\n  }\n\n  _getGroupScales() {\n    const self = this;\n    const scales = [];\n    Util.each(GROUP_ATTRS, function (attrName) {\n      const attr = self.getAttr(attrName);\n\n      if (attr) {\n        const attrScales = attr.scales;\n        Util.each(attrScales, function (scale) {\n          if (scale && scale.isCategory && scales.indexOf(scale) === -1) {\n            scales.push(scale);\n          }\n        });\n      }\n    });\n    return scales;\n  }\n\n  _groupData(data) {\n    const self = this;\n    const colDefs = self.get('colDefs');\n\n    const groupScales = self._getGroupScales();\n\n    if (groupScales.length) {\n      const appendConditions = {};\n      const names = [];\n      Util.each(groupScales, scale => {\n        const field = scale.field;\n        names.push(field);\n\n        if (colDefs && colDefs[field] && colDefs[field].values) {\n          // users have defined\n          appendConditions[scale.field] = colDefs[field].values;\n        }\n      });\n      return Util.Array.group(data, names, appendConditions);\n    }\n\n    return [data];\n  }\n\n  _setAttrOptions(attrName, attrCfg) {\n    const options = this.get('attrOptions');\n    options[attrName] = attrCfg;\n  }\n\n  _createAttrOption(attrName, field, cfg, defaultValues) {\n    const attrCfg = {};\n    attrCfg.field = field;\n\n    if (cfg) {\n      if (Util.isFunction(cfg)) {\n        attrCfg.callback = cfg;\n      } else {\n        attrCfg.values = cfg;\n      }\n    } else {\n      attrCfg.values = defaultValues;\n    }\n\n    this._setAttrOptions(attrName, attrCfg);\n  }\n\n  _initAttrs() {\n    const self = this;\n    const attrs = self.get('attrs');\n    const attrOptions = self.get('attrOptions');\n    const coord = self.get('coord');\n\n    for (const type in attrOptions) {\n      if (attrOptions.hasOwnProperty(type)) {\n        const option = attrOptions[type];\n        const className = Util.upperFirst(type);\n        const fields = parseFields(option.field);\n\n        if (type === 'position') {\n          option.coord = coord;\n        }\n\n        const scales = [];\n\n        for (let i = 0, len = fields.length; i < len; i++) {\n          const field = fields[i];\n\n          const scale = self._createScale(field);\n\n          scales.push(scale);\n        }\n\n        if (type === 'position') {\n          const yScale = scales[1]; // 饼图的处理，但是还不知道为啥\n\n          if (coord.type === 'polar' && coord.transposed && self.hasAdjust('stack')) {\n            if (yScale.values.length) {\n              yScale.change({\n                nice: false,\n                min: 0,\n                max: Math.max.apply(null, yScale.values)\n              });\n            }\n          }\n        }\n\n        option.scales = scales;\n        const attr = new Attr[className](option);\n        attrs[type] = attr;\n      }\n    }\n  }\n\n  _createScale(field) {\n    const scales = this.get('scales');\n    let scale = scales[field];\n\n    if (!scale) {\n      scale = this.get('chart').createScale(field);\n      scales[field] = scale;\n    }\n\n    return scale;\n  }\n\n  _processData() {\n    const self = this;\n    const data = this.get('data');\n    const dataArray = [];\n\n    let groupedArray = this._groupData(data);\n\n    if (this.get('ignoreEmptyGroup')) {\n      const yScale = this.getYScale();\n      groupedArray = groupedArray.filter(group => group.some(item => typeof item[yScale.field] !== 'undefined'));\n    }\n\n    for (let i = 0, len = groupedArray.length; i < len; i++) {\n      const subData = groupedArray[i];\n\n      const tempData = self._saveOrigin(subData);\n\n      if (this.hasAdjust('dodge')) {\n        self._numberic(tempData);\n      }\n\n      dataArray.push(tempData);\n    }\n\n    if (self.get('adjust')) {\n      self._adjustData(dataArray);\n    }\n\n    if (self.get('sortable')) {\n      self._sort(dataArray);\n    }\n\n    self.set('dataArray', dataArray);\n    return dataArray;\n  }\n\n  _saveOrigin(data) {\n    const rst = [];\n\n    for (let i = 0, len = data.length; i < len; i++) {\n      const origin = data[i];\n      const obj = {};\n\n      for (const k in origin) {\n        obj[k] = origin[k];\n      }\n\n      obj[FIELD_ORIGIN] = origin;\n      rst.push(obj);\n    }\n\n    return rst;\n  }\n\n  _numberic(data) {\n    const positionAttr = this.getAttr('position');\n    const scales = positionAttr.scales;\n\n    for (let j = 0, len = data.length; j < len; j++) {\n      const obj = data[j];\n      const count = Math.min(2, scales.length);\n\n      for (let i = 0; i < count; i++) {\n        const scale = scales[i];\n\n        if (scale.isCategory) {\n          const field = scale.field;\n          obj[field] = scale.translate(obj[field]);\n        }\n      }\n    }\n  }\n\n  _adjustData(dataArray) {\n    const self = this;\n    const adjust = self.get('adjust');\n\n    if (adjust) {\n      const adjustType = Util.upperFirst(adjust.type);\n\n      if (!Adjust[adjustType]) {\n        throw new Error('not support such adjust : ' + adjust);\n      }\n\n      const xScale = self.getXScale();\n      const yScale = self.getYScale();\n      const cfg = Util.mix({\n        xField: xScale.field,\n        yField: yScale.field\n      }, adjust);\n      const adjustObject = new Adjust[adjustType](cfg);\n      adjustObject.processAdjust(dataArray);\n\n      if (adjustType === 'Stack') {\n        self._updateStackRange(yScale.field, yScale, dataArray);\n      }\n    }\n  }\n\n  _updateStackRange(field, scale, dataArray) {\n    const mergeArray = Util.Array.merge(dataArray);\n    let min = scale.min;\n    let max = scale.max;\n\n    for (let i = 0, len = mergeArray.length; i < len; i++) {\n      const obj = mergeArray[i];\n      const tmpMin = Math.min.apply(null, obj[field]);\n      const tmpMax = Math.max.apply(null, obj[field]);\n\n      if (tmpMin < min) {\n        min = tmpMin;\n      }\n\n      if (tmpMax > max) {\n        max = tmpMax;\n      }\n    }\n\n    if (min < scale.min || max > scale.max) {\n      scale.change({\n        min,\n        max\n      });\n    }\n  }\n\n  _sort(mappedArray) {\n    const self = this;\n    const xScale = self.getXScale();\n    const {\n      field,\n      type\n    } = xScale;\n\n    if (type !== 'identity' && xScale.values.length > 1) {\n      Util.each(mappedArray, itemArr => {\n        itemArr.sort((obj1, obj2) => {\n          if (type === 'timeCat') {\n            return xScale._toTimeStamp(obj1[FIELD_ORIGIN][field]) - xScale._toTimeStamp(obj2[FIELD_ORIGIN][field]);\n          }\n\n          return xScale.translate(obj1[FIELD_ORIGIN][field]) - xScale.translate(obj2[FIELD_ORIGIN][field]);\n        });\n      });\n    }\n\n    self.set('hasSorted', true);\n    self.set('dataArray', mappedArray);\n  }\n\n  paint() {\n    const self = this;\n    const dataArray = self.get('dataArray');\n    const mappedArray = [];\n    const shapeFactory = self.getShapeFactory();\n    shapeFactory.setCoord(self.get('coord'));\n\n    self._beforeMapping(dataArray);\n\n    for (let i = 0, len = dataArray.length; i < len; i++) {\n      let data = dataArray[i];\n\n      if (data.length) {\n        data = self._mapping(data);\n        mappedArray.push(data);\n        self.draw(data, shapeFactory);\n      }\n    }\n\n    self.set('dataArray', mappedArray);\n  }\n\n  getShapeFactory() {\n    let shapeFactory = this.get('shapeFactory');\n\n    if (!shapeFactory) {\n      const shapeType = this.get('shapeType');\n      shapeFactory = GeometryShape.getShapeFactory(shapeType);\n      this.set('shapeFactory', shapeFactory);\n    }\n\n    return shapeFactory;\n  }\n\n  _mapping(data) {\n    const self = this;\n    const attrs = self.get('attrs');\n    const yField = self.getYScale().field; // 用来缓存转换的值，减少mapping耗时\n\n    const mappedCache = {};\n\n    for (const k in attrs) {\n      if (attrs.hasOwnProperty(k)) {\n        const attr = attrs[k];\n        const names = attr.names;\n        const scales = attr.scales;\n\n        for (let i = 0, len = data.length; i < len; i++) {\n          const record = data[i];\n          record[FIELD_ORIGIN_Y] = record[yField]; // 获取视觉属性对应的value值\n          // 位置的缓存命中率低，还是每次单独计算\n\n          if (attr.type === 'position') {\n            const values = self._getAttrValues(attr, record);\n\n            for (let j = 0, len = values.length; j < len; j++) {\n              const val = values[j];\n              const name = names[j];\n              record[name] = Util.isArray(val) && val.length === 1 ? val[0] : val;\n            }\n          } else {\n            // 除了position其他都只有一项\n            const name = names[0];\n            const field = scales[0].field;\n            const value = record[field];\n            const key = `${name}${value}`;\n            let values = mappedCache[key];\n\n            if (!values) {\n              values = self._getAttrValues(attr, record);\n              mappedCache[key] = values;\n            }\n\n            record[name] = values[0];\n          }\n        }\n      }\n    }\n\n    return data;\n  }\n\n  _getAttrValues(attr, record) {\n    const scales = attr.scales;\n    const params = [];\n\n    for (let i = 0, len = scales.length; i < len; i++) {\n      const scale = scales[i];\n      const field = scale.field;\n\n      if (scale.type === 'identity') {\n        params.push(scale.value);\n      } else {\n        params.push(record[field]);\n      }\n    }\n\n    const values = attr.mapping(...params);\n    return values;\n  }\n\n  getAttrValue(attrName, record) {\n    const attr = this.getAttr(attrName);\n    let rst = null;\n\n    if (attr) {\n      const values = this._getAttrValues(attr, record);\n\n      rst = values[0];\n    }\n\n    return rst;\n  }\n\n  _beforeMapping(dataArray) {\n    const self = this;\n\n    if (self.get('generatePoints')) {\n      self._generatePoints(dataArray);\n    }\n  }\n\n  isInCircle() {\n    const coord = this.get('coord');\n    return coord && coord.isPolar;\n  }\n\n  getCallbackCfg(fields, cfg, origin) {\n    if (!fields) {\n      return cfg;\n    }\n\n    const tmpCfg = {};\n    const params = fields.map(function (field) {\n      return origin[field];\n    });\n    Util.each(cfg, function (v, k) {\n      if (Util.isFunction(v)) {\n        tmpCfg[k] = v.apply(null, params);\n      } else {\n        tmpCfg[k] = v;\n      }\n    });\n    return tmpCfg;\n  }\n\n  getDrawCfg(obj) {\n    const self = this;\n    const isInCircle = self.isInCircle();\n    const cfg = {\n      origin: obj,\n      x: obj.x,\n      y: obj.y,\n      color: obj.color,\n      size: obj.size,\n      shape: obj.shape,\n      isInCircle,\n      opacity: obj.opacity\n    };\n    const styleOptions = self.get('styleOptions');\n\n    if (styleOptions && styleOptions.style) {\n      cfg.style = self.getCallbackCfg(styleOptions.fields, styleOptions.style, obj[FIELD_ORIGIN]);\n    }\n\n    if (self.get('generatePoints')) {\n      cfg.points = obj.points;\n      cfg.nextPoints = obj.nextPoints;\n    }\n\n    if (isInCircle) {\n      cfg.center = self.get('coord').center;\n    }\n\n    return cfg;\n  }\n\n  draw(data, shapeFactory) {\n    const self = this;\n    const container = self.get('container');\n    const yScale = self.getYScale();\n    Util.each(data, function (obj, index) {\n      if (yScale && Util.isNil(obj._origin[yScale.field])) {\n        return;\n      }\n\n      obj.index = index;\n      const cfg = self.getDrawCfg(obj);\n      const shape = obj.shape;\n      self.drawShape(shape, obj, cfg, container, shapeFactory);\n    });\n  }\n\n  drawShape(shape, shapeData, cfg, container, shapeFactory) {\n    const gShape = shapeFactory.drawShape(shape, cfg, container);\n\n    if (gShape) {\n      Util.each([].concat(gShape), s => {\n        s.set('origin', shapeData);\n      });\n    }\n  }\n\n  _generatePoints(dataArray) {\n    const self = this;\n    const shapeFactory = self.getShapeFactory();\n    const shapeAttr = self.getAttr('shape');\n    Util.each(dataArray, function (data) {\n      for (let i = 0, len = data.length; i < len; i++) {\n        const obj = data[i];\n        const cfg = self.createShapePointsCfg(obj);\n        const shape = shapeAttr ? self._getAttrValues(shapeAttr, obj) : null;\n        const points = shapeFactory.getShapePoints(shape, cfg);\n        obj.points = points;\n      }\n    }); // 添加nextPoints\n\n    Util.each(dataArray, (data, index) => {\n      const nextData = dataArray[index + 1];\n\n      if (nextData) {\n        data[0].nextPoints = nextData[0].points;\n      }\n    });\n  }\n  /**\n   * get the info of each shape\n   * @protected\n   * @param  {Object} obj the data item\n   * @return {Object} cfg return the result\n   */\n\n\n  createShapePointsCfg(obj) {\n    const xScale = this.getXScale();\n    const yScale = this.getYScale();\n\n    const x = this._normalizeValues(obj[xScale.field], xScale);\n\n    let y;\n\n    if (yScale) {\n      y = this._normalizeValues(obj[yScale.field], yScale);\n    } else {\n      y = obj.y ? obj.y : 0.1;\n    }\n\n    return {\n      x,\n      y,\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined\n    };\n  }\n\n  getYMinValue() {\n    const yScale = this.getYScale();\n    const {\n      min,\n      max\n    } = yScale;\n    let value;\n\n    if (this.get('startOnZero')) {\n      if (max <= 0 && min <= 0) {\n        value = max;\n      } else {\n        value = min >= 0 ? min : 0;\n      }\n    } else {\n      value = min;\n    }\n\n    return value;\n  }\n\n  _normalizeValues(values, scale) {\n    let rst = [];\n\n    if (Util.isArray(values)) {\n      for (let i = 0, len = values.length; i < len; i++) {\n        const v = values[i];\n        rst.push(scale.scale(v));\n      }\n    } else {\n      rst = scale.scale(values);\n    }\n\n    return rst;\n  }\n\n  getAttr(name) {\n    return this.get('attrs')[name];\n  }\n\n  getXScale() {\n    return this.getAttr('position').scales[0];\n  }\n\n  getYScale() {\n    return this.getAttr('position').scales[1];\n  }\n\n  hasAdjust(adjust) {\n    return this.get('adjust') && this.get('adjust').type === adjust;\n  }\n\n  _getSnap(scale, item, arr) {\n    let i = 0;\n    let values;\n    const yField = this.getYScale().field; // 叠加的维度\n\n    if (this.hasAdjust('stack') && scale.field === yField) {\n      values = [];\n      arr.forEach(function (obj) {\n        values.push(obj[FIELD_ORIGIN_Y]);\n      });\n\n      for (let len = values.length; i < len; i++) {\n        if (values[0][0] > item) {\n          break;\n        }\n\n        if (values[values.length - 1][1] <= item) {\n          i = values.length - 1;\n          break;\n        }\n\n        if (values[i][0] <= item && values[i][1] > item) {\n          break;\n        }\n      }\n    } else {\n      values = scale.values;\n      values.sort((a, b) => {\n        return a - b;\n      });\n\n      for (let len = values.length; i < len; i++) {\n        // 如果只有1个点直接返回第1个点\n        if (len <= 1) {\n          break;\n        } // 第1个点和第2个点之间\n\n\n        if ((values[0] + values[1]) / 2 > item) {\n          break;\n        } // 中间的点\n\n\n        if ((values[i - 1] + values[i]) / 2 <= item && (values[i + 1] + values[i]) / 2 > item) {\n          break;\n        } // 最后2个点\n\n\n        if ((values[values.length - 2] + values[values.length - 1]) / 2 <= item) {\n          i = values.length - 1;\n          break;\n        }\n      }\n    }\n\n    const result = values[i];\n    return result;\n  }\n\n  getSnapRecords(point) {\n    const self = this;\n    const coord = self.get('coord');\n    const xScale = self.getXScale();\n    const yScale = self.getYScale();\n    const xfield = xScale.field;\n    const dataArray = self.get('dataArray');\n\n    if (!this.get('hasSorted')) {\n      this._sort(dataArray);\n    }\n\n    let rst = [];\n    const invertPoint = coord.invertPoint(point);\n    let invertPointX = invertPoint.x;\n\n    if (self.isInCircle() && !coord.transposed && invertPointX > (1 + xScale.rangeMax()) / 2) {\n      invertPointX = xScale.rangeMin();\n    }\n\n    let xValue = xScale.invert(invertPointX);\n\n    if (!xScale.isCategory) {\n      xValue = self._getSnap(xScale, xValue);\n    }\n\n    const tmp = [];\n    dataArray.forEach(function (data) {\n      data.forEach(function (obj) {\n        const originValue = Util.isNil(obj[FIELD_ORIGIN]) ? obj[xfield] : obj[FIELD_ORIGIN][xfield];\n\n        if (self._isEqual(originValue, xValue, xScale)) {\n          tmp.push(obj);\n        }\n      });\n    }); // special for pie chart\n\n    if (this.hasAdjust('stack') && coord.isPolar && coord.transposed) {\n      if (invertPointX >= 0 && invertPointX <= 1) {\n        let yValue = yScale.invert(invertPoint.y);\n        yValue = self._getSnap(yScale, yValue, tmp);\n        tmp.forEach(obj => {\n          if (Util.isArray(yValue) ? obj[FIELD_ORIGIN_Y].toString() === yValue.toString() : obj[FIELD_ORIGIN_Y] === yValue) {\n            rst.push(obj);\n          }\n        });\n      }\n    } else {\n      rst = tmp;\n    }\n\n    return rst;\n  }\n\n  _isEqual(originValue, value, scale) {\n    if (scale.type === 'timeCat') {\n      return scale._toTimeStamp(originValue) === value;\n    }\n\n    return value === originValue;\n  }\n\n  position(field) {\n    this._setAttrOptions('position', {\n      field\n    });\n\n    return this;\n  }\n\n  color(field, values) {\n    this._createAttrOption('color', field, values, Global.colors);\n\n    return this;\n  }\n\n  size(field, values) {\n    this._createAttrOption('size', field, values, Global.sizes);\n\n    return this;\n  }\n\n  shape(field, values) {\n    const type = this.get('type');\n    const shapes = Global.shapes[type] || [];\n\n    this._createAttrOption('shape', field, values, shapes);\n\n    return this;\n  }\n\n  style(field, cfg) {\n    let styleOptions = this.get('styleOptions');\n\n    if (!styleOptions) {\n      styleOptions = {};\n      this.set('styleOptions', styleOptions);\n    }\n\n    if (Util.isObject(field)) {\n      cfg = field;\n      field = null;\n    }\n\n    let fields;\n\n    if (field) {\n      fields = parseFields(field);\n    }\n\n    styleOptions.fields = fields;\n    styleOptions.style = cfg;\n    return this;\n  }\n\n  adjust(type) {\n    if (Util.isString(type)) {\n      type = {\n        type\n      };\n    }\n\n    this.set('adjust', type);\n    return this;\n  }\n\n  animate(cfg) {\n    this.set('animateCfg', cfg);\n    return this;\n  }\n\n  changeData(data) {\n    this.set('data', data);\n\n    this._processData();\n  }\n\n  clearInner() {\n    const container = this.get('container');\n\n    if (container) {\n      container.clear(); // container.setMatrix([ 1, 0, 0, 1, 0, 0 ]);\n    }\n  }\n\n  reset() {\n    this.set('attrs', {});\n    this.set('attrOptions', {});\n    this.set('adjust', null);\n    this.clearInner();\n  }\n\n  clear() {\n    this.clearInner();\n  }\n\n  destroy() {\n    this.clear();\n    super.destroy();\n  }\n\n  _display(visible) {\n    this.set('visible', visible);\n    const container = this.get('container');\n    const canvas = container.get('canvas');\n    container.set('visible', visible);\n    canvas.draw();\n  }\n\n  show() {\n    this._display(true);\n  }\n\n  hide() {\n    this._display(false);\n  }\n\n}\n\nmodule.exports = Geom;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/geom/base.js"],"names":["Attr","Util","require","Base","GROUP_ATTRS","FIELD_ORIGIN","FIELD_ORIGIN_Y","Global","GeometryShape","Adjust","parseFields","field","isArray","isString","split","Geom","getDefaultCfg","type","data","attrs","scales","container","styleOptions","chart","shapeType","generatePoints","attrOptions","sortable","startOnZero","visible","connectNulls","ignoreEmptyGroup","init","self","_initAttrs","_processData","_getGroupScales","each","attrName","attr","getAttr","attrScales","scale","isCategory","indexOf","push","_groupData","colDefs","get","groupScales","length","appendConditions","names","values","Array","group","_setAttrOptions","attrCfg","options","_createAttrOption","cfg","defaultValues","isFunction","callback","coord","hasOwnProperty","option","className","upperFirst","fields","i","len","_createScale","yScale","transposed","hasAdjust","change","nice","min","max","Math","apply","createScale","dataArray","groupedArray","getYScale","filter","some","item","subData","tempData","_saveOrigin","_numberic","_adjustData","_sort","set","rst","origin","obj","k","positionAttr","j","count","translate","adjust","adjustType","Error","xScale","getXScale","mix","xField","yField","adjustObject","processAdjust","_updateStackRange","mergeArray","merge","tmpMin","tmpMax","mappedArray","itemArr","sort","obj1","obj2","_toTimeStamp","paint","shapeFactory","getShapeFactory","setCoord","_beforeMapping","_mapping","draw","mappedCache","record","_getAttrValues","val","name","value","key","params","mapping","getAttrValue","_generatePoints","isInCircle","isPolar","getCallbackCfg","tmpCfg","map","v","getDrawCfg","x","y","color","size","shape","opacity","style","points","nextPoints","center","index","isNil","_origin","drawShape","shapeData","gShape","concat","s","shapeAttr","createShapePointsCfg","getShapePoints","nextData","_normalizeValues","y0","getYMinValue","undefined","_getSnap","arr","forEach","a","b","result","getSnapRecords","point","xfield","invertPoint","invertPointX","rangeMax","rangeMin","xValue","invert","tmp","originValue","_isEqual","yValue","toString","position","colors","sizes","shapes","isObject","animate","changeData","clearInner","clear","reset","destroy","_display","canvas","show","hide","module","exports"],"mappings":"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","sourcesContent":["import * as Attr from '../attr/index';\n\nconst Util = require('../util/common');\nconst Base = require('../base');\nconst GROUP_ATTRS = [ 'color', 'size', 'shape' ];\nconst FIELD_ORIGIN = '_origin';\nconst FIELD_ORIGIN_Y = '_originY';\nconst Global = require('../global');\nconst GeometryShape = require('./shape/shape');\nconst Adjust = require('@antv/adjust/lib/base');\n\nfunction parseFields(field) {\n  if (Util.isArray(field)) {\n    return field;\n  }\n  if (Util.isString(field)) {\n    return field.split('*');\n  }\n  return [ field ];\n}\n\n/**\n * The parent class for Geometry\n * @class Geom\n */\nclass Geom extends Base {\n\n  getDefaultCfg() {\n    return {\n      /**\n       * geometry type\n       * @type {String}\n       */\n      type: null,\n      /**\n       * the data of geometry\n       * @type {Array}\n       */\n      data: null,\n      /**\n       * the attrs of geo,etry\n       * @type {Object}\n       */\n      attrs: {},\n\n      scales: {},\n\n      /**\n       * group for storing the shapes\n       * @type {Canvas}\n       */\n      container: null,\n      /**\n       * style options\n       * @type {Object}\n       */\n      styleOptions: null,\n\n      chart: null,\n\n      shapeType: '',\n\n      /**\n       * wether to generate key points for each shape\n       * @protected\n       * @type {Boolean}\n       */\n      generatePoints: false,\n\n      attrOptions: {},\n\n      sortable: false,\n      startOnZero: true,\n      visible: true,\n      connectNulls: false,\n      // 是否丢弃没有值的分组。\n      ignoreEmptyGroup: false\n    };\n  }\n\n  init() {\n    const self = this;\n    self._initAttrs();\n    self._processData();\n  }\n\n  _getGroupScales() {\n    const self = this;\n    const scales = [];\n    Util.each(GROUP_ATTRS, function(attrName) {\n      const attr = self.getAttr(attrName);\n      if (attr) {\n        const attrScales = attr.scales;\n        Util.each(attrScales, function(scale) {\n          if (scale && scale.isCategory && scales.indexOf(scale) === -1) {\n            scales.push(scale);\n          }\n        });\n      }\n    });\n    return scales;\n  }\n\n  _groupData(data) {\n    const self = this;\n    const colDefs = self.get('colDefs');\n    const groupScales = self._getGroupScales();\n    if (groupScales.length) {\n      const appendConditions = {};\n      const names = [];\n      Util.each(groupScales, scale => {\n        const field = scale.field;\n        names.push(field);\n        if (colDefs && colDefs[field] && colDefs[field].values) { // users have defined\n          appendConditions[scale.field] = colDefs[field].values;\n        }\n      });\n      return Util.Array.group(data, names, appendConditions);\n    }\n    return [ data ];\n\n  }\n\n  _setAttrOptions(attrName, attrCfg) {\n    const options = this.get('attrOptions');\n    options[attrName] = attrCfg;\n  }\n\n  _createAttrOption(attrName, field, cfg, defaultValues) {\n    const attrCfg = {};\n    attrCfg.field = field;\n    if (cfg) {\n      if (Util.isFunction(cfg)) {\n        attrCfg.callback = cfg;\n      } else {\n        attrCfg.values = cfg;\n      }\n    } else {\n      attrCfg.values = defaultValues;\n    }\n    this._setAttrOptions(attrName, attrCfg);\n  }\n\n  _initAttrs() {\n    const self = this;\n    const attrs = self.get('attrs');\n    const attrOptions = self.get('attrOptions');\n    const coord = self.get('coord');\n\n    for (const type in attrOptions) {\n      if (attrOptions.hasOwnProperty(type)) {\n        const option = attrOptions[type];\n        const className = Util.upperFirst(type);\n        const fields = parseFields(option.field);\n        if (type === 'position') {\n          option.coord = coord;\n        }\n        const scales = [];\n        for (let i = 0, len = fields.length; i < len; i++) {\n          const field = fields[i];\n          const scale = self._createScale(field);\n          scales.push(scale);\n        }\n        if (type === 'position') {\n          const yScale = scales[1];\n\n          // 饼图的处理，但是还不知道为啥\n          if (coord.type === 'polar' && coord.transposed && self.hasAdjust('stack')) {\n            if (yScale.values.length) {\n              yScale.change({\n                nice: false,\n                min: 0,\n                max: Math.max.apply(null, yScale.values)\n              });\n            }\n          }\n        }\n\n        option.scales = scales;\n        const attr = new Attr[className](option);\n        attrs[type] = attr;\n      }\n    }\n  }\n\n  _createScale(field) {\n    const scales = this.get('scales');\n    let scale = scales[field];\n    if (!scale) {\n      scale = this.get('chart').createScale(field);\n      scales[field] = scale;\n    }\n    return scale;\n  }\n\n  _processData() {\n    const self = this;\n    const data = this.get('data');\n    const dataArray = [];\n    let groupedArray = this._groupData(data);\n    if (this.get('ignoreEmptyGroup')) {\n      const yScale = this.getYScale();\n      groupedArray = groupedArray.filter(group =>\n        group.some(item => typeof item[yScale.field] !== 'undefined')\n      );\n    }\n    for (let i = 0, len = groupedArray.length; i < len; i++) {\n      const subData = groupedArray[i];\n      const tempData = self._saveOrigin(subData);\n      if (this.hasAdjust('dodge')) {\n        self._numberic(tempData);\n      }\n      dataArray.push(tempData);\n    }\n    if (self.get('adjust')) {\n      self._adjustData(dataArray);\n    }\n    if (self.get('sortable')) {\n      self._sort(dataArray);\n    }\n    self.set('dataArray', dataArray);\n    return dataArray;\n  }\n\n  _saveOrigin(data) {\n    const rst = [];\n    for (let i = 0, len = data.length; i < len; i++) {\n      const origin = data[i];\n      const obj = {};\n      for (const k in origin) {\n        obj[k] = origin[k];\n      }\n      obj[FIELD_ORIGIN] = origin;\n      rst.push(obj);\n    }\n    return rst;\n  }\n\n  _numberic(data) {\n    const positionAttr = this.getAttr('position');\n    const scales = positionAttr.scales;\n    for (let j = 0, len = data.length; j < len; j++) {\n      const obj = data[j];\n      const count = Math.min(2, scales.length);\n      for (let i = 0; i < count; i++) {\n        const scale = scales[i];\n        if (scale.isCategory) {\n          const field = scale.field;\n          obj[field] = scale.translate(obj[field]);\n        }\n      }\n    }\n  }\n\n  _adjustData(dataArray) {\n    const self = this;\n    const adjust = self.get('adjust');\n    if (adjust) {\n      const adjustType = Util.upperFirst(adjust.type);\n      if (!Adjust[adjustType]) {\n        throw new Error('not support such adjust : ' + adjust);\n      }\n\n      const xScale = self.getXScale();\n      const yScale = self.getYScale();\n      const cfg = Util.mix({\n        xField: xScale.field,\n        yField: yScale.field\n      }, adjust);\n      const adjustObject = new Adjust[adjustType](cfg);\n      adjustObject.processAdjust(dataArray);\n      if (adjustType === 'Stack') {\n        self._updateStackRange(yScale.field, yScale, dataArray);\n      }\n    }\n  }\n\n  _updateStackRange(field, scale, dataArray) {\n    const mergeArray = Util.Array.merge(dataArray);\n    let min = scale.min;\n    let max = scale.max;\n    for (let i = 0, len = mergeArray.length; i < len; i++) {\n      const obj = mergeArray[i];\n      const tmpMin = Math.min.apply(null, obj[field]);\n      const tmpMax = Math.max.apply(null, obj[field]);\n      if (tmpMin < min) {\n        min = tmpMin;\n      }\n      if (tmpMax > max) {\n        max = tmpMax;\n      }\n    }\n    if (min < scale.min || max > scale.max) {\n      scale.change({\n        min,\n        max\n      });\n    }\n  }\n\n  _sort(mappedArray) {\n    const self = this;\n    const xScale = self.getXScale();\n    const { field, type } = xScale;\n    if (type !== 'identity' && xScale.values.length > 1) {\n      Util.each(mappedArray, itemArr => {\n        itemArr.sort((obj1, obj2) => {\n          if (type === 'timeCat') {\n            return xScale._toTimeStamp(obj1[FIELD_ORIGIN][field]) - xScale._toTimeStamp(obj2[FIELD_ORIGIN][field]);\n          }\n          return xScale.translate(obj1[FIELD_ORIGIN][field]) - xScale.translate(obj2[FIELD_ORIGIN][field]);\n        });\n      });\n    }\n\n    self.set('hasSorted', true);\n    self.set('dataArray', mappedArray);\n  }\n\n  paint() {\n    const self = this;\n    const dataArray = self.get('dataArray');\n    const mappedArray = [];\n    const shapeFactory = self.getShapeFactory();\n    shapeFactory.setCoord(self.get('coord'));\n    self._beforeMapping(dataArray);\n    for (let i = 0, len = dataArray.length; i < len; i++) {\n      let data = dataArray[i];\n      if (data.length) {\n        data = self._mapping(data);\n        mappedArray.push(data);\n        self.draw(data, shapeFactory);\n      }\n    }\n    self.set('dataArray', mappedArray);\n  }\n\n  getShapeFactory() {\n    let shapeFactory = this.get('shapeFactory');\n    if (!shapeFactory) {\n      const shapeType = this.get('shapeType');\n      shapeFactory = GeometryShape.getShapeFactory(shapeType);\n      this.set('shapeFactory', shapeFactory);\n    }\n    return shapeFactory;\n  }\n\n  _mapping(data) {\n    const self = this;\n    const attrs = self.get('attrs');\n    const yField = self.getYScale().field;\n\n    // 用来缓存转换的值，减少mapping耗时\n    const mappedCache = {};\n\n    for (const k in attrs) {\n      if (attrs.hasOwnProperty(k)) {\n        const attr = attrs[k];\n        const names = attr.names;\n        const scales = attr.scales;\n\n        for (let i = 0, len = data.length; i < len; i++) {\n          const record = data[i];\n          record[FIELD_ORIGIN_Y] = record[yField];\n\n          // 获取视觉属性对应的value值\n          // 位置的缓存命中率低，还是每次单独计算\n          if (attr.type === 'position') {\n            const values = self._getAttrValues(attr, record);\n            for (let j = 0, len = values.length; j < len; j++) {\n              const val = values[j];\n              const name = names[j];\n              record[name] = (Util.isArray(val) && val.length === 1) ? val[0] : val;\n            }\n          } else {\n            // 除了position其他都只有一项\n            const name = names[0];\n            const field = scales[0].field;\n            const value = record[field];\n            const key = `${name}${value}`;\n            let values = mappedCache[key];\n            if (!values) {\n              values = self._getAttrValues(attr, record);\n              mappedCache[key] = values;\n            }\n            record[name] = values[0];\n          }\n        }\n      }\n    }\n    return data;\n  }\n\n  _getAttrValues(attr, record) {\n    const scales = attr.scales;\n    const params = [];\n    for (let i = 0, len = scales.length; i < len; i++) {\n      const scale = scales[i];\n      const field = scale.field;\n      if (scale.type === 'identity') {\n        params.push(scale.value);\n      } else {\n        params.push(record[field]);\n      }\n    }\n    const values = attr.mapping(...params);\n    return values;\n  }\n\n  getAttrValue(attrName, record) {\n    const attr = this.getAttr(attrName);\n    let rst = null;\n    if (attr) {\n      const values = this._getAttrValues(attr, record);\n      rst = values[0];\n    }\n    return rst;\n  }\n\n  _beforeMapping(dataArray) {\n    const self = this;\n    if (self.get('generatePoints')) {\n      self._generatePoints(dataArray);\n    }\n  }\n\n  isInCircle() {\n    const coord = this.get('coord');\n    return coord && coord.isPolar;\n  }\n\n  getCallbackCfg(fields, cfg, origin) {\n    if (!fields) {\n      return cfg;\n    }\n    const tmpCfg = {};\n    const params = fields.map(function(field) {\n      return origin[field];\n    });\n    Util.each(cfg, function(v, k) {\n      if (Util.isFunction(v)) {\n        tmpCfg[k] = v.apply(null, params);\n      } else {\n        tmpCfg[k] = v;\n      }\n    });\n    return tmpCfg;\n  }\n\n  getDrawCfg(obj) {\n    const self = this;\n    const isInCircle = self.isInCircle();\n    const cfg = {\n      origin: obj,\n      x: obj.x,\n      y: obj.y,\n      color: obj.color,\n      size: obj.size,\n      shape: obj.shape,\n      isInCircle,\n      opacity: obj.opacity\n    };\n    const styleOptions = self.get('styleOptions');\n    if (styleOptions && styleOptions.style) {\n      cfg.style = self.getCallbackCfg(styleOptions.fields, styleOptions.style, obj[FIELD_ORIGIN]);\n    }\n    if (self.get('generatePoints')) {\n      cfg.points = obj.points;\n      cfg.nextPoints = obj.nextPoints;\n    }\n    if (isInCircle) {\n      cfg.center = self.get('coord').center;\n    }\n    return cfg;\n  }\n\n  draw(data, shapeFactory) {\n    const self = this;\n    const container = self.get('container');\n    const yScale = self.getYScale();\n    Util.each(data, function(obj, index) {\n      if (yScale && Util.isNil(obj._origin[yScale.field])) {\n        return;\n      }\n      obj.index = index;\n      const cfg = self.getDrawCfg(obj);\n      const shape = obj.shape;\n      self.drawShape(shape, obj, cfg, container, shapeFactory);\n    });\n  }\n\n  drawShape(shape, shapeData, cfg, container, shapeFactory) {\n    const gShape = shapeFactory.drawShape(shape, cfg, container);\n\n    if (gShape) {\n      Util.each([].concat(gShape), s => {\n        s.set('origin', shapeData);\n      });\n    }\n  }\n\n  _generatePoints(dataArray) {\n    const self = this;\n    const shapeFactory = self.getShapeFactory();\n    const shapeAttr = self.getAttr('shape');\n    Util.each(dataArray, function(data) {\n      for (let i = 0, len = data.length; i < len; i++) {\n        const obj = data[i];\n        const cfg = self.createShapePointsCfg(obj);\n        const shape = shapeAttr ? self._getAttrValues(shapeAttr, obj) : null;\n        const points = shapeFactory.getShapePoints(shape, cfg);\n        obj.points = points;\n      }\n    });\n    // 添加nextPoints\n    Util.each(dataArray, (data, index) => {\n      const nextData = dataArray[index + 1];\n      if (nextData) {\n        data[0].nextPoints = nextData[0].points;\n      }\n    });\n  }\n\n  /**\n   * get the info of each shape\n   * @protected\n   * @param  {Object} obj the data item\n   * @return {Object} cfg return the result\n   */\n  createShapePointsCfg(obj) {\n    const xScale = this.getXScale();\n    const yScale = this.getYScale();\n    const x = this._normalizeValues(obj[xScale.field], xScale);\n    let y;\n\n    if (yScale) {\n      y = this._normalizeValues(obj[yScale.field], yScale);\n    } else {\n      y = obj.y ? obj.y : 0.1;\n    }\n\n    return {\n      x,\n      y,\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined\n    };\n  }\n\n  getYMinValue() {\n    const yScale = this.getYScale();\n    const { min, max } = yScale;\n    let value;\n\n    if (this.get('startOnZero')) {\n      if (max <= 0 && min <= 0) {\n        value = max;\n      } else {\n        value = min >= 0 ? min : 0;\n      }\n    } else {\n      value = min;\n    }\n\n    return value;\n  }\n\n  _normalizeValues(values, scale) {\n    let rst = [];\n    if (Util.isArray(values)) {\n      for (let i = 0, len = values.length; i < len; i++) {\n        const v = values[i];\n        rst.push(scale.scale(v));\n      }\n    } else {\n      rst = scale.scale(values);\n    }\n    return rst;\n  }\n\n  getAttr(name) {\n    return this.get('attrs')[name];\n  }\n\n  getXScale() {\n    return this.getAttr('position').scales[0];\n  }\n\n  getYScale() {\n    return this.getAttr('position').scales[1];\n  }\n\n  hasAdjust(adjust) {\n    return this.get('adjust') && (this.get('adjust').type === adjust);\n  }\n\n  _getSnap(scale, item, arr) {\n    let i = 0;\n    let values;\n    const yField = this.getYScale().field; // 叠加的维度\n    if (this.hasAdjust('stack') && scale.field === yField) {\n      values = [];\n      arr.forEach(function(obj) {\n        values.push(obj[FIELD_ORIGIN_Y]);\n      });\n\n      for (let len = values.length; i < len; i++) {\n        if (values[0][0] > item) {\n          break;\n        }\n        if (values[values.length - 1][1] <= item) {\n          i = values.length - 1;\n          break;\n        }\n        if (values[i][0] <= item && values[i][1] > item) {\n          break;\n        }\n      }\n    } else {\n      values = scale.values;\n      values.sort((a, b) => {\n        return a - b;\n      });\n      for (let len = values.length; i < len; i++) {\n        // 如果只有1个点直接返回第1个点\n        if (len <= 1) {\n          break;\n        }\n        // 第1个点和第2个点之间\n        if ((values[0] + values[1]) / 2 > item) {\n          break;\n        }\n        // 中间的点\n        if ((values[i - 1] + values[i]) / 2 <= item && (values[i + 1] + values[i]) / 2 > item) {\n          break;\n        }\n        // 最后2个点\n        if ((values[values.length - 2] + values[values.length - 1]) / 2 <= item) {\n          i = values.length - 1;\n          break;\n        }\n      }\n    }\n    const result = values[i];\n    return result;\n  }\n\n  getSnapRecords(point) {\n    const self = this;\n    const coord = self.get('coord');\n    const xScale = self.getXScale();\n    const yScale = self.getYScale();\n    const xfield = xScale.field;\n\n    const dataArray = self.get('dataArray');\n    if (!this.get('hasSorted')) {\n      this._sort(dataArray);\n    }\n\n    let rst = [];\n    const invertPoint = coord.invertPoint(point);\n    let invertPointX = invertPoint.x;\n    if (self.isInCircle() && !coord.transposed && invertPointX > (1 + xScale.rangeMax()) / 2) {\n      invertPointX = xScale.rangeMin();\n    }\n\n    let xValue = xScale.invert(invertPointX);\n    if (!xScale.isCategory) {\n      xValue = self._getSnap(xScale, xValue);\n    }\n\n    const tmp = [];\n\n    dataArray.forEach(function(data) {\n      data.forEach(function(obj) {\n        const originValue = Util.isNil(obj[FIELD_ORIGIN]) ? obj[xfield] : obj[FIELD_ORIGIN][xfield];\n        if (self._isEqual(originValue, xValue, xScale)) {\n          tmp.push(obj);\n        }\n      });\n    });\n\n    // special for pie chart\n    if (this.hasAdjust('stack') && coord.isPolar && coord.transposed) {\n      if (invertPointX >= 0 && invertPointX <= 1) {\n        let yValue = yScale.invert(invertPoint.y);\n        yValue = self._getSnap(yScale, yValue, tmp);\n        tmp.forEach(obj => {\n          if (Util.isArray(yValue) ? obj[FIELD_ORIGIN_Y].toString() === yValue.toString() : obj[FIELD_ORIGIN_Y] === yValue) {\n            rst.push(obj);\n          }\n        });\n      }\n\n    } else {\n      rst = tmp;\n    }\n\n    return rst;\n  }\n\n  _isEqual(originValue, value, scale) {\n    if (scale.type === 'timeCat') {\n      return scale._toTimeStamp(originValue) === value;\n    }\n    return value === originValue;\n  }\n\n  position(field) {\n    this._setAttrOptions('position', {\n      field\n    });\n    return this;\n  }\n\n  color(field, values) {\n    this._createAttrOption('color', field, values, Global.colors);\n    return this;\n  }\n\n  size(field, values) {\n    this._createAttrOption('size', field, values, Global.sizes);\n    return this;\n  }\n\n  shape(field, values) {\n    const type = this.get('type');\n    const shapes = Global.shapes[type] || [];\n    this._createAttrOption('shape', field, values, shapes);\n    return this;\n  }\n\n  style(field, cfg) {\n    let styleOptions = this.get('styleOptions');\n    if (!styleOptions) {\n      styleOptions = {};\n      this.set('styleOptions', styleOptions);\n    }\n    if (Util.isObject(field)) {\n      cfg = field;\n      field = null;\n    }\n    let fields;\n    if (field) {\n      fields = parseFields(field);\n    }\n    styleOptions.fields = fields;\n    styleOptions.style = cfg;\n    return this;\n  }\n\n  adjust(type) {\n    if (Util.isString(type)) {\n      type = { type };\n    }\n    this.set('adjust', type);\n    return this;\n  }\n\n  animate(cfg) {\n    this.set('animateCfg', cfg);\n    return this;\n  }\n\n  changeData(data) {\n    this.set('data', data);\n    this._processData();\n  }\n\n  clearInner() {\n    const container = this.get('container');\n    if (container) {\n      container.clear();\n      // container.setMatrix([ 1, 0, 0, 1, 0, 0 ]);\n    }\n  }\n\n  reset() {\n    this.set('attrs', {});\n    this.set('attrOptions', {});\n    this.set('adjust', null);\n    this.clearInner();\n  }\n\n  clear() {\n    this.clearInner();\n  }\n\n  destroy() {\n    this.clear();\n    super.destroy();\n  }\n\n  _display(visible) {\n    this.set('visible', visible);\n    const container = this.get('container');\n    const canvas = container.get('canvas');\n    container.set('visible', visible);\n    canvas.draw();\n  }\n\n  show() {\n    this._display(true);\n  }\n\n  hide() {\n    this._display(false);\n  }\n}\n\nmodule.exports = Geom;\n"]},"metadata":{},"sourceType":"module"}