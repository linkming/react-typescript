{"ast":null,"code":"const Vector2 = require('./vector2');\n\nconst start = Vector2.create();\nconst end = Vector2.create();\nconst extremity = Vector2.create();\n\nfunction getCubicBezierXYatT(startPt, controlPt1, controlPt2, endPt, T) {\n  const x = CubicN(T, startPt.x, controlPt1.x, controlPt2.x, endPt.x);\n  const y = CubicN(T, startPt.y, controlPt1.y, controlPt2.y, endPt.y);\n  return {\n    x,\n    y\n  };\n} // cubic helper formula at T distance\n\n\nfunction CubicN(T, a, b, c, d) {\n  const t2 = T * T;\n  const t3 = t2 * T;\n  return a + (-a * 3 + T * (3 * a - a * T)) * T + (3 * b + T * (-6 * b + b * 3 * T)) * T + (c * 3 - c * 3 * T) * t2 + d * t3;\n}\n\nfunction cubicBezierBounds(c) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n  const s = {\n    x: c[0],\n    y: c[1]\n  };\n  const c1 = {\n    x: c[2],\n    y: c[3]\n  };\n  const c2 = {\n    x: c[4],\n    y: c[5]\n  };\n  const e = {\n    x: c[6],\n    y: c[7]\n  };\n\n  for (let t = 0; t < 100; t++) {\n    const pt = getCubicBezierXYatT(s, c1, c2, e, t / 100);\n\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY\n  };\n}\n\nmodule.exports = {\n  getBBoxFromPoints(points, lineWidth) {\n    if (points.length === 0) {\n      return;\n    }\n\n    let p = points[0];\n    let left = p.x;\n    let right = p.x;\n    let top = p.y;\n    let bottom = p.y;\n    const len = points.length;\n\n    for (let i = 1; i < len; i++) {\n      p = points[i];\n      left = Math.min(left, p.x);\n      right = Math.max(right, p.x);\n      top = Math.min(top, p.y);\n      bottom = Math.max(bottom, p.y);\n    }\n\n    lineWidth = lineWidth / 2 || 0;\n    return {\n      minX: left - lineWidth,\n      minY: top - lineWidth,\n      maxX: right + lineWidth,\n      maxY: bottom + lineWidth\n    };\n  },\n\n  getBBoxFromLine(x0, y0, x1, y1, lineWidth) {\n    lineWidth = lineWidth / 2 || 0;\n    return {\n      minX: Math.min(x0, x1) - lineWidth,\n      minY: Math.min(y0, y1) - lineWidth,\n      maxX: Math.max(x0, x1) + lineWidth,\n      maxY: Math.max(y0, y1) + lineWidth\n    };\n  },\n\n  getBBoxFromArc(x, y, r, startAngle, endAngle, anticlockwise) {\n    const diff = Math.abs(startAngle - endAngle);\n\n    if (diff % (Math.PI * 2) < 1e-4 && diff > 1e-4) {\n      // Is a circle\n      return {\n        minX: x - r,\n        minY: y - r,\n        maxX: x + r,\n        maxY: y + r\n      };\n    }\n\n    start[0] = Math.cos(startAngle) * r + x;\n    start[1] = Math.sin(startAngle) * r + y;\n    end[0] = Math.cos(endAngle) * r + x;\n    end[1] = Math.sin(endAngle) * r + y;\n    const min = [0, 0];\n    const max = [0, 0];\n    Vector2.min(min, start, end);\n    Vector2.max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n    startAngle = startAngle % (Math.PI * 2);\n\n    if (startAngle < 0) {\n      startAngle = startAngle + Math.PI * 2;\n    }\n\n    endAngle = endAngle % (Math.PI * 2);\n\n    if (endAngle < 0) {\n      endAngle = endAngle + Math.PI * 2;\n    }\n\n    if (startAngle > endAngle && !anticlockwise) {\n      endAngle += Math.PI * 2;\n    } else if (startAngle < endAngle && anticlockwise) {\n      startAngle += Math.PI * 2;\n    }\n\n    if (anticlockwise) {\n      const tmp = endAngle;\n      endAngle = startAngle;\n      startAngle = tmp;\n    }\n\n    for (let angle = 0; angle < endAngle; angle += Math.PI / 2) {\n      if (angle > startAngle) {\n        extremity[0] = Math.cos(angle) * r + x;\n        extremity[1] = Math.sin(angle) * r + y;\n        Vector2.min(min, extremity, min);\n        Vector2.max(max, extremity, max);\n      }\n    }\n\n    return {\n      minX: min[0],\n      minY: min[1],\n      maxX: max[0],\n      maxY: max[1]\n    };\n  },\n\n  getBBoxFromBezierGroup(points, lineWidth) {\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n\n    for (let i = 0, len = points.length; i < len; i++) {\n      const bbox = cubicBezierBounds(points[i]);\n\n      if (bbox.minX < minX) {\n        minX = bbox.minX;\n      }\n\n      if (bbox.maxX > maxX) {\n        maxX = bbox.maxX;\n      }\n\n      if (bbox.minY < minY) {\n        minY = bbox.minY;\n      }\n\n      if (bbox.maxY > maxY) {\n        maxY = bbox.maxY;\n      }\n    }\n\n    lineWidth = lineWidth / 2 || 0;\n    return {\n      minX: minX - lineWidth,\n      minY: minY - lineWidth,\n      maxX: maxX + lineWidth,\n      maxY: maxY + lineWidth\n    };\n  }\n\n};","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/graphic/util/bbox.js"],"names":["Vector2","require","start","create","end","extremity","getCubicBezierXYatT","startPt","controlPt1","controlPt2","endPt","T","x","CubicN","y","a","b","c","d","t2","t3","cubicBezierBounds","minX","Infinity","maxX","minY","maxY","s","c1","c2","e","t","pt","module","exports","getBBoxFromPoints","points","lineWidth","length","p","left","right","top","bottom","len","i","Math","min","max","getBBoxFromLine","x0","y0","x1","y1","getBBoxFromArc","r","startAngle","endAngle","anticlockwise","diff","abs","PI","cos","sin","tmp","angle","getBBoxFromBezierGroup","bbox"],"mappings":"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","sourcesContent":["const Vector2 = require('./vector2');\n\nconst start = Vector2.create();\nconst end = Vector2.create();\nconst extremity = Vector2.create();\n\nfunction getCubicBezierXYatT(startPt, controlPt1, controlPt2, endPt, T) {\n  const x = CubicN(T, startPt.x, controlPt1.x, controlPt2.x, endPt.x);\n  const y = CubicN(T, startPt.y, controlPt1.y, controlPt2.y, endPt.y);\n  return ({\n    x,\n    y\n  });\n}\n// cubic helper formula at T distance\nfunction CubicN(T, a, b, c, d) {\n  const t2 = T * T;\n  const t3 = t2 * T;\n  return a + (-a * 3 + T * (3 * a - a * T)) * T + (3 * b + T * (-6 * b + b * 3 * T)) * T + (c * 3 - c * 3 * T) * t2 + d * t3;\n}\n\nfunction cubicBezierBounds(c) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n  const s = {\n    x: c[0],\n    y: c[1]\n  };\n  const c1 = {\n    x: c[2],\n    y: c[3]\n  };\n  const c2 = {\n    x: c[4],\n    y: c[5]\n  };\n  const e = {\n    x: c[6],\n    y: c[7]\n  };\n  for (let t = 0; t < 100; t++) {\n    const pt = getCubicBezierXYatT(s, c1, c2, e, t / 100);\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n  return {\n    minX,\n    minY,\n    maxX,\n    maxY\n  };\n}\n\nmodule.exports = {\n  getBBoxFromPoints(points, lineWidth) {\n    if (points.length === 0) {\n      return;\n    }\n    let p = points[0];\n    let left = p.x;\n    let right = p.x;\n    let top = p.y;\n    let bottom = p.y;\n    const len = points.length;\n\n    for (let i = 1; i < len; i++) {\n      p = points[i];\n      left = Math.min(left, p.x);\n      right = Math.max(right, p.x);\n      top = Math.min(top, p.y);\n      bottom = Math.max(bottom, p.y);\n    }\n\n    lineWidth = (lineWidth / 2) || 0;\n\n    return {\n      minX: left - lineWidth,\n      minY: top - lineWidth,\n      maxX: right + lineWidth,\n      maxY: bottom + lineWidth\n    };\n  },\n  getBBoxFromLine(x0, y0, x1, y1, lineWidth) {\n    lineWidth = (lineWidth / 2) || 0;\n\n    return {\n      minX: Math.min(x0, x1) - lineWidth,\n      minY: Math.min(y0, y1) - lineWidth,\n      maxX: Math.max(x0, x1) + lineWidth,\n      maxY: Math.max(y0, y1) + lineWidth\n    };\n  },\n  getBBoxFromArc(x, y, r, startAngle, endAngle, anticlockwise) {\n    const diff = Math.abs(startAngle - endAngle);\n    if (diff % (Math.PI * 2) < 1e-4 && diff > 1e-4) {\n      // Is a circle\n      return {\n        minX: x - r,\n        minY: y - r,\n        maxX: x + r,\n        maxY: y + r\n      };\n    }\n\n    start[0] = Math.cos(startAngle) * r + x;\n    start[1] = Math.sin(startAngle) * r + y;\n\n    end[0] = Math.cos(endAngle) * r + x;\n    end[1] = Math.sin(endAngle) * r + y;\n    const min = [ 0, 0 ];\n    const max = [ 0, 0 ];\n\n    Vector2.min(min, start, end);\n    Vector2.max(max, start, end);\n\n    // Thresh to [0, Math.PI * 2]\n    startAngle = startAngle % (Math.PI * 2);\n    if (startAngle < 0) {\n      startAngle = startAngle + Math.PI * 2;\n    }\n    endAngle = endAngle % (Math.PI * 2);\n    if (endAngle < 0) {\n      endAngle = endAngle + Math.PI * 2;\n    }\n\n    if (startAngle > endAngle && !anticlockwise) {\n      endAngle += Math.PI * 2;\n    } else if (startAngle < endAngle && anticlockwise) {\n      startAngle += Math.PI * 2;\n    }\n    if (anticlockwise) {\n      const tmp = endAngle;\n      endAngle = startAngle;\n      startAngle = tmp;\n    }\n\n    for (let angle = 0; angle < endAngle; angle += Math.PI / 2) {\n      if (angle > startAngle) {\n        extremity[0] = Math.cos(angle) * r + x;\n        extremity[1] = Math.sin(angle) * r + y;\n\n        Vector2.min(min, extremity, min);\n        Vector2.max(max, extremity, max);\n      }\n    }\n\n    return {\n      minX: min[0],\n      minY: min[1],\n      maxX: max[0],\n      maxY: max[1]\n    };\n  },\n  getBBoxFromBezierGroup(points, lineWidth) {\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, len = points.length; i < len; i++) {\n      const bbox = cubicBezierBounds(points[i]);\n      if (bbox.minX < minX) {\n        minX = bbox.minX;\n      }\n      if (bbox.maxX > maxX) {\n        maxX = bbox.maxX;\n      }\n      if (bbox.minY < minY) {\n        minY = bbox.minY;\n      }\n      if (bbox.maxY > maxY) {\n        maxY = bbox.maxY;\n      }\n    }\n\n    lineWidth = (lineWidth / 2) || 0;\n\n    return {\n      minX: minX - lineWidth,\n      minY: minY - lineWidth,\n      maxX: maxX + lineWidth,\n      maxY: maxY + lineWidth\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}