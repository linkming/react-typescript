{"ast":null,"code":"const Base = require('./base');\n\nclass Cartesian extends Base {\n  _initDefaultCfg() {\n    this.type = 'cartesian';\n    this.transposed = false;\n    this.isRect = true;\n  }\n\n  init(start, end) {\n    super.init(start, end);\n    this.x = {\n      start: start.x,\n      end: end.x\n    };\n    this.y = {\n      start: start.y,\n      end: end.y\n    };\n  }\n\n  _convertPoint(point) {\n    const self = this;\n    const transposed = self.transposed;\n    const xDim = transposed ? 'y' : 'x';\n    const yDim = transposed ? 'x' : 'y';\n    const x = self.x;\n    const y = self.y;\n    return {\n      x: x.start + (x.end - x.start) * point[xDim],\n      y: y.start + (y.end - y.start) * point[yDim]\n    };\n  }\n\n  _invertPoint(point) {\n    const self = this;\n    const transposed = self.transposed;\n    const xDim = transposed ? 'y' : 'x';\n    const yDim = transposed ? 'x' : 'y';\n    const x = self.x;\n    const y = self.y;\n    const rst = {};\n    rst[xDim] = (point.x - x.start) / (x.end - x.start);\n    rst[yDim] = (point.y - y.start) / (y.end - y.start);\n    return rst;\n  }\n\n}\n\nBase.Cartesian = Cartesian;\nBase.Rect = Cartesian;\nmodule.exports = Cartesian;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/coord/cartesian.js"],"names":["Base","require","Cartesian","_initDefaultCfg","type","transposed","isRect","init","start","end","x","y","_convertPoint","point","self","xDim","yDim","_invertPoint","rst","Rect","module","exports"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,QAAD,CAApB;;AAEA,MAAMC,SAAN,SAAwBF,IAAxB,CAA6B;AAC3BG,EAAAA,eAAe,GAAG;AAChB,SAAKC,IAAL,GAAY,WAAZ;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKC,MAAL,GAAc,IAAd;AACD;;AAEDC,EAAAA,IAAI,CAACC,KAAD,EAAQC,GAAR,EAAa;AACf,UAAMF,IAAN,CAAWC,KAAX,EAAkBC,GAAlB;AACA,SAAKC,CAAL,GAAS;AACPF,MAAAA,KAAK,EAAEA,KAAK,CAACE,CADN;AAEPD,MAAAA,GAAG,EAAEA,GAAG,CAACC;AAFF,KAAT;AAKA,SAAKC,CAAL,GAAS;AACPH,MAAAA,KAAK,EAAEA,KAAK,CAACG,CADN;AAEPF,MAAAA,GAAG,EAAEA,GAAG,CAACE;AAFF,KAAT;AAID;;AAEDC,EAAAA,aAAa,CAACC,KAAD,EAAQ;AACnB,UAAMC,IAAI,GAAG,IAAb;AACA,UAAMT,UAAU,GAAGS,IAAI,CAACT,UAAxB;AACA,UAAMU,IAAI,GAAGV,UAAU,GAAG,GAAH,GAAS,GAAhC;AACA,UAAMW,IAAI,GAAGX,UAAU,GAAG,GAAH,GAAS,GAAhC;AACA,UAAMK,CAAC,GAAGI,IAAI,CAACJ,CAAf;AACA,UAAMC,CAAC,GAAGG,IAAI,CAACH,CAAf;AACA,WAAO;AACLD,MAAAA,CAAC,EAAEA,CAAC,CAACF,KAAF,GAAU,CAACE,CAAC,CAACD,GAAF,GAAQC,CAAC,CAACF,KAAX,IAAoBK,KAAK,CAACE,IAAD,CADjC;AAELJ,MAAAA,CAAC,EAAEA,CAAC,CAACH,KAAF,GAAU,CAACG,CAAC,CAACF,GAAF,GAAQE,CAAC,CAACH,KAAX,IAAoBK,KAAK,CAACG,IAAD;AAFjC,KAAP;AAID;;AAEDC,EAAAA,YAAY,CAACJ,KAAD,EAAQ;AAClB,UAAMC,IAAI,GAAG,IAAb;AACA,UAAMT,UAAU,GAAGS,IAAI,CAACT,UAAxB;AACA,UAAMU,IAAI,GAAGV,UAAU,GAAG,GAAH,GAAS,GAAhC;AACA,UAAMW,IAAI,GAAGX,UAAU,GAAG,GAAH,GAAS,GAAhC;AACA,UAAMK,CAAC,GAAGI,IAAI,CAACJ,CAAf;AACA,UAAMC,CAAC,GAAGG,IAAI,CAACH,CAAf;AACA,UAAMO,GAAG,GAAG,EAAZ;AACAA,IAAAA,GAAG,CAACH,IAAD,CAAH,GAAY,CAACF,KAAK,CAACH,CAAN,GAAUA,CAAC,CAACF,KAAb,KAAuBE,CAAC,CAACD,GAAF,GAAQC,CAAC,CAACF,KAAjC,CAAZ;AACAU,IAAAA,GAAG,CAACF,IAAD,CAAH,GAAY,CAACH,KAAK,CAACF,CAAN,GAAUA,CAAC,CAACH,KAAb,KAAuBG,CAAC,CAACF,GAAF,GAAQE,CAAC,CAACH,KAAjC,CAAZ;AACA,WAAOU,GAAP;AACD;;AA5C0B;;AA+C7BlB,IAAI,CAACE,SAAL,GAAiBA,SAAjB;AACAF,IAAI,CAACmB,IAAL,GAAYjB,SAAZ;AACAkB,MAAM,CAACC,OAAP,GAAiBnB,SAAjB","sourcesContent":["const Base = require('./base');\n\nclass Cartesian extends Base {\n  _initDefaultCfg() {\n    this.type = 'cartesian';\n    this.transposed = false;\n    this.isRect = true;\n  }\n\n  init(start, end) {\n    super.init(start, end);\n    this.x = {\n      start: start.x,\n      end: end.x\n    };\n\n    this.y = {\n      start: start.y,\n      end: end.y\n    };\n  }\n\n  _convertPoint(point) {\n    const self = this;\n    const transposed = self.transposed;\n    const xDim = transposed ? 'y' : 'x';\n    const yDim = transposed ? 'x' : 'y';\n    const x = self.x;\n    const y = self.y;\n    return {\n      x: x.start + (x.end - x.start) * point[xDim],\n      y: y.start + (y.end - y.start) * point[yDim]\n    };\n  }\n\n  _invertPoint(point) {\n    const self = this;\n    const transposed = self.transposed;\n    const xDim = transposed ? 'y' : 'x';\n    const yDim = transposed ? 'x' : 'y';\n    const x = self.x;\n    const y = self.y;\n    const rst = {};\n    rst[xDim] = (point.x - x.start) / (x.end - x.start);\n    rst[yDim] = (point.y - y.start) / (y.end - y.start);\n    return rst;\n  }\n}\n\nBase.Cartesian = Cartesian;\nBase.Rect = Cartesian;\nmodule.exports = Cartesian;\n"]},"metadata":{},"sourceType":"script"}