{"ast":null,"code":"/**\n * @fileOverview 计算方法\n * @author dxq613@gmail.com\n */\n// 如果小数点后面超过 10 位浮点数时进行一下处理\nvar DECIMAL_LENGTH = 12; // 获取系数\n\nfunction getFactor(v) {\n  var factor = 1;\n\n  if (v === Infinity || v === -Infinity) {\n    throw new Error('Not support Infinity!');\n  }\n\n  if (v < 1) {\n    var count = 0;\n\n    while (v < 1) {\n      factor = factor / 10;\n      v = v * 10;\n      count++;\n    } // 浮点数计算出现问题\n\n\n    if (factor.toString().length > DECIMAL_LENGTH) {\n      factor = parseFloat(factor.toFixed(count));\n    }\n  } else {\n    while (v > 10) {\n      factor = factor * 10;\n      v = v / 10;\n    }\n  }\n\n  return factor;\n} // 取小于当前值的\n\n\nfunction arrayFloor(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  }\n\n  var pre = values[0];\n\n  if (value < values[0]) {\n    return NaN;\n  }\n\n  if (value >= values[length - 1]) {\n    return values[length - 1];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value < values[i]) {\n      break;\n    }\n\n    pre = values[i];\n  }\n\n  return pre;\n} // 大于当前值的第一个\n\n\nfunction arrayCeiling(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  } // var pre = values[0];\n\n\n  var rst;\n\n  if (value > values[length - 1]) {\n    return NaN;\n  }\n\n  if (value < values[0]) {\n    return values[0];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value <= values[i]) {\n      rst = values[i];\n      break;\n    }\n  }\n\n  return rst;\n}\n\nvar Util = {\n  // 获取逼近的数值\n  snapFactorTo: function snapFactorTo(v, arr, snapType) {\n    // 假设 v = -512,isFloor = true\n    if (isNaN(v)) {\n      return NaN;\n    }\n\n    var factor = 1; // 计算系数\n\n    if (v !== 0) {\n      if (v < 0) {\n        factor = -1;\n      }\n\n      v = v * factor; // v = 512\n\n      var tmpFactor = getFactor(v);\n      factor = factor * tmpFactor; // factor = -100\n\n      v = v / tmpFactor; // v = 5.12\n    }\n\n    if (snapType === 'floor') {\n      v = Util.snapFloor(arr, v); // v = 5\n    } else if (snapType === 'ceil') {\n      v = Util.snapCeiling(arr, v); // v = 6\n    } else {\n      v = Util.snapTo(arr, v); // 四舍五入 5\n    }\n\n    var rst = parseFloat((v * factor).toPrecision(DECIMAL_LENGTH)); // 如果出现浮点数计算问题，需要处理一下\n    // 如果出现浮点数计算问题，需要处理一下\n\n    if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {\n      var decimalVal = parseInt(1 / factor);\n      var symbol = factor > 0 ? 1 : -1;\n      rst = v / decimalVal * symbol;\n    }\n\n    return rst;\n  },\n  // 获取逼近的倍数\n  snapMultiple: function snapMultiple(v, base, snapType) {\n    var div;\n\n    if (snapType === 'ceil') {\n      div = Math.ceil(v / base);\n    } else if (snapType === 'floor') {\n      div = Math.floor(v / base);\n    } else {\n      div = Math.round(v / base);\n    }\n\n    return div * base;\n  },\n\n  /**\n   * 获取逼近的值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的值\n   */\n  snapTo: function snapTo(values, value) {\n    // 这里假定values是升序排列\n    var floorVal = arrayFloor(values, value);\n    var ceilingVal = arrayCeiling(values, value);\n\n    if (isNaN(floorVal) || isNaN(ceilingVal)) {\n      if (values[0] >= value) {\n        return values[0];\n      }\n\n      var last = values[values.length - 1];\n\n      if (last <= value) {\n        return last;\n      }\n    }\n\n    if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {\n      return floorVal;\n    }\n\n    return ceilingVal;\n  },\n\n  /**\n   * 获取逼近的最小值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最小值\n   */\n  snapFloor: function snapFloor(values, value) {\n    // 这里假定values是升序排列\n    return arrayFloor(values, value);\n  },\n\n  /**\n   * 获取逼近的最大值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最大值\n   */\n  snapCeiling: function snapCeiling(values, value) {\n    // 这里假定values是升序排列\n    return arrayCeiling(values, value);\n  },\n  fixedBase: function fixedBase(v, base) {\n    var str = base.toString();\n    var index = str.indexOf('.');\n    var indexOfExp = str.indexOf('e-'); // 判断是否带小数点，1.000001 1.23e-9\n\n    if (index < 0 && indexOfExp < 0) {\n      // base为整数\n      return Math.round(v);\n    }\n\n    var length = indexOfExp >= 0 ? parseInt(str.substr(indexOfExp + 2), 10) : str.substr(index + 1).length;\n\n    if (length > 20) {\n      length = 20;\n    }\n\n    return parseFloat(v.toFixed(length));\n  }\n};\nmodule.exports = Util;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_scale@0.1.4@@antv/scale/lib/auto/util.js"],"names":["DECIMAL_LENGTH","getFactor","v","factor","Infinity","Error","count","toString","length","parseFloat","toFixed","arrayFloor","values","value","NaN","pre","i","arrayCeiling","rst","Util","snapFactorTo","arr","snapType","isNaN","tmpFactor","snapFloor","snapCeiling","snapTo","toPrecision","Math","abs","decimalVal","parseInt","symbol","snapMultiple","base","div","ceil","floor","round","floorVal","ceilingVal","last","fixedBase","str","index","indexOf","indexOfExp","substr","module","exports"],"mappings":"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","sourcesContent":["/**\n * @fileOverview 计算方法\n * @author dxq613@gmail.com\n */\n// 如果小数点后面超过 10 位浮点数时进行一下处理\nvar DECIMAL_LENGTH = 12; // 获取系数\n\nfunction getFactor(v) {\n  var factor = 1;\n\n  if (v === Infinity || v === -Infinity) {\n    throw new Error('Not support Infinity!');\n  }\n\n  if (v < 1) {\n    var count = 0;\n\n    while (v < 1) {\n      factor = factor / 10;\n      v = v * 10;\n      count++;\n    } // 浮点数计算出现问题\n\n\n    if (factor.toString().length > DECIMAL_LENGTH) {\n      factor = parseFloat(factor.toFixed(count));\n    }\n  } else {\n    while (v > 10) {\n      factor = factor * 10;\n      v = v / 10;\n    }\n  }\n\n  return factor;\n} // 取小于当前值的\n\n\nfunction arrayFloor(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  }\n\n  var pre = values[0];\n\n  if (value < values[0]) {\n    return NaN;\n  }\n\n  if (value >= values[length - 1]) {\n    return values[length - 1];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value < values[i]) {\n      break;\n    }\n\n    pre = values[i];\n  }\n\n  return pre;\n} // 大于当前值的第一个\n\n\nfunction arrayCeiling(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  } // var pre = values[0];\n\n\n  var rst;\n\n  if (value > values[length - 1]) {\n    return NaN;\n  }\n\n  if (value < values[0]) {\n    return values[0];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value <= values[i]) {\n      rst = values[i];\n      break;\n    }\n  }\n\n  return rst;\n}\n\nvar Util = {\n  // 获取逼近的数值\n  snapFactorTo: function snapFactorTo(v, arr, snapType) {\n    // 假设 v = -512,isFloor = true\n    if (isNaN(v)) {\n      return NaN;\n    }\n\n    var factor = 1; // 计算系数\n\n    if (v !== 0) {\n      if (v < 0) {\n        factor = -1;\n      }\n\n      v = v * factor; // v = 512\n\n      var tmpFactor = getFactor(v);\n      factor = factor * tmpFactor; // factor = -100\n\n      v = v / tmpFactor; // v = 5.12\n    }\n\n    if (snapType === 'floor') {\n      v = Util.snapFloor(arr, v); // v = 5\n    } else if (snapType === 'ceil') {\n      v = Util.snapCeiling(arr, v); // v = 6\n    } else {\n      v = Util.snapTo(arr, v); // 四舍五入 5\n    }\n\n    var rst = parseFloat((v * factor).toPrecision(DECIMAL_LENGTH)); // 如果出现浮点数计算问题，需要处理一下\n    // 如果出现浮点数计算问题，需要处理一下\n\n    if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {\n      var decimalVal = parseInt(1 / factor);\n      var symbol = factor > 0 ? 1 : -1;\n      rst = v / decimalVal * symbol;\n    }\n\n    return rst;\n  },\n  // 获取逼近的倍数\n  snapMultiple: function snapMultiple(v, base, snapType) {\n    var div;\n\n    if (snapType === 'ceil') {\n      div = Math.ceil(v / base);\n    } else if (snapType === 'floor') {\n      div = Math.floor(v / base);\n    } else {\n      div = Math.round(v / base);\n    }\n\n    return div * base;\n  },\n\n  /**\n   * 获取逼近的值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的值\n   */\n  snapTo: function snapTo(values, value) {\n    // 这里假定values是升序排列\n    var floorVal = arrayFloor(values, value);\n    var ceilingVal = arrayCeiling(values, value);\n\n    if (isNaN(floorVal) || isNaN(ceilingVal)) {\n      if (values[0] >= value) {\n        return values[0];\n      }\n\n      var last = values[values.length - 1];\n\n      if (last <= value) {\n        return last;\n      }\n    }\n\n    if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {\n      return floorVal;\n    }\n\n    return ceilingVal;\n  },\n\n  /**\n   * 获取逼近的最小值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最小值\n   */\n  snapFloor: function snapFloor(values, value) {\n    // 这里假定values是升序排列\n    return arrayFloor(values, value);\n  },\n\n  /**\n   * 获取逼近的最大值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最大值\n   */\n  snapCeiling: function snapCeiling(values, value) {\n    // 这里假定values是升序排列\n    return arrayCeiling(values, value);\n  },\n  fixedBase: function fixedBase(v, base) {\n    var str = base.toString();\n    var index = str.indexOf('.');\n    var indexOfExp = str.indexOf('e-'); // 判断是否带小数点，1.000001 1.23e-9\n\n    if (index < 0 && indexOfExp < 0) {\n      // base为整数\n      return Math.round(v);\n    }\n\n    var length = indexOfExp >= 0 ? parseInt(str.substr(indexOfExp + 2), 10) : str.substr(index + 1).length;\n\n    if (length > 20) {\n      length = 20;\n    }\n\n    return parseFloat(v.toFixed(length));\n  }\n};\nmodule.exports = Util;"]},"metadata":{},"sourceType":"script"}