{"ast":null,"code":"/**\n * @fileOverview 计算分类的的坐标点\n * @author dxq613@gmail.com\n */\nvar each = require('@antv/util/lib/each');\n\nvar MAX_COUNT = 8;\nvar SUB_COUNT = 4; // 控制个数不能过小\n\nfunction getSimpleArray(data) {\n  var arr = [];\n  each(data, function (sub) {\n    arr = arr.concat(sub);\n  });\n  return arr;\n}\n\nfunction getGreatestFactor(count, number) {\n  var i;\n\n  for (i = number; i > 0; i--) {\n    if (count % i === 0) {\n      break;\n    }\n  } // 如果是素数，没有可以整除的数字\n\n\n  if (i === 1) {\n    for (i = number; i > 0; i--) {\n      if ((count - 1) % i === 0) {\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nmodule.exports = function (info) {\n  var rst = {};\n  var ticks = [];\n  var isRounding = info.isRounding;\n  var categories = getSimpleArray(info.data);\n  var length = categories.length;\n  var maxCount = info.maxCount || MAX_COUNT;\n  var tickCount;\n\n  if (isRounding) {\n    // 取整操作\n    tickCount = getGreatestFactor(length - 1, maxCount - 1) + 1; // 如果计算出来只有两个坐标点，则直接使用传入的 maxCount\n\n    if (tickCount === 2) {\n      tickCount = maxCount;\n    } else if (tickCount < maxCount - SUB_COUNT) {\n      tickCount = maxCount - SUB_COUNT;\n    }\n  } else {\n    tickCount = maxCount;\n  }\n\n  if (!isRounding && length <= tickCount + tickCount / 2) {\n    ticks = [].concat(categories);\n  } else {\n    var step = parseInt(length / (tickCount - 1), 10);\n    var groups = categories.map(function (e, i) {\n      return i % step === 0 ? categories.slice(i, i + step) : null;\n    }).filter(function (e) {\n      return e;\n    });\n\n    for (var i = 1, groupLen = groups.length; i < groupLen && (isRounding ? i * step < length - step : i < tickCount - 1); i++) {\n      ticks.push(groups[i][0]);\n    }\n\n    if (categories.length) {\n      ticks.unshift(categories[0]);\n      var last = categories[length - 1];\n\n      if (ticks.indexOf(last) === -1) {\n        ticks.push(last);\n      }\n    }\n  }\n\n  rst.categories = categories;\n  rst.ticks = ticks;\n  return rst;\n};","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_scale@0.1.4@@antv/scale/lib/auto/cat.js"],"names":["each","require","MAX_COUNT","SUB_COUNT","getSimpleArray","data","arr","sub","concat","getGreatestFactor","count","number","i","module","exports","info","rst","ticks","isRounding","categories","length","maxCount","tickCount","step","parseInt","groups","map","e","slice","filter","groupLen","push","unshift","last","indexOf"],"mappings":"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","sourcesContent":["/**\n * @fileOverview 计算分类的的坐标点\n * @author dxq613@gmail.com\n */\nvar each = require('@antv/util/lib/each');\n\nvar MAX_COUNT = 8;\nvar SUB_COUNT = 4; // 控制个数不能过小\n\nfunction getSimpleArray(data) {\n  var arr = [];\n  each(data, function (sub) {\n    arr = arr.concat(sub);\n  });\n  return arr;\n}\n\nfunction getGreatestFactor(count, number) {\n  var i;\n\n  for (i = number; i > 0; i--) {\n    if (count % i === 0) {\n      break;\n    }\n  } // 如果是素数，没有可以整除的数字\n\n\n  if (i === 1) {\n    for (i = number; i > 0; i--) {\n      if ((count - 1) % i === 0) {\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nmodule.exports = function (info) {\n  var rst = {};\n  var ticks = [];\n  var isRounding = info.isRounding;\n  var categories = getSimpleArray(info.data);\n  var length = categories.length;\n  var maxCount = info.maxCount || MAX_COUNT;\n  var tickCount;\n\n  if (isRounding) {\n    // 取整操作\n    tickCount = getGreatestFactor(length - 1, maxCount - 1) + 1; // 如果计算出来只有两个坐标点，则直接使用传入的 maxCount\n\n    if (tickCount === 2) {\n      tickCount = maxCount;\n    } else if (tickCount < maxCount - SUB_COUNT) {\n      tickCount = maxCount - SUB_COUNT;\n    }\n  } else {\n    tickCount = maxCount;\n  }\n\n  if (!isRounding && length <= tickCount + tickCount / 2) {\n    ticks = [].concat(categories);\n  } else {\n    var step = parseInt(length / (tickCount - 1), 10);\n    var groups = categories.map(function (e, i) {\n      return i % step === 0 ? categories.slice(i, i + step) : null;\n    }).filter(function (e) {\n      return e;\n    });\n\n    for (var i = 1, groupLen = groups.length; i < groupLen && (isRounding ? i * step < length - step : i < tickCount - 1); i++) {\n      ticks.push(groups[i][0]);\n    }\n\n    if (categories.length) {\n      ticks.unshift(categories[0]);\n      var last = categories[length - 1];\n\n      if (ticks.indexOf(last) === -1) {\n        ticks.push(last);\n      }\n    }\n  }\n\n  rst.categories = categories;\n  rst.ticks = ticks;\n  return rst;\n};"]},"metadata":{},"sourceType":"script"}