{"ast":null,"code":"const {\n  requestAnimationFrame\n} = require('../util/requestAnimationFrame');\n\nconst clock = typeof performance === 'object' && performance.now ? performance : Date;\n\nclass Timeline {\n  constructor() {\n    this.anims = [];\n    this.time = null;\n    this.playing = false;\n    this.canvas = [];\n  }\n\n  play() {\n    const self = this;\n    self.time = clock.now();\n    self.playing = true;\n\n    function step() {\n      if (self.playing) {\n        requestAnimationFrame(step);\n        self.update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  }\n\n  stop() {\n    this.playing = false;\n    this.time = null;\n    this.canvas = [];\n  }\n\n  update() {\n    const currentTime = clock.now();\n    this.canvas = [];\n\n    for (let i = 0; i < this.anims.length; i++) {\n      const propertyAnim = this.anims[i];\n\n      if (currentTime < propertyAnim.startTime || propertyAnim.hasEnded) {\n        continue;\n      }\n\n      const shape = propertyAnim.shape; // shape\n\n      if (shape.get('destroyed')) {\n        this.anims.splice(i, 1);\n        i--;\n        continue;\n      }\n\n      const {\n        startState,\n        endState,\n        interpolate,\n        duration\n      } = propertyAnim;\n\n      if (currentTime >= propertyAnim.startTime && !propertyAnim.hasStarted) {\n        propertyAnim.hasStarted = true;\n\n        if (propertyAnim.onStart) {\n          propertyAnim.onStart();\n        }\n      }\n\n      let t = (currentTime - propertyAnim.startTime) / duration;\n      t = Math.max(0, Math.min(t, 1));\n      t = propertyAnim.easing(t);\n\n      if (propertyAnim.onFrame) {\n        propertyAnim.onFrame(t);\n      } else {\n        for (const key in interpolate) {\n          const diff = interpolate[key];\n          const value = diff(t);\n          let newValue;\n\n          if (key === 'points') {\n            newValue = [];\n            const aLen = Math.max(startState.points.length, endState.points.length);\n\n            for (let j = 0; j < aLen; j += 2) {\n              newValue.push({\n                x: value[j],\n                y: value[j + 1]\n              });\n            }\n          } else {\n            newValue = value;\n          }\n\n          shape._attrs.attrs[key] = newValue;\n          shape._attrs.bbox = null; // should clear calculated bbox\n        }\n      }\n\n      const canvas = shape.get('canvas');\n\n      if (this.canvas.indexOf(canvas) === -1) {\n        this.canvas.push(canvas);\n      }\n\n      if (propertyAnim.onUpdate) {\n        propertyAnim.onUpdate(t);\n      }\n\n      if (currentTime >= propertyAnim.endTime && !propertyAnim.hasEnded) {\n        propertyAnim.hasEnded = true;\n\n        if (propertyAnim.onEnd) {\n          propertyAnim.onEnd();\n        }\n      }\n\n      if (t === 1) {\n        // end\n        this.anims.splice(i, 1);\n        i--;\n      }\n    }\n\n    this.canvas.map(c => {\n      c.draw();\n      return c;\n    });\n    this.time = clock.now();\n  }\n\n}\n\nmodule.exports = Timeline;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/graphic/animate/timeline.js"],"names":["requestAnimationFrame","require","clock","performance","now","Date","Timeline","constructor","anims","time","playing","canvas","play","self","step","update","stop","currentTime","i","length","propertyAnim","startTime","hasEnded","shape","get","splice","startState","endState","interpolate","duration","hasStarted","onStart","t","Math","max","min","easing","onFrame","key","diff","value","newValue","aLen","points","j","push","x","y","_attrs","attrs","bbox","indexOf","onUpdate","endTime","onEnd","map","c","draw","module","exports"],"mappings":"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","sourcesContent":["const { requestAnimationFrame } = require('../util/requestAnimationFrame');\nconst clock = typeof performance === 'object' && performance.now ? performance : Date;\n\nclass Timeline {\n  constructor() {\n    this.anims = [];\n    this.time = null;\n    this.playing = false;\n    this.canvas = [];\n  }\n\n  play() {\n    const self = this;\n    self.time = clock.now();\n    self.playing = true;\n\n    function step() {\n      if (self.playing) {\n        requestAnimationFrame(step);\n        self.update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  }\n\n  stop() {\n    this.playing = false;\n    this.time = null;\n    this.canvas = [];\n  }\n\n  update() {\n    const currentTime = clock.now();\n    this.canvas = [];\n\n    for (let i = 0; i < this.anims.length; i++) {\n      const propertyAnim = this.anims[i];\n      if (currentTime < propertyAnim.startTime || propertyAnim.hasEnded) {\n        continue;\n      }\n      const shape = propertyAnim.shape; // shape\n      if (shape.get('destroyed')) {\n        this.anims.splice(i, 1);\n        i--;\n        continue;\n      }\n\n      const { startState, endState, interpolate, duration } = propertyAnim;\n      if (currentTime >= propertyAnim.startTime && !propertyAnim.hasStarted) {\n        propertyAnim.hasStarted = true;\n        if (propertyAnim.onStart) {\n          propertyAnim.onStart();\n        }\n      }\n      let t = (currentTime - propertyAnim.startTime) / duration;\n      t = Math.max(0, Math.min(t, 1));\n      t = propertyAnim.easing(t);\n\n      if (propertyAnim.onFrame) {\n        propertyAnim.onFrame(t);\n      } else {\n        for (const key in interpolate) {\n          const diff = interpolate[key];\n          const value = diff(t);\n          let newValue;\n          if (key === 'points') {\n            newValue = [];\n            const aLen = Math.max(startState.points.length, endState.points.length);\n            for (let j = 0; j < aLen; j += 2) {\n              newValue.push({\n                x: value[j],\n                y: value[j + 1]\n              });\n            }\n          } else {\n            newValue = value;\n          }\n          shape._attrs.attrs[key] = newValue;\n          shape._attrs.bbox = null; // should clear calculated bbox\n        }\n      }\n\n      const canvas = shape.get('canvas');\n      if (this.canvas.indexOf(canvas) === -1) {\n        this.canvas.push(canvas);\n      }\n\n      if (propertyAnim.onUpdate) {\n        propertyAnim.onUpdate(t);\n      }\n\n      if (currentTime >= propertyAnim.endTime && !propertyAnim.hasEnded) {\n        propertyAnim.hasEnded = true;\n        if (propertyAnim.onEnd) {\n          propertyAnim.onEnd();\n        }\n      }\n\n      if (t === 1) { // end\n        this.anims.splice(i, 1);\n        i--;\n      }\n    }\n\n    this.canvas.map(c => {\n      c.draw();\n      return c;\n    });\n    this.time = clock.now();\n  }\n}\n\nmodule.exports = Timeline;\n"]},"metadata":{},"sourceType":"script"}