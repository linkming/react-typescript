{"ast":null,"code":"const Shape = require('./shape');\n\nconst Util = require('../../util/common');\n\nfunction _sortValue(value) {\n  const sorted = value.sort(function (a, b) {\n    return a < b ? 1 : -1;\n  });\n  const length = sorted.length;\n\n  if (length < 4) {\n    const min = sorted[length - 1];\n\n    for (let i = 0; i < 4 - length; i++) {\n      sorted.push(min);\n    }\n  }\n\n  return sorted;\n} // from left bottom corner, and clockwise\n\n\nfunction getCandlePoints(x, y, width) {\n  const yValues = _sortValue(y);\n\n  const points = [{\n    x,\n    y: yValues[0]\n  }, {\n    x,\n    y: yValues[1]\n  }, {\n    x: x - width / 2,\n    y: yValues[2]\n  }, {\n    x: x - width / 2,\n    y: yValues[1]\n  }, {\n    x: x + width / 2,\n    y: yValues[1]\n  }, {\n    x: x + width / 2,\n    y: yValues[2]\n  }, {\n    x,\n    y: yValues[2]\n  }, {\n    x,\n    y: yValues[3]\n  }];\n  return points;\n}\n\nconst Schema = Shape.registerFactory('schema', {});\nShape.registerShape('schema', 'candle', {\n  getPoints(cfg) {\n    return getCandlePoints(cfg.x, cfg.y, cfg.size);\n  },\n\n  draw(cfg, container) {\n    const points = this.parsePoints(cfg.points);\n    const style = Util.mix({\n      stroke: cfg.color,\n      fill: cfg.color,\n      lineWidth: 1\n    }, cfg.style);\n    return container.addShape('Custom', {\n      className: 'schema',\n      attrs: style,\n\n      createPath(ctx) {\n        ctx.beginPath();\n        ctx.moveTo(points[0].x, points[0].y);\n        ctx.lineTo(points[1].x, points[1].y);\n        ctx.moveTo(points[2].x, points[2].y);\n\n        for (let i = 3; i < 6; i++) {\n          ctx.lineTo(points[i].x, points[i].y);\n        }\n\n        ctx.closePath();\n        ctx.moveTo(points[6].x, points[6].y);\n        ctx.lineTo(points[7].x, points[7].y);\n      }\n\n    });\n  }\n\n});\nmodule.exports = Schema;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/geom/shape/schema.js"],"names":["Shape","require","Util","_sortValue","value","sorted","sort","a","b","length","min","i","push","getCandlePoints","x","y","width","yValues","points","Schema","registerFactory","registerShape","getPoints","cfg","size","draw","container","parsePoints","style","mix","stroke","color","fill","lineWidth","addShape","className","attrs","createPath","ctx","beginPath","moveTo","lineTo","closePath","module","exports"],"mappings":"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","sourcesContent":["const Shape = require('./shape');\nconst Util = require('../../util/common');\n\nfunction _sortValue(value) {\n  const sorted = value.sort(function(a, b) {\n    return a < b ? 1 : -1;\n  });\n\n  const length = sorted.length;\n  if (length < 4) {\n    const min = sorted[length - 1];\n    for (let i = 0; i < (4 - length); i++) {\n      sorted.push(min);\n    }\n  }\n  return sorted;\n}\n\n// from left bottom corner, and clockwise\nfunction getCandlePoints(x, y, width) {\n  const yValues = _sortValue(y);\n  const points = [{\n    x,\n    y: yValues[0]\n  }, {\n    x,\n    y: yValues[1]\n  }, {\n    x: x - width / 2,\n    y: yValues[2]\n  }, {\n    x: x - width / 2,\n    y: yValues[1]\n  }, {\n    x: x + width / 2,\n    y: yValues[1]\n  }, {\n    x: x + width / 2,\n    y: yValues[2]\n  }, {\n    x,\n    y: yValues[2]\n  }, {\n    x,\n    y: yValues[3]\n  }];\n  return points;\n}\n\nconst Schema = Shape.registerFactory('schema', {});\n\nShape.registerShape('schema', 'candle', {\n  getPoints(cfg) {\n    return getCandlePoints(cfg.x, cfg.y, cfg.size);\n  },\n  draw(cfg, container) {\n    const points = this.parsePoints(cfg.points);\n    const style = Util.mix({\n      stroke: cfg.color,\n      fill: cfg.color,\n      lineWidth: 1\n    }, cfg.style);\n    return container.addShape('Custom', {\n      className: 'schema',\n      attrs: style,\n      createPath(ctx) {\n        ctx.beginPath();\n        ctx.moveTo(points[0].x, points[0].y);\n        ctx.lineTo(points[1].x, points[1].y);\n\n        ctx.moveTo(points[2].x, points[2].y);\n        for (let i = 3; i < 6; i++) {\n          ctx.lineTo(points[i].x, points[i].y);\n        }\n        ctx.closePath();\n        ctx.moveTo(points[6].x, points[6].y);\n        ctx.lineTo(points[7].x, points[7].y);\n      }\n    });\n  }\n});\n\nmodule.exports = Schema;\n"]},"metadata":{},"sourceType":"script"}