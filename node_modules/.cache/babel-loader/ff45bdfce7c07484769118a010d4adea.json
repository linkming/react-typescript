{"ast":null,"code":"const Util = require('../../util/common');\n\nconst Shape = require('./shape');\n\nconst Smooth = require('../../graphic/util/smooth');\n\nconst bbox = require('../../graphic/util/bbox');\n\nconst Global = require('../../global');\n\nfunction equals(v1, v2) {\n  return Math.abs(v1 - v2) < 0.00001;\n}\n\nfunction notEmpty(value) {\n  return !isNaN(value) && !Util.isNil(value);\n}\n\nfunction filterPoints(points) {\n  const filteredPoints = []; // filter the point which x or y is NaN\n\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n\n    if (notEmpty(point.x) && notEmpty(point.y)) {\n      filteredPoints.push(point);\n    }\n  }\n\n  return filteredPoints;\n}\n\nfunction equalsCenter(points, center) {\n  let eqls = true;\n  Util.each(points, function (point) {\n    if (!equals(point.x, center.x) || !equals(point.y, center.y)) {\n      eqls = false;\n      return false;\n    }\n  });\n  return eqls;\n}\n\nfunction drawRectShape(topPoints, bottomPoints, container, style, isSmooth) {\n  let shape;\n  const points = topPoints.concat(bottomPoints);\n\n  if (isSmooth) {\n    shape = container.addShape('Custom', {\n      className: 'area',\n      attrs: Util.mix({\n        points\n      }, style),\n\n      createPath(context) {\n        const constaint = [[0, 0], [1, 1]];\n        const points = filterPoints(this._attrs.attrs.points);\n        const pointsLen = points.length;\n        const topPoints = points.slice(0, pointsLen / 2);\n        const bottomPoints = points.slice(pointsLen / 2, pointsLen);\n        const topSps = Smooth.smooth(topPoints, false, constaint);\n        context.beginPath();\n        context.moveTo(topPoints[0].x, topPoints[0].y);\n\n        for (let i = 0, n = topSps.length; i < n; i++) {\n          const sp = topSps[i];\n          context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\n        }\n\n        if (bottomPoints.length) {\n          const bottomSps = Smooth.smooth(bottomPoints, false, constaint);\n          context.lineTo(bottomPoints[0].x, bottomPoints[0].y);\n\n          for (let i = 0, n = bottomSps.length; i < n; i++) {\n            const sp = bottomSps[i];\n            context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\n          }\n        }\n\n        context.closePath();\n      },\n\n      calculateBox() {\n        const points = filterPoints(this._attrs.attrs.points);\n        return bbox.getBBoxFromPoints(points);\n      }\n\n    });\n  } else {\n    shape = container.addShape('Polyline', {\n      className: 'area',\n      attrs: Util.mix({\n        points\n      }, style)\n    });\n  }\n\n  return shape;\n}\n\nfunction drawShape(cfg, container, isSmooth) {\n  const self = this;\n  const points = cfg.points;\n  let topPoints = [];\n  let bottomPoints = [];\n  Util.each(points, function (point) {\n    bottomPoints.push(point[0]);\n    topPoints.push(point[1]);\n  });\n  const style = Util.mix({\n    fillStyle: cfg.color\n  }, Global.shape.area, cfg.style);\n  bottomPoints.reverse();\n  topPoints = self.parsePoints(topPoints);\n  bottomPoints = self.parsePoints(bottomPoints);\n\n  if (cfg.isInCircle) {\n    topPoints.push(topPoints[0]);\n    bottomPoints.unshift(bottomPoints[bottomPoints.length - 1]);\n\n    if (equalsCenter(bottomPoints, cfg.center)) {\n      bottomPoints = [];\n    }\n  }\n\n  return drawRectShape(topPoints, bottomPoints, container, style, isSmooth);\n}\n\nconst Area = Shape.registerFactory('area', {\n  defaultShapeType: 'area',\n\n  getDefaultPoints(obj) {\n    const x = obj.x;\n    let y = obj.y;\n    const y0 = obj.y0;\n    y = Util.isArray(y) ? y : [y0, y];\n    const points = [];\n    points.push({\n      x,\n      y: y[0]\n    }, {\n      x,\n      y: y[1]\n    });\n    return points;\n  }\n\n});\nconst SHAPES = ['area', 'smooth'];\nUtil.each(SHAPES, function (shapeType) {\n  Shape.registerShape('area', shapeType, {\n    draw(cfg, container) {\n      const smooth = shapeType === 'smooth';\n      return drawShape.call(this, cfg, container, smooth);\n    }\n\n  });\n});\nmodule.exports = Area;","map":{"version":3,"sources":["/home/sunxuming/react-typescript/node_modules/_@antv_f2@3.6.0-alpha.2@@antv/f2/src/geom/shape/area.js"],"names":["Util","require","Shape","Smooth","bbox","Global","equals","v1","v2","Math","abs","notEmpty","value","isNaN","isNil","filterPoints","points","filteredPoints","i","len","length","point","x","y","push","equalsCenter","center","eqls","each","drawRectShape","topPoints","bottomPoints","container","style","isSmooth","shape","concat","addShape","className","attrs","mix","createPath","context","constaint","_attrs","pointsLen","slice","topSps","smooth","beginPath","moveTo","n","sp","bezierCurveTo","bottomSps","lineTo","closePath","calculateBox","getBBoxFromPoints","drawShape","cfg","self","fillStyle","color","area","reverse","parsePoints","isInCircle","unshift","Area","registerFactory","defaultShapeType","getDefaultPoints","obj","y0","isArray","SHAPES","shapeType","registerShape","draw","call","module","exports"],"mappings":"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","sourcesContent":["const Util = require('../../util/common');\nconst Shape = require('./shape');\nconst Smooth = require('../../graphic/util/smooth');\nconst bbox = require('../../graphic/util/bbox');\nconst Global = require('../../global');\n\nfunction equals(v1, v2) {\n  return Math.abs(v1 - v2) < 0.00001;\n}\n\nfunction notEmpty(value) {\n  return !isNaN(value) && !Util.isNil(value);\n}\n\nfunction filterPoints(points) {\n  const filteredPoints = [];\n  // filter the point which x or y is NaN\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (notEmpty(point.x) && notEmpty(point.y)) {\n      filteredPoints.push(point);\n    }\n  }\n\n  return filteredPoints;\n}\n\nfunction equalsCenter(points, center) {\n  let eqls = true;\n  Util.each(points, function(point) {\n    if (!equals(point.x, center.x) || !equals(point.y, center.y)) {\n      eqls = false;\n      return false;\n    }\n  });\n  return eqls;\n}\n\nfunction drawRectShape(topPoints, bottomPoints, container, style, isSmooth) {\n  let shape;\n  const points = topPoints.concat(bottomPoints);\n  if (isSmooth) {\n    shape = container.addShape('Custom', {\n      className: 'area',\n      attrs: Util.mix({\n        points\n      }, style),\n      createPath(context) {\n        const constaint = [\n          [ 0, 0 ],\n          [ 1, 1 ]\n        ];\n        const points = filterPoints(this._attrs.attrs.points);\n\n        const pointsLen = points.length;\n        const topPoints = points.slice(0, pointsLen / 2);\n        const bottomPoints = points.slice(pointsLen / 2, pointsLen);\n        const topSps = Smooth.smooth(topPoints, false, constaint);\n        context.beginPath();\n        context.moveTo(topPoints[0].x, topPoints[0].y);\n        for (let i = 0, n = topSps.length; i < n; i++) {\n          const sp = topSps[i];\n          context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\n        }\n\n        if (bottomPoints.length) {\n          const bottomSps = Smooth.smooth(bottomPoints, false, constaint);\n          context.lineTo(bottomPoints[0].x, bottomPoints[0].y);\n          for (let i = 0, n = bottomSps.length; i < n; i++) {\n            const sp = bottomSps[i];\n            context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\n          }\n        }\n        context.closePath();\n      },\n      calculateBox() {\n        const points = filterPoints(this._attrs.attrs.points);\n        return bbox.getBBoxFromPoints(points);\n      }\n    });\n  } else {\n    shape = container.addShape('Polyline', {\n      className: 'area',\n      attrs: Util.mix({\n        points\n      }, style)\n    });\n  }\n  return shape;\n}\n\nfunction drawShape(cfg, container, isSmooth) {\n  const self = this;\n  const points = cfg.points;\n  let topPoints = [];\n  let bottomPoints = [];\n  Util.each(points, function(point) {\n    bottomPoints.push(point[0]);\n    topPoints.push(point[1]);\n  });\n  const style = Util.mix({\n    fillStyle: cfg.color\n  }, Global.shape.area, cfg.style);\n\n  bottomPoints.reverse();\n  topPoints = self.parsePoints(topPoints);\n  bottomPoints = self.parsePoints(bottomPoints);\n  if (cfg.isInCircle) {\n    topPoints.push(topPoints[0]);\n    bottomPoints.unshift(bottomPoints[bottomPoints.length - 1]);\n    if (equalsCenter(bottomPoints, cfg.center)) {\n      bottomPoints = [];\n    }\n  }\n\n  return drawRectShape(topPoints, bottomPoints, container, style, isSmooth);\n}\n\nconst Area = Shape.registerFactory('area', {\n  defaultShapeType: 'area',\n  getDefaultPoints(obj) {\n    const x = obj.x;\n    let y = obj.y;\n    const y0 = obj.y0;\n    y = Util.isArray(y) ? y : [ y0, y ];\n\n    const points = [];\n    points.push({\n      x,\n      y: y[0]\n    }, {\n      x,\n      y: y[1]\n    });\n    return points;\n  }\n});\n\nconst SHAPES = [ 'area', 'smooth' ];\nUtil.each(SHAPES, function(shapeType) {\n  Shape.registerShape('area', shapeType, {\n    draw(cfg, container) {\n      const smooth = (shapeType === 'smooth');\n      return drawShape.call(this, cfg, container, smooth);\n    }\n  });\n});\n\nmodule.exports = Area;\n"]},"metadata":{},"sourceType":"script"}